/* eslint-disable */
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  normalizeScopeRootsWithMode: () => normalizeScopeRootsWithMode,
  default: () => KnowledgeWeaverPlugin
});
module.exports = __toCommonJS(main_exports);
var import_child_process = require("child_process");
var nodeCrypto = __toESM(require("crypto"));
var nodeFs = __toESM(require("fs"));
var nodeHttp = __toESM(require("http"));
var nodeOs = __toESM(require("os"));
var nodePath = __toESM(require("path"));
var import_util = require("util");
var import_obsidian4 = require("obsidian");

// src/frontmatter.ts
var import_obsidian = require("obsidian");
var MANAGED_KEYS = ["tags", "topic", "linked", "index"];
var MANAGED_KEY_SET = new Set(MANAGED_KEYS.map((key) => key.toLowerCase()));
var PROTECTED_FRONTMATTER_KEYS = /* @__PURE__ */ new Set([
  "date created",
  "date modified",
  "date updated",
  "date_created",
  "date_modified",
  "date_updated",
  "created",
  "updated",
  "modified"
]);
var LEGACY_REMOVABLE_KEY_PREFIXES = ["ai_", "autolinker_", "auto_linker_"];
function toStringArray(value) {
  if (Array.isArray(value)) {
    return value.map((item) => typeof item === "string" ? item.trim() : "").filter(Boolean);
  }
  if (typeof value === "string") {
    return value.split(",").map((item) => item.trim()).filter(Boolean);
  }
  return [];
}
function toSingleString(value) {
  if (typeof value !== "string") {
    return void 0;
  }
  const normalized = value.trim();
  return normalized.length > 0 ? normalized : void 0;
}
function normalizeTag(rawTag) {
  const normalized = rawTag.trim().replace(/^#+/, "").replace(/\s+/g, "-").replace(/[`"'\\]+/g, "");
  if (!normalized) {
    return "";
  }
  const lower = normalized.toLowerCase();
  const looksLikePath = normalized.startsWith("/") || normalized.startsWith("./") || normalized.startsWith("../") || /^[A-Za-z]:[\\/]/.test(normalized) || /^\/(usr|bin|sbin|etc|opt|var|tmp|home|users)\//i.test(lower) || lower.startsWith("usr/bin/") || lower.includes("/usr/bin/env");
  const looksLikeCode = normalized.startsWith("!") || normalized.startsWith("#!") || normalized.includes("://") || /[{}()[\];|<>$]/.test(normalized);
  if (looksLikePath || looksLikeCode || normalized.length > 64) {
    return "";
  }
  if (!/[0-9A-Za-z가-힣]/.test(normalized)) {
    return "";
  }
  return normalized;
}
function normalizeTags(tags) {
  const deduped = /* @__PURE__ */ new Set();
  for (const rawTag of tags) {
    const normalized = normalizeTag(rawTag);
    if (normalized) {
      deduped.add(normalized);
    }
  }
  return [...deduped];
}
function stripWikiSyntax(raw) {
  return raw.trim().replace(/^\[\[/, "").replace(/\]\]$/, "").split("|")[0].split("#")[0].trim();
}
function resolveExistingMarkdownFile(app, sourcePath, rawLink) {
  const cleaned = stripWikiSyntax(rawLink);
  if (!cleaned) {
    return null;
  }
  const directPath = cleaned.endsWith(".md") ? cleaned : `${cleaned}.md`;
  const direct = app.vault.getAbstractFileByPath((0, import_obsidian.normalizePath)(directPath));
  if (direct instanceof import_obsidian.TFile && direct.extension === "md") {
    return direct;
  }
  const resolved = app.metadataCache.getFirstLinkpathDest(cleaned, sourcePath);
  if (resolved instanceof import_obsidian.TFile && resolved.extension === "md") {
    return resolved;
  }
  return null;
}
function normalizeLinked(app, sourcePath, linked, allowedPaths) {
  const deduped = /* @__PURE__ */ new Set();
  for (const candidate of linked) {
    const file = resolveExistingMarkdownFile(app, sourcePath, candidate);
    if (!file) {
      continue;
    }
    if (allowedPaths && !allowedPaths.has(file.path)) {
      continue;
    }
    if (file.path === sourcePath) {
      continue;
    }
    const linkText = app.metadataCache.fileToLinktext(file, sourcePath, true);
    deduped.add(`[[${linkText}]]`);
  }
  return [...deduped];
}
function extractManagedFrontmatter(frontmatter) {
  const source = frontmatter != null ? frontmatter : {};
  return {
    tags: normalizeTags(toStringArray(source.tags)),
    topic: toSingleString(source.topic),
    linked: toStringArray(source.linked),
    index: toSingleString(source.index)
  };
}
function normalizeManagedFrontmatter(managed) {
  var _a, _b;
  const topic = (_a = managed.topic) == null ? void 0 : _a.trim();
  const index = (_b = managed.index) == null ? void 0 : _b.trim();
  return {
    tags: normalizeTags(managed.tags),
    topic: topic && topic.length > 0 ? topic : void 0,
    linked: managed.linked.map((item) => item.trim()).filter(Boolean).filter((item, idx, arr) => arr.indexOf(item) === idx),
    index: index && index.length > 0 ? index : void 0
  };
}
function shouldRemoveByRules(normalizedKey, options) {
  var _a, _b, _c, _d;
  if (PROTECTED_FRONTMATTER_KEYS.has(normalizedKey)) {
    return false;
  }
  const keepKeys = (_a = options.cleanupConfig) == null ? void 0 : _a.keepKeys;
  if (keepKeys && keepKeys.has(normalizedKey)) {
    return false;
  }
  const legacyRemovable = LEGACY_REMOVABLE_KEY_PREFIXES.some(
    (prefix) => normalizedKey.startsWith(prefix)
  );
  if (options.cleanUnknown && legacyRemovable) {
    return true;
  }
  const removeKeys = (_b = options.cleanupConfig) == null ? void 0 : _b.removeKeys;
  if (removeKeys && removeKeys.has(normalizedKey)) {
    return true;
  }
  const removePrefixes = (_d = (_c = options.cleanupConfig) == null ? void 0 : _c.removePrefixes) != null ? _d : [];
  if (removePrefixes.some((prefix) => normalizedKey.startsWith(prefix))) {
    return true;
  }
  return false;
}
function buildRetainedFrontmatter(current, options) {
  const next = {};
  const removedKeys = [];
  for (const [key, value] of Object.entries(current)) {
    const normalizedKey = key.trim().toLowerCase();
    const isManaged = MANAGED_KEY_SET.has(normalizedKey);
    if (isManaged && options.dropManaged) {
      removedKeys.push(key);
      continue;
    }
    if (shouldRemoveByRules(normalizedKey, options)) {
      removedKeys.push(key);
      continue;
    }
    next[key] = value;
  }
  return { next, removedKeys };
}
function cleanupFrontmatterRecord(current, options) {
  return buildRetainedFrontmatter(current, {
    cleanUnknown: options.cleanUnknown,
    cleanupConfig: options.cleanupConfig,
    dropManaged: false
  });
}
function buildNextFrontmatter(current, proposed, options) {
  const { next } = buildRetainedFrontmatter(current, {
    cleanUnknown: options.cleanUnknown,
    cleanupConfig: options.cleanupConfig,
    dropManaged: true
  });
  const tags = options.sortArrays ? [...proposed.tags].sort((a, b) => a.localeCompare(b)) : [...proposed.tags];
  const linked = options.sortArrays ? [...proposed.linked].sort((a, b) => a.localeCompare(b)) : [...proposed.linked];
  if (tags.length > 0) {
    next.tags = tags;
  }
  if (proposed.topic) {
    next.topic = proposed.topic;
  }
  if (linked.length > 0) {
    next.linked = linked;
  }
  if (proposed.index) {
    next.index = proposed.index;
  }
  return next;
}
function managedFrontmatterChanged(before, after) {
  if (before.topic !== after.topic) {
    return true;
  }
  if (before.index !== after.index) {
    return true;
  }
  const beforeTags = before.tags.join("\0");
  const afterTags = after.tags.join("\0");
  if (beforeTags !== afterTags) {
    return true;
  }
  const beforeLinked = before.linked.join("\0");
  const afterLinked = after.linked.join("\0");
  return beforeLinked !== afterLinked;
}

// src/providers.ts
var import_obsidian2 = require("obsidian");
function truncate(text, max) {
  return text.length <= max ? text : text.slice(0, max);
}
function extractJsonFromText(text) {
  const trimmed = text.trim();
  try {
    const parsed = JSON.parse(trimmed);
    if (parsed && typeof parsed === "object") {
      return parsed;
    }
  } catch (e) {
  }
  const fencedMatch = trimmed.match(/```(?:json)?\s*([\s\S]*?)```/i);
  if (fencedMatch == null ? void 0 : fencedMatch[1]) {
    try {
      const parsed = JSON.parse(fencedMatch[1].trim());
      if (parsed && typeof parsed === "object") {
        return parsed;
      }
    } catch (e) {
    }
  }
  const firstBrace = trimmed.indexOf("{");
  const lastBrace = trimmed.lastIndexOf("}");
  if (firstBrace !== -1 && lastBrace > firstBrace) {
    const candidate = trimmed.slice(firstBrace, lastBrace + 1);
    try {
      const parsed = JSON.parse(candidate);
      if (parsed && typeof parsed === "object") {
        return parsed;
      }
    } catch (e) {
    }
  }
  return null;
}
function toStringArray2(value) {
  if (!Array.isArray(value)) {
    return [];
  }
  return value.map((item) => typeof item === "string" ? item.trim() : "").filter(Boolean);
}
function toOptionalString(value) {
  if (typeof value !== "string") {
    return void 0;
  }
  const normalized = value.trim();
  return normalized.length > 0 ? normalized : void 0;
}
function toReasons(value) {
  if (!value || typeof value !== "object") {
    return {};
  }
  const asRecord = value;
  return {
    tags: toOptionalString(asRecord.tags),
    topic: toOptionalString(asRecord.topic),
    linked: toOptionalString(asRecord.linked),
    index: toOptionalString(asRecord.index)
  };
}
function sanitizeProposal(record) {
  return {
    tags: toStringArray2(record.tags),
    topic: toOptionalString(record.topic),
    linked: toStringArray2(record.linked),
    index: toOptionalString(record.index),
    reasons: toReasons(record.reasons)
  };
}
function buildPrompt(request) {
  const candidateList = request.candidateLinkPaths.map((path) => `- ${path}`).join("\n");
  const source = truncate(request.sourceText, 12e3);
  return [
    "You generate Obsidian frontmatter metadata for a single note.",
    "Return JSON only with this exact schema:",
    "{",
    '  "tags": string[],',
    '  "topic": string,',
    '  "linked": string[],',
    '  "index": string,',
    '  "reasons": { "tags": string, "topic": string, "linked": string, "index": string }',
    "}",
    "Rules:",
    "- linked MUST only contain values from the candidate list exactly.",
    "- Keep tags concise. No leading #.",
    "- Tags must be conceptual topics only (no shell commands, file paths, shebangs, URLs, or code snippets).",
    "- topic should be one short phrase.",
    "- index should be one category label.",
    `- max tags: ${request.maxTags}`,
    `- max linked: ${request.maxLinked}`,
    "- If a field is disabled, return empty value for it.",
    `- analyze tags: ${request.analyzeTags}`,
    `- analyze topic: ${request.analyzeTopic}`,
    `- analyze linked: ${request.analyzeLinked}`,
    `- analyze index: ${request.analyzeIndex}`,
    `- include reasons: ${request.includeReasons}`,
    "",
    `Source path: ${request.sourcePath}`,
    "Candidate links:",
    candidateList || "- (none)",
    "",
    "Note content:",
    source
  ].join("\n");
}
var BaseProvider = class {
  constructor(settings) {
    this.settings = settings;
  }
  parseOrThrow(rawText) {
    const parsed = extractJsonFromText(rawText);
    if (!parsed) {
      throw new Error("Provider returned non-JSON output.");
    }
    return sanitizeProposal(parsed);
  }
};
var OllamaProvider = class extends BaseProvider {
  async analyze(request) {
    var _a;
    const url = `${this.settings.ollamaBaseUrl.replace(/\/$/, "")}/api/generate`;
    const response = await (0, import_obsidian2.requestUrl)({
      url,
      method: "POST",
      contentType: "application/json",
      body: JSON.stringify({
        model: this.settings.ollamaModel,
        prompt: buildPrompt(request),
        stream: false,
        format: "json"
      }),
      throw: false
    });
    if (response.status >= 300) {
      throw new Error(`Ollama request failed: ${response.status}`);
    }
    const responseBody = typeof ((_a = response.json) == null ? void 0 : _a.response) === "string" ? response.json.response : response.text;
    return this.parseOrThrow(responseBody);
  }
};
var OpenAICompatibleProvider = class extends BaseProvider {
  constructor(settings, config) {
    super(settings);
    this.config = config;
  }
  async analyze(request) {
    var _a, _b, _c, _d;
    const url = `${this.config.baseUrl.replace(/\/$/, "")}/chat/completions`;
    const headers = {};
    if (typeof this.config.getAuthHeaders === "function") {
      const authHeaders = await this.config.getAuthHeaders();
      if (authHeaders && typeof authHeaders === "object") {
        Object.assign(headers, authHeaders);
      }
    } else if (this.config.apiKey) {
      headers.Authorization = `Bearer ${this.config.apiKey}`;
    }
    const response = await (0, import_obsidian2.requestUrl)({
      url,
      method: "POST",
      headers,
      contentType: "application/json",
      body: JSON.stringify({
        model: this.config.model,
        messages: [
          {
            role: "system",
            content: "You are an assistant that returns strict JSON for Obsidian metadata."
          },
          { role: "user", content: buildPrompt(request) }
        ],
        temperature: 0.2
      }),
      throw: false
    });
    if (response.status >= 300) {
      throw new Error(`OpenAI-compatible request failed: ${response.status}`);
    }
    const content = (_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content;
    if (typeof content !== "string") {
      throw new Error("OpenAI-compatible response missing content.");
    }
    return this.parseOrThrow(content);
  }
};
var AnthropicProvider = class extends BaseProvider {
  async analyze(request) {
    var _a, _b, _c;
    const apiKey = this.settings.anthropicApiKey.trim();
    if (!apiKey) {
      throw new Error("Anthropic API key is missing.");
    }
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "x-api-key": apiKey,
        "anthropic-version": "2023-06-01"
      },
      contentType: "application/json",
      body: JSON.stringify({
        model: this.settings.anthropicModel,
        max_tokens: 1e3,
        temperature: 0.2,
        messages: [
          {
            role: "user",
            content: buildPrompt(request)
          }
        ]
      }),
      throw: false
    });
    if (response.status >= 300) {
      throw new Error(`Anthropic request failed: ${response.status}`);
    }
    const content = (_c = (_b = (_a = response.json) == null ? void 0 : _a.content) == null ? void 0 : _b[0]) == null ? void 0 : _c.text;
    if (typeof content !== "string") {
      throw new Error("Anthropic response missing text.");
    }
    return this.parseOrThrow(content);
  }
};
var GeminiProvider = class extends BaseProvider {
  async analyze(request) {
    var _a, _b, _c, _d, _e, _f;
    const apiKey = this.settings.geminiApiKey.trim();
    if (!apiKey) {
      throw new Error("Gemini API key is missing.");
    }
    const model = this.settings.geminiModel.trim();
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(
      model
    )}:generateContent?key=${encodeURIComponent(apiKey)}`;
    const response = await (0, import_obsidian2.requestUrl)({
      url,
      method: "POST",
      contentType: "application/json",
      body: JSON.stringify({
        generationConfig: {
          temperature: 0.2
        },
        contents: [
          {
            parts: [
              {
                text: buildPrompt(request)
              }
            ]
          }
        ]
      }),
      throw: false
    });
    if (response.status >= 300) {
      throw new Error(`Gemini request failed: ${response.status}`);
    }
    const content = (_f = (_e = (_d = (_c = (_b = (_a = response.json) == null ? void 0 : _a.candidates) == null ? void 0 : _b[0]) == null ? void 0 : _c.content) == null ? void 0 : _d.parts) == null ? void 0 : _e[0]) == null ? void 0 : _f.text;
    if (typeof content !== "string") {
      throw new Error("Gemini response missing text.");
    }
    return this.parseOrThrow(content);
  }
};
var HeuristicFallbackProvider = class extends BaseProvider {
  async analyze(request) {
    const tags = request.analyzeTags ? extractHashTags(request.sourceText).slice(0, request.maxTags) : [];
    const topic = request.analyzeTopic ? extractTopicFromContent(request.sourceText, request.sourcePath) : void 0;
    const linked = request.analyzeLinked ? request.candidateLinkPaths.slice(0, request.maxLinked) : [];
    const index = request.analyzeIndex ? extractIndexFromPath(request.sourcePath) : void 0;
    return {
      tags,
      topic,
      linked,
      index,
      reasons: request.includeReasons ? {
        tags: request.analyzeTags ? "Found hashtag-like tokens in the note text." : void 0,
        topic: request.analyzeTopic ? "Used the first heading or note title." : void 0,
        linked: request.analyzeLinked ? "Used top candidates because AI provider was unavailable." : void 0,
        index: request.analyzeIndex ? "Used top-level folder name as category." : void 0
      } : {}
    };
  }
};
function extractHashTags(sourceText) {
  const found = /* @__PURE__ */ new Set();
  const regex = /(^|\s)#([^\s#]+)/g;
  let match = regex.exec(sourceText);
  while (match) {
    found.add(match[2].trim());
    match = regex.exec(sourceText);
  }
  return [...found];
}
function extractTopicFromContent(sourceText, sourcePath) {
  var _a;
  const firstHeading = sourceText.split("\n").map((line) => line.trim()).find((line) => /^#\s+\S+/.test(line));
  if (firstHeading) {
    return firstHeading.replace(/^#\s+/, "").trim();
  }
  const fileName = (_a = sourcePath.split("/").pop()) != null ? _a : sourcePath;
  return fileName.replace(/\.md$/i, "");
}
function extractIndexFromPath(sourcePath) {
  const chunks = sourcePath.split("/");
  if (chunks.length <= 1) {
    return void 0;
  }
  return chunks[0].trim() || void 0;
}
function toOpenAICompatibleBase(baseUrl) {
  const cleaned = baseUrl.replace(/\/+$/, "").replace(/\/v1$/, "");
  return `${cleaned}/v1`;
}
function toBase64Url(input) {
  return input.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}
function parseOAuthTokenPayload(response) {
  var _a;
  if (((_a = response == null ? void 0 : response.json) == null ? void 0 : _a.constructor) === Object || Array.isArray(response == null ? void 0 : response.json)) {
    return response.json;
  }
  const rawText = typeof (response == null ? void 0 : response.text) === "string" ? response.text.trim() : "";
  if (!rawText) {
    return {};
  }
  try {
    return JSON.parse(rawText);
  } catch (e) {
    return {};
  }
}
function resolveOAuthTokenExpiryMs(payload) {
  if (!payload || typeof payload !== "object") {
    return 0;
  }
  const expiresIn = Number(payload.expires_in);
  if (Number.isFinite(expiresIn) && expiresIn > 0) {
    return Date.now() + Math.floor(expiresIn * 1e3);
  }
  const expiresAtRaw = payload.expires_at;
  const expiresAtNumber = Number(expiresAtRaw);
  if (Number.isFinite(expiresAtNumber) && expiresAtNumber > 0) {
    return expiresAtNumber > 1e12 ? Math.floor(expiresAtNumber) : Math.floor(expiresAtNumber * 1e3);
  }
  if (typeof expiresAtRaw === "string" && expiresAtRaw.trim()) {
    const parsed = Date.parse(expiresAtRaw);
    if (Number.isFinite(parsed) && parsed > 0) {
      return parsed;
    }
  }
  return 0;
}
function tokenFreshStatusForSummary(accessTokenPresent, expiryMs) {
  if (!accessTokenPresent) {
    return "required";
  }
  if (!expiryMs) {
    return "not required (non-expiring token)";
  }
  return Date.now() < expiryMs ? "not required" : "required";
}
function isCloudProviderForOAuthBridge(provider) {
  return provider === "openai" || provider === "anthropic" || provider === "gemini";
}
function getProviderModelLabelRaw(settings) {
  switch (settings.provider) {
    case "ollama":
      return settings.ollamaModel;
    case "lmstudio":
      return settings.lmStudioModel;
    case "openai":
      return settings.openAIModel;
    case "anthropic":
      return settings.anthropicModel;
    case "gemini":
      return settings.geminiModel;
    default:
      return "unknown";
  }
}
function resolveOAuthBridgeBaseUrl(settings) {
  const bridgeBase = typeof settings.oauthBridgeBaseUrl === "string" ? settings.oauthBridgeBaseUrl.trim() : "";
  const fallbackOpenAIBase = typeof settings.openAIBaseUrl === "string" ? settings.openAIBaseUrl.trim() : "";
  return toOpenAICompatibleBase(
    bridgeBase || fallbackOpenAIBase || DEFAULT_SETTINGS.openAIBaseUrl || "https://api.openai.com/v1"
  );
}
function resolveOAuthBridgeModel(settings) {
  const override = typeof settings.oauthBridgeModel === "string" ? settings.oauthBridgeModel.trim() : "";
  return override || getProviderModelLabelRaw(settings);
}
function resolveCloudProviderApiKey(settings) {
  switch (settings.provider) {
    case "anthropic":
      return settings.anthropicApiKey.trim() || settings.openAIApiKey.trim() || void 0;
    case "gemini":
      return settings.geminiApiKey.trim() || settings.openAIApiKey.trim() || void 0;
    case "openai":
      return settings.openAIApiKey.trim() || void 0;
    default:
      return void 0;
  }
}
function getProviderModelLabel(settings) {
  if (settings.oauthBridgeEnabled === true && isCloudProviderForOAuthBridge(settings.provider)) {
    return resolveOAuthBridgeModel(settings);
  }
  return getProviderModelLabelRaw(settings);
}
function scoreOllamaModel(modelName) {
  if (!isOllamaModelAnalyzable(modelName)) {
    return -100;
  }
  const lower = modelName.toLowerCase();
  let score = 0;
  if (/qwen2\.5|qwen3|llama3\.1|llama3\.2|mistral|gemma2|phi-?4/.test(lower)) {
    score += 20;
  }
  if (/instruct|chat|it\b/.test(lower)) {
    score += 10;
  }
  if (/:8b|:7b|:9b/.test(lower)) {
    score += 8;
  }
  if (/:4b|:3b/.test(lower)) {
    score += 5;
  }
  if (/:1b|:0\.[0-9]+b/.test(lower)) {
    score -= 3;
  }
  return score;
}
var UNAVAILABLE_MODEL_REGEX = /(embed|embedding|bge|e5-|e5:|rerank|whisper|tts|speech|transcribe|stt|vision|llava|bakllava|moondream|florence|vl\b|image[-_ ]?gen|stable[-_ ]?diffusion|sdxl|flux)/i;
function isOllamaModelAnalyzable(modelName) {
  return !UNAVAILABLE_MODEL_REGEX.test(modelName);
}
function describeOllamaModel(modelName) {
  const lower = modelName.toLowerCase();
  if (!isOllamaModelAnalyzable(modelName)) {
    return "Looks like a vision/embedding/speech/rerank/image-generation model and is not suitable for metadata text analysis.";
  }
  if (/instruct|chat|it\b/.test(lower)) {
    return "Chat/instruct style model suitable for metadata suggestion tasks.";
  }
  if (/:8b|:7b|:9b/.test(lower)) {
    return "General-purpose local model with balanced quality and speed.";
  }
  if (/:4b|:3b/.test(lower)) {
    return "Lightweight model with fast runtime; quality may vary by note complexity.";
  }
  return "General text model candidate.";
}
function buildOllamaModelOptions(models, recommended) {
  const options = models.map((model) => {
    if (!isOllamaModelAnalyzable(model)) {
      return {
        model,
        status: "unavailable",
        reason: describeOllamaModel(model)
      };
    }
    if (recommended && model === recommended) {
      return {
        model,
        status: "recommended",
        reason: describeOllamaModel(model)
      };
    }
    return {
      model,
      status: "available",
      reason: describeOllamaModel(model)
    };
  });
  const weight = (status) => {
    switch (status) {
      case "recommended":
        return 0;
      case "available":
        return 1;
      case "unavailable":
        return 2;
      default:
        return 3;
    }
  };
  return options.sort(
    (a, b) => weight(a.status) - weight(b.status) || a.model.localeCompare(b.model)
  );
}
function recommendOllamaModel(models) {
  var _a;
  if (models.length === 0) {
    return {
      reason: "No local Ollama models were detected. Install at least one chat/instruct model first."
    };
  }
  const analyzableModels = models.filter((model) => isOllamaModelAnalyzable(model));
  if (analyzableModels.length === 0) {
    return {
      reason: "No analyzable Ollama model detected. Install a chat/instruct LLM (not embedding-only)."
    };
  }
  const scored = analyzableModels.map((name) => ({ name, score: scoreOllamaModel(name) })).sort((a, b) => b.score - a.score || a.name.localeCompare(b.name));
  const winner = (_a = scored[0]) == null ? void 0 : _a.name;
  if (!winner) {
    return { reason: "Could not select a recommended Ollama model." };
  }
  const reason = scoreOllamaModel(winner) >= 0 ? `Recommended '${winner}' based on chat/instruct capability and balanced size.` : `Recommended '${winner}' as fallback among detected models.`;
  return {
    recommended: winner,
    reason
  };
}
async function detectOllamaModels(baseUrl) {
  var _a;
  const url = `${baseUrl.replace(/\/$/, "")}/api/tags`;
  const response = await (0, import_obsidian2.requestUrl)({
    url,
    method: "GET",
    throw: false
  });
  if (response.status >= 300) {
    throw new Error(`Ollama model detection failed: ${response.status}`);
  }
  const rawModels = Array.isArray(
    (_a = response.json) == null ? void 0 : _a.models
  ) ? response.json.models : [];
  const modelNames = rawModels.map((item) => {
    const nameValue = item.name;
    if (typeof nameValue === "string") {
      return nameValue.trim();
    }
    const modelValue = item.model;
    if (typeof modelValue === "string") {
      return modelValue.trim();
    }
    return "";
  }).filter((name) => name.length > 0);
  const uniqueSorted = [...new Set(modelNames)].sort(
    (a, b) => a.localeCompare(b)
  );
  const recommendation = recommendOllamaModel(uniqueSorted);
  return {
    models: uniqueSorted,
    recommended: recommendation.recommended,
    reason: recommendation.reason
  };
}
function createProvider(settings) {
  const authHeaderResolver = arguments.length > 1 ? arguments[1] : void 0;
  const oauthEnabled = settings.oauthEnabled === true;
  const oauthBridgeEnabled = settings.oauthBridgeEnabled === true;
  if ((oauthBridgeEnabled || oauthEnabled) && isCloudProviderForOAuthBridge(settings.provider)) {
    const baseUrl = oauthBridgeEnabled ? resolveOAuthBridgeBaseUrl(settings) : toOpenAICompatibleBase(settings.openAIBaseUrl.trim() || DEFAULT_SETTINGS.openAIBaseUrl);
    const model = oauthBridgeEnabled ? resolveOAuthBridgeModel(settings) : getProviderModelLabelRaw(settings);
    return new OpenAICompatibleProvider(settings, {
      baseUrl,
      model,
      apiKey: oauthEnabled ? void 0 : resolveCloudProviderApiKey(settings),
      getAuthHeaders: oauthEnabled ? authHeaderResolver : void 0
    });
  }
  const providerMap = {
    ollama: () => new OllamaProvider(settings),
    lmstudio: () => new OpenAICompatibleProvider(settings, {
      baseUrl: toOpenAICompatibleBase(settings.lmStudioBaseUrl),
      model: settings.lmStudioModel,
      apiKey: settings.lmStudioApiKey.trim() || void 0
    }),
    openai: () => new OpenAICompatibleProvider(settings, {
      baseUrl: toOpenAICompatibleBase(settings.openAIBaseUrl),
      model: settings.openAIModel,
      apiKey: oauthEnabled ? void 0 : settings.openAIApiKey.trim(),
      getAuthHeaders: oauthEnabled ? authHeaderResolver : void 0
    }),
    anthropic: () => new AnthropicProvider(settings),
    gemini: () => new GeminiProvider(settings)
  };
  return providerMap[settings.provider]();
}
async function analyzeWithFallback(settings, request) {
  const authHeaderResolver = arguments.length > 2 ? arguments[2] : void 0;
  const provider = createProvider(settings, authHeaderResolver);
  const providerModel = getProviderModelLabel(settings);
  const startedAt = Date.now();
  try {
    const proposal = await provider.analyze(request);
    return {
      proposal,
      meta: {
        provider: settings.provider,
        model: providerModel,
        elapsedMs: Date.now() - startedAt,
        usedFallback: false
      }
    };
  } catch (e) {
    const fallback = new HeuristicFallbackProvider(settings);
    const proposal = await fallback.analyze(request);
    return {
      proposal,
      meta: {
        provider: settings.provider,
        model: providerModel,
        elapsedMs: Date.now() - startedAt,
        usedFallback: true
      }
    };
  }
}

// src/semantic.ts
var import_obsidian3 = require("obsidian");
var EMBEDDING_BATCH_SIZE = 8;
var EMBEDDING_CACHE_VERSION = 1;
var RUNTIME_FILE_VECTOR_CACHE_MAX = 15e3;
var RUNTIME_QUERY_VECTOR_CACHE_MAX = 800;
var EMBEDDING_MODEL_REGEX = /(embed|embedding|nomic-embed|mxbai|bge|e5|gte|arctic-embed|jina-emb)/i;
var NON_EMBEDDING_MODEL_REGEX = /(whisper|tts|speech|transcribe|stt|rerank)/i;
var runtimeFileVectorCache = /* @__PURE__ */ new Map();
var runtimeQueryVectorCache = /* @__PURE__ */ new Map();
var embeddingCacheMemory = /* @__PURE__ */ new Map();
function isOllamaModelEmbeddingCapable(modelName) {
  return EMBEDDING_MODEL_REGEX.test(modelName) && !NON_EMBEDDING_MODEL_REGEX.test(modelName);
}
function scoreEmbeddingModel(modelName) {
  const lower = modelName.toLowerCase();
  let score = 0;
  if (/nomic-embed-text/.test(lower)) {
    score += 40;
  }
  if (/bge-m3|bge-large|bge-base/.test(lower)) {
    score += 35;
  }
  if (/mxbai-embed-large/.test(lower)) {
    score += 30;
  }
  if (/e5-large|gte-large/.test(lower)) {
    score += 25;
  }
  if (/embed|embedding/.test(lower)) {
    score += 10;
  }
  if (/:large|:xl/.test(lower)) {
    score += 5;
  }
  if (/:small|:mini|:base/.test(lower)) {
    score -= 2;
  }
  return score;
}
function describeEmbeddingModel(modelName) {
  const lower = modelName.toLowerCase();
  if (!isOllamaModelEmbeddingCapable(modelName)) {
    return "Looks non-embedding model for semantic retrieval.";
  }
  if (/nomic-embed-text/.test(lower)) {
    return "Strong local embedding baseline with broad retrieval quality.";
  }
  if (/bge|e5|gte|mxbai/.test(lower)) {
    return "Embedding family suitable for semantic note similarity.";
  }
  return "Embedding-capable model candidate.";
}
function recommendEmbeddingModel(models) {
  var _a;
  if (models.length === 0) {
    return {
      reason: "No local Ollama models were detected. Install at least one embedding model."
    };
  }
  const candidates = models.filter((model) => isOllamaModelEmbeddingCapable(model));
  if (candidates.length === 0) {
    return {
      reason: "No embedding-capable model detected. Install nomic-embed-text, bge, e5, or similar."
    };
  }
  const scored = candidates.map((name) => ({ name, score: scoreEmbeddingModel(name) })).sort((a, b) => b.score - a.score || a.name.localeCompare(b.name));
  const winner = (_a = scored[0]) == null ? void 0 : _a.name;
  if (!winner) {
    return { reason: "Could not choose an embedding model." };
  }
  return {
    recommended: winner,
    reason: `Recommended '${winner}' for semantic embedding quality/speed balance.`
  };
}
function buildOllamaEmbeddingModelOptions(models, recommended) {
  const options = models.map((model) => {
    if (!isOllamaModelEmbeddingCapable(model)) {
      return {
        model,
        status: "unavailable",
        reason: describeEmbeddingModel(model)
      };
    }
    if (recommended && model === recommended) {
      return {
        model,
        status: "recommended",
        reason: describeEmbeddingModel(model)
      };
    }
    return {
      model,
      status: "available",
      reason: describeEmbeddingModel(model)
    };
  });
  const weight = (status) => {
    switch (status) {
      case "recommended":
        return 0;
      case "available":
        return 1;
      case "unavailable":
        return 2;
      default:
        return 3;
    }
  };
  return options.sort(
    (a, b) => weight(a.status) - weight(b.status) || a.model.localeCompare(b.model)
  );
}
async function detectOllamaEmbeddingModels(baseUrl) {
  var _a;
  const url = `${baseUrl.replace(/\/$/, "")}/api/tags`;
  const response = await (0, import_obsidian3.requestUrl)({
    url,
    method: "GET",
    throw: false
  });
  if (response.status >= 300) {
    throw new Error(`Ollama embedding model detection failed: ${response.status}`);
  }
  const rawModels = Array.isArray(
    (_a = response.json) == null ? void 0 : _a.models
  ) ? response.json.models : [];
  const modelNames = rawModels.map((item) => {
    if (typeof item.name === "string") {
      return item.name.trim();
    }
    if (typeof item.model === "string") {
      return item.model.trim();
    }
    return "";
  }).filter((name) => name.length > 0);
  const uniqueSorted = [...new Set(modelNames)].sort(
    (a, b) => a.localeCompare(b)
  );
  const recommendation = recommendEmbeddingModel(uniqueSorted);
  return {
    models: uniqueSorted,
    recommended: recommendation.recommended,
    reason: recommendation.reason
  };
}
function clampSimilarity(raw) {
  if (!Number.isFinite(raw)) {
    return 0;
  }
  if (raw > 1) {
    return 1;
  }
  if (raw < -1) {
    return -1;
  }
  return raw;
}
function cosineSimilarity(a, b) {
  if (a.length === 0 || b.length === 0 || a.length !== b.length) {
    return null;
  }
  let dot = 0;
  let aNorm = 0;
  let bNorm = 0;
  for (let i = 0; i < a.length; i += 1) {
    const av = a[i];
    const bv = b[i];
    dot += av * bv;
    aNorm += av * av;
    bNorm += bv * bv;
  }
  if (aNorm <= 0 || bNorm <= 0) {
    return null;
  }
  return clampSimilarity(dot / (Math.sqrt(aNorm) * Math.sqrt(bNorm)));
}
function toNumberVector(value) {
  if (!Array.isArray(value)) {
    return null;
  }
  const out = [];
  for (const item of value) {
    if (typeof item !== "number" || !Number.isFinite(item)) {
      return null;
    }
    out.push(item);
  }
  return out.length > 0 ? out : null;
}
function parseEmbeddings(payload) {
  if (!payload || typeof payload !== "object") {
    return [];
  }
  const record = payload;
  const embeddingSingle = toNumberVector(record.embedding);
  if (embeddingSingle) {
    return [embeddingSingle];
  }
  const embeddings = record.embeddings;
  if (!Array.isArray(embeddings)) {
    return [];
  }
  const out = [];
  for (const item of embeddings) {
    const vector = toNumberVector(item);
    if (!vector) {
      return [];
    }
    out.push(vector);
  }
  return out;
}
function fingerprintText(text) {
  let hash = 2166136261;
  for (let i = 0; i < text.length; i += 1) {
    hash ^= text.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }
  return (hash >>> 0).toString(16).padStart(8, "0");
}
function buildCacheKey(baseUrl, model, filePath) {
  return `${baseUrl}::${model}::${filePath}`;
}
function buildRuntimeFileVectorKey(baseUrl, model, maxChars, filePath) {
  return `${baseUrl}::${model}::${maxChars}::${filePath}`;
}
function buildRuntimeQueryKey(baseUrl, model, maxChars, queryText) {
  return `${baseUrl}::${model}::${maxChars}::${queryText}`;
}
function getAppCacheIdentity(app) {
  return `${app.vault.configDir}::${app.vault.getName()}`;
}
function pruneRuntimeFileVectorCache() {
  if (runtimeFileVectorCache.size <= RUNTIME_FILE_VECTOR_CACHE_MAX) {
    return;
  }
  const sorted = [...runtimeFileVectorCache.entries()].sort(
    (a, b) => a[1].updatedAt - b[1].updatedAt || a[0].localeCompare(b[0])
  );
  const removeCount = sorted.length - RUNTIME_FILE_VECTOR_CACHE_MAX;
  for (let i = 0; i < removeCount; i += 1) {
    runtimeFileVectorCache.delete(sorted[i][0]);
  }
}
function setRuntimeFileVector(key, vector, mtime, size) {
  runtimeFileVectorCache.set(key, {
    vector,
    mtime,
    size,
    updatedAt: Date.now()
  });
  pruneRuntimeFileVectorCache();
}
function getRuntimeFileVector(key, mtime, size) {
  const hit = runtimeFileVectorCache.get(key);
  if (!hit) {
    return null;
  }
  if (hit.mtime !== mtime || hit.size !== size || hit.vector.length === 0) {
    runtimeFileVectorCache.delete(key);
    return null;
  }
  hit.updatedAt = Date.now();
  return hit.vector;
}
function pruneRuntimeQueryVectorCache() {
  if (runtimeQueryVectorCache.size <= RUNTIME_QUERY_VECTOR_CACHE_MAX) {
    return;
  }
  const sorted = [...runtimeQueryVectorCache.entries()].sort(
    (a, b) => a[1].updatedAt - b[1].updatedAt || a[0].localeCompare(b[0])
  );
  const removeCount = sorted.length - RUNTIME_QUERY_VECTOR_CACHE_MAX;
  for (let i = 0; i < removeCount; i += 1) {
    runtimeQueryVectorCache.delete(sorted[i][0]);
  }
}
function getEmbeddingCachePath(app) {
  return (0, import_obsidian3.normalizePath)(
    `${app.vault.configDir}/plugins/omni-forge/semantic-embedding-cache.json`
  );
}
async function ensureParentFolder(app, path) {
  const normalized = (0, import_obsidian3.normalizePath)(path);
  const chunks = normalized.split("/");
  chunks.pop();
  if (chunks.length === 0) {
    return;
  }
  let currentPath = "";
  for (const part of chunks) {
    currentPath = currentPath ? `${currentPath}/${part}` : part;
    const existing = app.vault.getAbstractFileByPath(currentPath);
    if (existing) {
      continue;
    }
    await app.vault.createFolder(currentPath);
  }
}
async function readEmbeddingCache(app) {
  const memoryKey = getAppCacheIdentity(app);
  const cached = embeddingCacheMemory.get(memoryKey);
  if (cached) {
    return cached;
  }
  const path = getEmbeddingCachePath(app);
  const exists = await app.vault.adapter.exists(path);
  if (!exists) {
    const empty = { version: EMBEDDING_CACHE_VERSION, entries: {} };
    embeddingCacheMemory.set(memoryKey, empty);
    return empty;
  }
  try {
    const raw = await app.vault.adapter.read(path);
    const parsed = JSON.parse(raw);
    const version = typeof parsed.version === "number" ? parsed.version : EMBEDDING_CACHE_VERSION;
    const entries = parsed.entries && typeof parsed.entries === "object" ? parsed.entries : {};
    if (version !== EMBEDDING_CACHE_VERSION) {
      const empty = { version: EMBEDDING_CACHE_VERSION, entries: {} };
      embeddingCacheMemory.set(memoryKey, empty);
      return empty;
    }
    const loaded = { version, entries };
    embeddingCacheMemory.set(memoryKey, loaded);
    return loaded;
  } catch (e) {
    const empty = { version: EMBEDDING_CACHE_VERSION, entries: {} };
    embeddingCacheMemory.set(memoryKey, empty);
    return empty;
  }
}
async function writeEmbeddingCache(app, cache) {
  const path = getEmbeddingCachePath(app);
  await ensureParentFolder(app, path);
  await app.vault.adapter.write(path, JSON.stringify(cache));
  embeddingCacheMemory.set(getAppCacheIdentity(app), cache);
}
function normalizeSourceText(raw, maxChars) {
  const collapsed = raw.replace(/\s+/g, " ").trim();
  if (!collapsed) {
    return "(empty note)";
  }
  return collapsed.slice(0, Math.max(200, maxChars));
}
async function requestOllamaEmbeddings(baseUrl, model, inputs) {
  const url = `${baseUrl.replace(/\/$/, "")}/api/embed`;
  const response = await (0, import_obsidian3.requestUrl)({
    url,
    method: "POST",
    contentType: "application/json",
    body: JSON.stringify({
      model,
      input: inputs
    }),
    throw: false
  });
  if (response.status >= 300) {
    throw new Error(`Embedding request failed: ${response.status}`);
  }
  const parsed = parseEmbeddings(response.json);
  if (parsed.length === 0) {
    throw new Error("Embedding response was empty or invalid.");
  }
  return parsed;
}
function resolveEmbeddingConfig(settings) {
  const baseUrl = settings.semanticOllamaBaseUrl.trim() || settings.ollamaBaseUrl.trim();
  const model = settings.semanticOllamaModel.trim();
  if (!baseUrl) {
    throw new Error("Semantic embedding base URL is empty.");
  }
  if (!model) {
    throw new Error("Semantic embedding model is empty.");
  }
  return { baseUrl, model };
}
function throwAbortIfNeeded(abortSignal) {
  if (abortSignal == null ? void 0 : abortSignal.aborted) {
    throw new DOMException("The operation was aborted.", "AbortError");
  }
}
async function buildFileVectorIndex(app, files, config, maxChars, abortSignal) {
  const vectorsByPath = /* @__PURE__ */ new Map();
  const errors = [];
  const cache = await readEmbeddingCache(app);
  let cacheHits = 0;
  let cacheWrites = 0;
  let cacheDirty = false;
  const missing = [];
  for (const file of files) {
    throwAbortIfNeeded(abortSignal);
    const runtimeKey = buildRuntimeFileVectorKey(
      config.baseUrl,
      config.model,
      maxChars,
      file.path
    );
    const runtimeHit = getRuntimeFileVector(runtimeKey, file.stat.mtime, file.stat.size);
    if (runtimeHit) {
      vectorsByPath.set(file.path, runtimeHit);
      cacheHits += 1;
      continue;
    }
    const cacheKey = buildCacheKey(config.baseUrl, config.model, file.path);
    const hit = cache.entries[cacheKey];
    if (hit && typeof hit.mtime === "number" && typeof hit.size === "number" && hit.mtime === file.stat.mtime && hit.size === file.stat.size && Array.isArray(hit.vector) && hit.vector.length > 0) {
      vectorsByPath.set(file.path, hit.vector);
      setRuntimeFileVector(runtimeKey, hit.vector, file.stat.mtime, file.stat.size);
      cacheHits += 1;
      continue;
    }
    const content = await app.vault.cachedRead(file);
    throwAbortIfNeeded(abortSignal);
    const text = normalizeSourceText(content, maxChars);
    const fingerprint = fingerprintText(text);
    if (hit && hit.fingerprint === fingerprint && Array.isArray(hit.vector) && hit.vector.length > 0) {
      vectorsByPath.set(file.path, hit.vector);
      cache.entries[cacheKey] = {
        ...hit,
        mtime: file.stat.mtime,
        size: file.stat.size,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      setRuntimeFileVector(runtimeKey, hit.vector, file.stat.mtime, file.stat.size);
      cacheHits += 1;
      cacheDirty = true;
      continue;
    }
    missing.push({
      file,
      text,
      cacheKey,
      fingerprint
    });
  }
  for (let i = 0; i < missing.length; i += EMBEDDING_BATCH_SIZE) {
    throwAbortIfNeeded(abortSignal);
    const batch = missing.slice(i, i + EMBEDDING_BATCH_SIZE);
    try {
      const embeddings = await requestOllamaEmbeddings(
        config.baseUrl,
        config.model,
        batch.map((item) => item.text)
      );
      throwAbortIfNeeded(abortSignal);
      if (embeddings.length !== batch.length) {
        throw new Error(
          `Embedding count mismatch (${embeddings.length} vs ${batch.length}).`
        );
      }
      for (let idx = 0; idx < batch.length; idx += 1) {
        const entry = batch[idx];
        const vector = embeddings[idx];
        vectorsByPath.set(entry.file.path, vector);
        const runtimeKey = buildRuntimeFileVectorKey(
          config.baseUrl,
          config.model,
          maxChars,
          entry.file.path
        );
        setRuntimeFileVector(
          runtimeKey,
          vector,
          entry.file.stat.mtime,
          entry.file.stat.size
        );
        cache.entries[entry.cacheKey] = {
          fingerprint: entry.fingerprint,
          vector,
          mtime: entry.file.stat.mtime,
          size: entry.file.stat.size,
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        cacheWrites += 1;
        cacheDirty = true;
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown embedding error";
      for (const item of batch) {
        errors.push(`${item.file.path}: ${message}`);
      }
    }
  }
  if (cacheDirty) {
    try {
      await writeEmbeddingCache(app, cache);
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown embedding cache write error";
      errors.push(`cache-write: ${message}`);
    }
  }
  return {
    vectorsByPath,
    cacheHits,
    cacheWrites,
    errors
  };
}
async function buildSemanticNeighborMap(app, files, settings, abortSignal) {
  const neighborMap = /* @__PURE__ */ new Map();
  for (const file of files) {
    throwAbortIfNeeded(abortSignal);
    neighborMap.set(file.path, []);
  }
  if (files.length < 2) {
    return {
      neighborMap,
      model: settings.semanticOllamaModel,
      generatedVectors: 0,
      cacheHits: 0,
      cacheWrites: 0,
      errors: []
    };
  }
  const config = resolveEmbeddingConfig(settings);
  const model = config.model;
  const maxChars = Math.max(400, settings.semanticMaxChars);
  const minSimilarity = Math.max(0, Math.min(1, settings.semanticMinSimilarity));
  const topK = Math.max(1, settings.semanticTopK);
  const vectorBuild = await buildFileVectorIndex(
    app,
    files,
    config,
    maxChars,
    abortSignal
  );
  const vectorsByPath = vectorBuild.vectorsByPath;
  const errors = [...vectorBuild.errors];
  const cacheHits = vectorBuild.cacheHits;
  const cacheWrites = vectorBuild.cacheWrites;
  for (const sourceFile of files) {
    throwAbortIfNeeded(abortSignal);
    const sourceVector = vectorsByPath.get(sourceFile.path);
    if (!sourceVector) {
      continue;
    }
    const scored = [];
    for (const targetFile of files) {
      throwAbortIfNeeded(abortSignal);
      if (targetFile.path === sourceFile.path) {
        continue;
      }
      const targetVector = vectorsByPath.get(targetFile.path);
      if (!targetVector) {
        continue;
      }
      const similarity = cosineSimilarity(sourceVector, targetVector);
      if (similarity === null || similarity < minSimilarity) {
        continue;
      }
      scored.push({
        path: targetFile.path,
        similarity
      });
    }
    scored.sort((a, b) => b.similarity - a.similarity || a.path.localeCompare(b.path));
    neighborMap.set(sourceFile.path, scored.slice(0, topK));
  }
  return {
    neighborMap,
    model,
    generatedVectors: vectorsByPath.size,
    cacheHits,
    cacheWrites,
    errors
  };
}
async function searchSemanticNotesByQuery(app, files, settings, query, topK, abortSignal) {
  var _a;
  if (files.length === 0) {
    return {
      hits: [],
      model: settings.semanticOllamaModel,
      generatedVectors: 0,
      cacheHits: 0,
      cacheWrites: 0,
      errors: []
    };
  }
  const config = resolveEmbeddingConfig(settings);
  const maxChars = Math.max(400, settings.semanticMaxChars);
  const queryText = normalizeSourceText(query, maxChars);
  const safeTopK = Math.max(1, topK);
  const vectorBuild = await buildFileVectorIndex(
    app,
    files,
    config,
    maxChars,
    abortSignal
  );
  const hits = [];
  const errors = [...vectorBuild.errors];
  let queryVector = null;
  const queryCacheKey = buildRuntimeQueryKey(
    config.baseUrl,
    config.model,
    maxChars,
    queryText
  );
  const queryCacheHit = runtimeQueryVectorCache.get(queryCacheKey);
  if (queryCacheHit && queryCacheHit.vector.length > 0) {
    queryCacheHit.updatedAt = Date.now();
    queryVector = queryCacheHit.vector;
  }
  try {
    throwAbortIfNeeded(abortSignal);
    if (!queryVector) {
      const queryEmbeddings = await requestOllamaEmbeddings(config.baseUrl, config.model, [
        queryText
      ]);
      throwAbortIfNeeded(abortSignal);
      queryVector = (_a = queryEmbeddings[0]) != null ? _a : null;
      if (queryVector && queryVector.length > 0) {
        runtimeQueryVectorCache.set(queryCacheKey, {
          vector: queryVector,
          updatedAt: Date.now()
        });
        pruneRuntimeQueryVectorCache();
      }
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown query embedding error";
    errors.push(`query: ${message}`);
  }
  if (queryVector) {
    for (const file of files) {
      throwAbortIfNeeded(abortSignal);
      const fileVector = vectorBuild.vectorsByPath.get(file.path);
      if (!fileVector) {
        continue;
      }
      const similarity = cosineSimilarity(queryVector, fileVector);
      if (similarity === null) {
        continue;
      }
      hits.push({
        path: file.path,
        similarity
      });
    }
  }
  hits.sort((a, b) => b.similarity - a.similarity || a.path.localeCompare(b.path));
  return {
    hits: hits.slice(0, safeTopK),
    model: config.model,
    generatedVectors: vectorBuild.vectorsByPath.size,
    cacheHits: vectorBuild.cacheHits,
    cacheWrites: vectorBuild.cacheWrites,
    errors
  };
}

// src/main.ts
var execAsync = (0, import_util.promisify)(import_child_process.exec);
function shellQuoteForExec(value) {
  const source = value == null ? "" : String(value);
  if (process.platform === "win32") {
    return `"${source.replace(/"/g, '""')}"`;
  }
  return `'${source.replace(/'/g, `'"'"'`)}'`;
}
function sanitizeTempFileNameForHwp(rawName, fallbackBase, extHint = "") {
  const source = typeof rawName === "string" && rawName.trim() ? rawName.trim() : fallbackBase;
  const normalized = source.normalize("NFKD").replace(/[^\x20-\x7E]/g, "");
  const collapsed = normalized.replace(/[^A-Za-z0-9._-]+/g, "-").replace(/-+/g, "-");
  const trimmed = collapsed.replace(/^-+|-+$/g, "") || fallbackBase;
  const ext = typeof extHint === "string" ? extHint.trim().replace(/^\.+/, "").toLowerCase() : "";
  if (!ext) {
    return trimmed;
  }
  return trimmed.toLowerCase().endsWith(`.${ext}`) ? trimmed : `${trimmed}.${ext}`;
}
async function resolveSofficeExecutableForHwpPoC() {
  const probes = process.platform === "win32" ? ["where soffice.exe", "where soffice"] : ["command -v soffice"];
  for (const probe of probes) {
    try {
      const result = await execAsync(probe);
      const first = String((result == null ? void 0 : result.stdout) || "").split(/\r?\n/g).map((line) => line.trim()).find((line) => line.length > 0);
      if (first) {
        return first;
      }
      if (process.platform !== "win32") {
        return "soffice";
      }
    } catch (e) {
    }
  }
  const programFiles = process.env.ProgramFiles || "C:\\Program Files";
  const programFilesX86 = process.env["ProgramFiles(x86)"] || "C:\\Program Files (x86)";
  const candidates = process.platform === "win32" ? [
    nodePath.join(programFiles, "LibreOffice", "program", "soffice.exe"),
    nodePath.join(programFilesX86, "LibreOffice", "program", "soffice.exe")
  ] : [
    "/Applications/LibreOffice.app/Contents/MacOS/soffice",
    "/opt/homebrew/bin/soffice",
    "/usr/local/bin/soffice",
    "/usr/bin/soffice"
  ];
  const accessMode = process.platform === "win32" ? nodeFs.constants.F_OK : nodeFs.constants.X_OK;
  for (const candidate of candidates) {
    try {
      await nodeFs.promises.access(candidate, accessMode);
      return candidate;
    } catch (e) {
    }
  }
  return null;
}
function normalizeHwpAutoConvertDetail(raw, fallback = "") {
  const base = typeof raw === "string" && raw.trim() ? raw.trim() : fallback;
  if (!base) {
    return "";
  }
  const compact = base.replace(/\s+/g, " ").trim();
  return compact.length > 180 ? `${compact.slice(0, 177)}...` : compact;
}
function describeHwpAutoConvertStatus(status, detail = "") {
  const suffix = detail ? ` (${detail})` : "";
  switch (status) {
    case "ok":
      return `soffice ready${suffix}`;
    case "non_hwp":
      return `skipped(non-hwp)${suffix}`;
    case "binary_missing":
      return `binary unavailable${suffix}`;
    case "soffice_unavailable":
      return `soffice missing${suffix}`;
    case "soffice_failed":
      return `soffice failed${suffix}`;
    case "pdf_missing":
      return `pdf not generated${suffix}`;
    case "pdf_parser_unavailable":
      return `pdf parser chain unavailable${suffix}`;
    case "pdf_parser_failed":
      return `pdf parser chain failed${suffix}`;
    default:
      return `unknown${suffix}`;
  }
}
async function runHwpToPdfParserPocWithSoffice(options) {
  const ext = typeof (options == null ? void 0 : options.ext) === "string" ? options.ext.trim().toLowerCase() : "";
  if (ext !== "hwp") {
    return {
      attempted: false,
      ok: false,
      status: "non_hwp",
      message: "only .hwp is supported for this PoC route"
    };
  }
  const binarySource = options == null ? void 0 : options.binary;
  if (!(binarySource instanceof ArrayBuffer) && !ArrayBuffer.isView(binarySource)) {
    return {
      attempted: true,
      ok: false,
      status: "binary_missing",
      message: "input binary unavailable"
    };
  }
  if (typeof (options == null ? void 0 : options.parsePdf) !== "function") {
    return {
      attempted: true,
      ok: false,
      status: "pdf_parser_unavailable",
      message: "pdf parser chain callback unavailable"
    };
  }
  const sofficeBin = await resolveSofficeExecutableForHwpPoC();
  if (!sofficeBin) {
    return {
      attempted: true,
      ok: false,
      status: "soffice_unavailable",
      message: "command not found"
    };
  }
  const inputBuffer = binarySource instanceof ArrayBuffer ? Buffer.from(binarySource) : Buffer.from(binarySource.buffer, binarySource.byteOffset, binarySource.byteLength);
  const fileName = typeof (options == null ? void 0 : options.fileName) === "string" && options.fileName.trim() ? options.fileName.trim() : "document.hwp";
  const tmpRoot = await nodeFs.promises.mkdtemp(nodePath.join(nodeOs.tmpdir(), "omni-forge-hwp-soffice-"));
  const outDir = nodePath.join(tmpRoot, "out");
  try {
    await nodeFs.promises.mkdir(outDir, { recursive: true });
    const inputName = sanitizeTempFileNameForHwp(fileName, "document", "hwp");
    const inputPath = nodePath.join(tmpRoot, inputName);
    await nodeFs.promises.writeFile(inputPath, inputBuffer);
    const convertCommand = [
      shellQuoteForExec(sofficeBin),
      "--headless",
      "--convert-to",
      "pdf",
      "--outdir",
      shellQuoteForExec(outDir),
      shellQuoteForExec(inputPath)
    ].join(" ");
    try {
      await execAsync(convertCommand, { timeout: 9e4, maxBuffer: 10 * 1024 * 1024 });
    } catch (error) {
      const detail = normalizeHwpAutoConvertDetail(
        error && typeof error.stderr === "string" ? error.stderr : error instanceof Error ? error.message : "",
        "conversion command failed"
      );
      return {
        attempted: true,
        ok: false,
        status: "soffice_failed",
        message: detail
      };
    }
    const pdfCandidates = (await nodeFs.promises.readdir(outDir)).filter((name) => name.toLowerCase().endsWith(".pdf")).sort((a, b) => a.localeCompare(b));
    if (pdfCandidates.length === 0) {
      return {
        attempted: true,
        ok: false,
        status: "pdf_missing",
        message: "converted pdf not found in output directory"
      };
    }
    const pdfPath = nodePath.join(outDir, pdfCandidates[0]);
    const pdfBinary = await nodeFs.promises.readFile(pdfPath);
    try {
      const parsed = await options.parsePdf(pdfBinary, pdfPath);
      return {
        attempted: true,
        ok: true,
        status: "ok",
        message: "hwp->pdf conversion and pdf parser chain completed",
        parsed,
        pdfPath,
        pdfBinary,
        sofficeBin
      };
    } catch (error) {
      const detail = normalizeHwpAutoConvertDetail(
        error instanceof Error ? error.message : "",
        "pdf parser chain failed"
      );
      return {
        attempted: true,
        ok: false,
        status: "pdf_parser_failed",
        message: detail,
        pdfPath,
        pdfBinary
      };
    }
  } finally {
    try {
      await nodeFs.promises.rm(tmpRoot, { recursive: true, force: true });
    } catch (e) {
    }
  }
}
var DEFAULT_SETTINGS = {
  settingsViewMode: "full",
  settingsUiLanguage: "ko",
  settingsActiveTab: "quick",
  provider: "ollama",
  ollamaBaseUrl: "http://127.0.0.1:11434",
  ollamaModel: "",
  ollamaAutoPickEnabled: true,
  lmStudioBaseUrl: "http://127.0.0.1:1234",
  lmStudioModel: "local-model",
  lmStudioApiKey: "",
  openAIBaseUrl: "https://api.openai.com/v1",
  openAIModel: "gpt-5.3-codex",
  openAIApiKey: "",
  oauthBridgeEnabled: false,
  oauthBridgeBaseUrl: "",
  oauthBridgeModel: "",
  oauthEnabled: true,
  oauthProviderPreset: "google",
  oauthProvider: "google",
  oauthAuth0Domain: "",
  oauthAuthUrl: "https://accounts.google.com/o/oauth2/v2/auth",
  oauthTokenUrl: "https://oauth2.googleapis.com/token",
  oauthClientId: "",
  oauthScopes: "openid profile email",
  oauthRedirectUri: "http://127.0.0.1:8765/callback",
  oauthUsePkce: true,
  oauthAccessToken: "",
  oauthRefreshToken: "",
  oauthTokenExpiry: 0,
  anthropicModel: "claude-3-7-sonnet-latest",
  anthropicApiKey: "",
  geminiModel: "gemini-2.5-pro",
  geminiApiKey: "",
  suggestionMode: true,
  includeReasons: true,
  showAutoLinkScoreDetails: false,
  cleanUnknownFrontmatter: false,
  sortArrays: true,
  analyzeTags: true,
  analyzeTopic: true,
  analyzeLinked: true,
  forceAllToAllLinkedEnabled: false,
  analyzeLinkedScopeMode: "selected_only",
  relatedScopeMaxCandidates: 120,
  relatedScopeTimeBudgetMs: 150,
  analyzeIndex: true,
  maxTags: 8,
  maxLinked: 8,
  analysisOnlyChangedNotes: false,
  semanticLinkingEnabled: false,
  semanticOllamaBaseUrl: "http://127.0.0.1:11434",
  semanticOllamaModel: "",
  semanticAutoPickEnabled: true,
  semanticTopK: 24,
  semanticMinSimilarity: 0.25,
  semanticMaxChars: 5e3,
  qaOllamaBaseUrl: "http://127.0.0.1:11434",
  qaOllamaModel: "",
  qaChatModelFamily: "local",
  qaChatModelProfile: "local-flash",
  qaChatFontSize: 14,
  qaShowSystemMessages: false,
  qaTopK: 5,
  qaMaxContextChars: 12e3,
  qaAllowNonLocalEndpoint: false,
  qaAllowedOutboundHosts: "",
  qaPreferChatApi: true,
  qaStructureGuardEnabled: true,
  qaAlwaysDetailedAnswer: true,
  qaMinAnswerChars: 320,
  qaPreferredResponseLanguage: "korean",
  qaLocalPresetProfile: "balanced_local",
  qaConversationMode: "ask",
  qaQuickCustomProfileSlot1: "",
  qaQuickCustomProfileSlot2: "",
  qaQuickCustomProfileSlot3: "",
  qaCustomSystemPrompt: '\uB108\uB294 \uB85C\uCEEC Obsidian \uB178\uD2B8 \uAE30\uBC18 \uC2E4\uD589 \uC5D0\uC774\uC804\uD2B8\uB2E4. \uD56D\uC0C1 \uD55C\uAD6D\uC5B4\uB85C \uB2F5\uD55C\uB2E4. \uC81C\uACF5\uB41C \uC18C\uC2A4 \uBC94\uC704 \uC548\uC5D0\uC11C\uB9CC \uB2F5\uD558\uACE0, \uADFC\uAC70\uAC00 \uBD80\uC871\uD558\uBA74 \uBC18\uB4DC\uC2DC "\uC815\uBCF4 \uBD80\uC871"\uC774\uB77C\uACE0 \uBA85\uC2DC\uD55C\uB2E4. \uCD94\uCE21/\uD658\uAC01/\uACFC\uC7A5 \uD45C\uD604\uC744 \uAE08\uC9C0\uD55C\uB2E4. \uC6B0\uC120\uC21C\uC704: (1) \uB178\uD2B8 \uB9C1\uD06C\uB97C \uC815\uD655\uD788 \uC5F0\uACB0\uD574 \uADF8\uB798\uD504 \uC778\uC0AC\uC774\uD2B8\uB97C \uAC15\uD654 (2) \uB178\uD2B8 \uAE30\uBC18 \uBB38\uC11C/\uBD84\uC11D/\uAC1C\uBC1C \uC791\uC5C5 \uD6A8\uC728\uC744 \uB192\uC774\uB294 \uC2E4\uD589\uC548 \uC81C\uC2DC. \uCCA8\uBD80\uAC00 \uC788\uC73C\uBA74 \uCCA8\uBD80\uB97C 1\uC21C\uC704 \uADFC\uAC70\uB85C \uC0AC\uC6A9\uD558\uACE0, \uC120\uD0DD \uB178\uD2B8\uB294 \uBCF4\uC870 \uADFC\uAC70\uB85C\uB9CC \uC0AC\uC6A9\uD55C\uB2E4. \uB2F5\uBCC0 \uD615\uC2DD: 1) \uD55C \uC904 \uC694\uC57D 2) \uD575\uC2EC \uADFC\uAC70 (\uCD5C\uB300 5\uAC1C) 3) \uC2E4\uD589 \uAC00\uB2A5\uD55C \uB2E4\uC74C \uB2E8\uACC4 (\uCD5C\uB300 5\uAC1C). \uC8FC\uC7A5\uC5D0\uB294 \uAC00\uB2A5\uD55C \uACBD\uC6B0 \uC18C\uC2A4 \uACBD\uB85C\uB97C \uAD04\uD638\uB85C \uD45C\uAE30\uD55C\uB2E4. \uC7A5\uD669\uD568\uBCF4\uB2E4 \uC815\uD655\uC131\uACFC \uC7AC\uD604 \uAC00\uB2A5\uC131\uC744 \uC6B0\uC120\uD55C\uB2E4.',
  qaRolePreset: "ask",
  qaPipelinePreset: "orchestrator_safeguard",
  qaAskModel: "",
  qaAskVisionModel: "",
  qaImageGeneratorModel: "",
  qaCoderModel: "",
  qaDebuggerModel: "",
  qaArchitectModel: "",
  qaOrchestratorModel: "",
  qaSafeguardModel: "",
  qaBalancedPresetBaseModel: "qwen3:14b",
  qaBalancedPresetVisionModel: "qwen2.5vl:7b",
  qaBalancedPresetEmbeddingModel: "nomic-embed-text",
  qaQualityPresetBaseModel: "qwen3:30b",
  qaQualityPresetVisionModel: "qwen2.5vl:7b",
  qaQualityPresetEmbeddingModel: "nomic-embed-text",
  qaAskSystemPrompt: "\uB108\uB294 \uB85C\uCEEC \uB178\uD2B8 \uAE30\uBC18 Ask \uC5D0\uC774\uC804\uD2B8\uB2E4. \uD56D\uC0C1 \uD55C\uAD6D\uC5B4\uB85C \uB2F5\uD55C\uB2E4. \uADFC\uAC70\uAC00 \uBD80\uC871\uD558\uBA74 '\uC815\uBCF4 \uBD80\uC871'\uC744 \uBA85\uC2DC\uD558\uACE0, \uD575\uC2EC\uB9CC \uC815\uD655\uD558\uAC8C \uC804\uB2EC\uD55C\uB2E4.",
  qaAskVisionSystemPrompt: '\uB108\uB294 Ask(vision) \uC5ED\uD560\uC774\uC9C0\uB9CC, \uD604\uC7AC \uD30C\uC774\uD504\uB77C\uC778\uC740 \uD14D\uC2A4\uD2B8 \uC911\uC2EC\uC784\uC744 \uC804\uC81C\uB85C \uB3D9\uC791\uD55C\uB2E4. \uD56D\uC0C1 \uD55C\uAD6D\uC5B4\uB85C \uB2F5\uD55C\uB2E4. \uC2E4\uC81C \uC774\uBBF8\uC9C0\uB97C \uC9C1\uC811 \uBCF8 \uAC83\uCC98\uB7FC \uB9D0\uD558\uC9C0 \uC54A\uB294\uB2E4. \uC774\uBBF8\uC9C0 \uC790\uCCB4\uAC00 \uC785\uB825\uB418\uC9C0 \uC54A\uC558\uC73C\uBA74 "\uC774\uBBF8\uC9C0 \uC6D0\uBCF8 \uD655\uC778 \uBD88\uAC00"\uB97C \uBA85\uC2DC\uD558\uACE0, \uD14D\uC2A4\uD2B8 \uAE30\uBC18\uC73C\uB85C \uAC00\uB2A5\uD55C \uD574\uC11D/\uC694\uCCAD\uC0AC\uD56D/\uB2E4\uC74C \uD655\uC778 \uC808\uCC28\uB97C \uC81C\uC2DC\uD55C\uB2E4. \uB2F5\uBCC0 \uD615\uC2DD: 1) \uD604\uC7AC \uD655\uC778 \uAC00\uB2A5\uD55C \uC0AC\uC2E4 2) \uD655\uC778 \uBD88\uAC00\uB2A5\uD55C \uD56D\uBAA9 3) \uCD94\uAC00\uB85C \uBC1B\uC73C\uBA74 \uC815\uD655\uB3C4\uAC00 \uC62C\uB77C\uAC00\uB294 \uC785\uB825 \uBAA9\uB85D',
  qaImageGeneratorSystemPrompt: '\uB108\uB294 \uC774\uBBF8\uC9C0 \uC0DD\uC131 \uC6CC\uD06C\uD50C\uB85C \uC124\uACC4 \uC5D0\uC774\uC804\uD2B8\uB2E4. \uD56D\uC0C1 \uD55C\uAD6D\uC5B4\uB85C \uB2F5\uD55C\uB2E4. \uC2E4\uC81C \uC774\uBBF8\uC9C0\uB97C \uC0DD\uC131\uD588\uB2E4\uACE0 \uC8FC\uC7A5\uD558\uC9C0 \uB9D0\uACE0, "\uC0DD\uC131\uC6A9 \uD504\uB86C\uD504\uD2B8 \uC124\uACC4"\uB9CC \uC81C\uACF5\uD55C\uB2E4. \uCD9C\uB825 \uD615\uC2DD: 1) \uBAA9\uC801 \uC694\uC57D 2) Positive prompt 3) Negative prompt 4) \uC2A4\uD0C0\uC77C/\uAD6C\uB3C4/\uC870\uBA85/\uC0C9\uAC10 \uC9C0\uC2DC 5) \uAD8C\uC7A5 \uD30C\uB77C\uBBF8\uD130(\uBE44\uC728, \uC2A4\uD15D, \uC2DC\uB4DC \uC804\uB7B5) \uC694\uCCAD\uC774 \uBD88\uBA85\uD655\uD558\uBA74 \uAE30\uBCF8\uAC12\uC744 \uBA85\uC2DC\uD558\uACE0 \uBCF4\uC218\uC801\uC73C\uB85C \uC81C\uC548\uD55C\uB2E4.',
  qaCoderSystemPrompt: "You are an implementation-focused Omni-Forge Coder. Always answer in Korean. For EDIT_NOTE tasks, follow Coder Prompt Contract strictly: output unified diff only; the first non-empty line must be CURRENT_SELECTION; after the header emit only @@ hunks with diff prefixes (space/+/-); forbid path headers (diff --git, index, ---, +++); patch scope is CURRENT_SELECTION only; never modify frontmatter; if validation fails, regenerate once with a single fallback attempt.",
  qaDebuggerSystemPrompt: "\uB108\uB294 \uB514\uBC84\uAE45 \uC5D0\uC774\uC804\uD2B8\uB2E4. \uD56D\uC0C1 \uD55C\uAD6D\uC5B4\uB85C \uB2F5\uD55C\uB2E4. \uBAA9\uD45C: \uC7AC\uD604 \uAC00\uB2A5\uC131, \uC6D0\uC778 \uBD84\uB9AC, \uC548\uC804\uD55C \uC218\uC815. \uADDC\uCE59: - \uC6D0\uC778 \uD6C4\uBCF4\uB97C \uC6B0\uC120\uC21C\uC704\uB85C \uC815\uB9AC - \uAC01 \uD6C4\uBCF4\uBCC4 \uAC80\uC99D \uC2E4\uD5D8\uC744 \uC81C\uC2DC - \uD655\uC815\uB418\uC9C0 \uC54A\uC740 \uC6D0\uC778\uC744 \uB2E8\uC815\uD558\uC9C0 \uC54A\uB294\uB2E4 \uCD9C\uB825 \uD615\uC2DD: 1) \uC99D\uC0C1 \uC815\uB9AC 2) \uC6D0\uC778 \uAC00\uC124 Top 3 3) \uAC00\uC124\uBCC4 \uAC80\uC99D \uC808\uCC28 4) \uCD5C\uC18C \uC218\uC815\uC548 5) \uC218\uC815 \uD6C4 \uAC80\uC99D \uCCB4\uD06C\uB9AC\uC2A4\uD2B8",
  qaArchitectSystemPrompt: "\uB108\uB294 \uC2DC\uC2A4\uD15C \uC544\uD0A4\uD14D\uD2B8 \uC5D0\uC774\uC804\uD2B8\uB2E4. \uD56D\uC0C1 \uD55C\uAD6D\uC5B4\uB85C \uB2F5\uD55C\uB2E4. \uBAA9\uD45C: \uC7A5\uAE30 \uC720\uC9C0\uBCF4\uC218 \uAC00\uB2A5\uD55C \uAD6C\uC870\uC640 \uD2B8\uB808\uC774\uB4DC\uC624\uD504 \uC81C\uC2DC. \uADDC\uCE59: - \uB300\uC548 \uCD5C\uC18C 2\uAC1C \uC81C\uC2DC - \uC131\uB2A5/\uBCF5\uC7A1\uB3C4/\uC6B4\uC601\uBE44/\uBCF4\uC548 \uAD00\uC810 \uBE44\uAD50 - \uC758\uC0AC\uACB0\uC815 \uAE30\uC900\uC744 \uBA85\uD655\uD788 \uC81C\uC2DC \uCD9C\uB825 \uD615\uC2DD: 1) \uC694\uAD6C\uC0AC\uD56D/\uC81C\uC57D \uC694\uC57D 2) \uC544\uD0A4\uD14D\uCC98 \uC635\uC158 \uBE44\uAD50\uD45C 3) \uAD8C\uC7A5\uC548\uACFC \uC120\uD0DD \uC774\uC720 4) \uB2E8\uACC4\uC801 \uC774\uD589 \uACC4\uD68D 5) \uB9AC\uC2A4\uD06C\uC640 \uBAA8\uB2C8\uD130\uB9C1 \uD3EC\uC778\uD2B8",
  qaOrchestratorSystemPrompt: '\uB108\uB294 \uBA40\uD2F0 \uC5D0\uC774\uC804\uD2B8 \uC624\uCF00\uC2A4\uD2B8\uB808\uC774\uD130\uB2E4. \uD56D\uC0C1 \uD55C\uAD6D\uC5B4\uB85C \uB2F5\uD55C\uB2E4. \uBAA9\uD45C: \uC9C8\uBB38\uC744 \uC2E4\uD589 \uAC00\uB2A5\uD55C \uC791\uC5C5 \uD750\uB984\uC73C\uB85C \uBD84\uD574\uD558\uACE0, \uD544\uC694\uD55C \uD558\uC704 \uC5ED\uD560(architect/coder/debugger/safeguard)\uC744 \uC9C0\uC815\uD55C\uB2E4. \uADDC\uCE59: - \uC0AC\uC2E4 \uC0DD\uC131 \uAE08\uC9C0, \uADFC\uAC70 \uBD80\uC871 \uC2DC "\uC815\uBCF4 \uBD80\uC871" \uD45C\uAE30 - \uACFC\uB3C4\uD55C \uC7A5\uBB38 \uAE08\uC9C0, \uD575\uC2EC \uC758\uC0AC\uACB0\uC815 \uC911\uC2EC - \uCCA8\uBD80\uAC00 \uC788\uC73C\uBA74 \uCCA8\uBD80\uB97C 1\uC21C\uC704 \uADFC\uAC70\uB85C \uC0AC\uC6A9 \uCD9C\uB825 \uD615\uC2DD: 1) \uC791\uC5C5 \uBAA9\uD45C/\uBC94\uC704 2) \uB2E8\uACC4\uBCC4 \uACC4\uD68D(\uC21C\uC11C/\uC758\uC874\uC131/\uC644\uB8CC\uC870\uAC74) 3) \uC5ED\uD560 \uB77C\uC6B0\uD305 \uD45C (\uC5ED\uD560 | \uB9E1\uAE38 \uC77C | \uAE30\uB300 \uC0B0\uCD9C\uBB3C) 4) \uC5ED\uD560 \uC2E4\uD589 \uC694\uC57D (\uC5ED\uD560 | \uC2E4\uC81C \uAE30\uC5EC | \uC0B0\uCD9C\uBB3C | \uC870\uC728 \uBA54\uBAA8 | \uBBF8\uD574\uACB0 \uC774\uC288) 5) \uC704\uD5D8\uC694\uC18C\uC640 \uC644\uD654\uCC45 6) \uC989\uC2DC \uC2E4\uD589\uD560 3\uB2E8\uACC4',
  qaSafeguardSystemPrompt: '\uB108\uB294 \uBCF4\uC548/\uC548\uC804 \uAC80\uC99D \uC5D0\uC774\uC804\uD2B8\uB2E4. \uD56D\uC0C1 \uD55C\uAD6D\uC5B4\uB85C \uB2F5\uD55C\uB2E4. \uCD08\uC810: \uAC1C\uC778\uC815\uBCF4, \uBCF4\uC548, \uADDC\uC815 \uC900\uC218, \uACFC\uC7A5/\uD5C8\uC704 \uC8FC\uC7A5 \uC81C\uAC70. \uADDC\uCE59: - \uADFC\uAC70 \uC5C6\uB294 \uBB38\uC7A5\uC740 \uC0AD\uC81C \uB610\uB294 "\uC815\uBCF4 \uBD80\uC871"\uC73C\uB85C \uB0AE\uCDB0 \uD45C\uD604 - \uBBFC\uAC10\uC815\uBCF4 \uB178\uCD9C \uAC00\uB2A5\uC131, \uC678\uBD80 \uC804\uC1A1 \uC704\uD5D8, \uAD8C\uD55C \uACFC\uB2E4 \uC5EC\uBD80\uB97C \uC6B0\uC120 \uC810\uAC80 \uCD9C\uB825 \uD615\uC2DD: 1) \uC704\uD5D8 \uC694\uC57D (\uC2EC\uAC01\uB3C4: \uB192\uC74C/\uC911\uAC04/\uB0AE\uC74C) 2) \uBC1C\uACAC \uD56D\uBAA9 (\uBB38\uC81C | \uC601\uD5A5 | \uADFC\uAC70) 3) \uC989\uC2DC \uC218\uC815 \uAD8C\uACE0\uC548 4) \uC6B4\uC601 \uC804 \uCD5C\uC885 \uCCB4\uD06C\uB9AC\uC2A4\uD2B8',
  qaRoleModelAutoPickEnabled: true,
  qaOrchestratorEnabled: false,
  qaSafeguardPassEnabled: false,
  qaIncludeSelectionInventory: true,
  qaSelectionInventoryMaxFiles: 200,
  qaThreadAutoSyncEnabled: true,
  qaPdfAttachmentEnabled: true,
  qaContextInChat: true,
  qaRequireSelectionForSelectedAsk: true,
  qaParserInboxWatchEnabled: false,
  qaParserInboxFolder: "inbox",
  qaParserIngestOutputFormat: "md",
  qaParserMode: "fast",
  qaParserInboxCollapsedDefault: true,
  qaAgentToolModeEnabled: false,
  qaAgentRequireApproval: true,
  qaAgentAllowShellTool: false,
  qaAgentShellFullAccess: false,
  qaAgentShellTimeoutSec: 20,
  qaAgentShellCwdPath: "",
  qaAgentPathAllowlist: "",
  qaAttachmentIngestRootPath: "Omni Forge Ingest",
  qaSkillsRootPath: "",
  autoTagActiveNoteEnabled: false,
  autoTagActiveNoteCooldownSec: 90,
  watchNewNotesEnabled: false,
  watchNewNotesFolders: "",
  pr3ScopeMode: "warn-only",
  pr3ScopeEnforceAck: false,
  pr3ScopeRoots: "",
  showPr3ScopeFingerprint: false,
  chatTranscriptRootPath: "Omni Forge Chats",
  cleanupReportRootPath: "Omni Forge Reports",
  propertyCleanupEnabled: false,
  propertyCleanupKeys: "related",
  propertyCleanupPrefixes: "",
  propertyCleanupKeepKeys: "date created,date updated,date modified,created,updated,modified",
  autoCreateTargetFolders: false,
  applyMode: "metadata_only",
  moveConflictPolicy: "suffix",
  targetFilePaths: [],
  targetFolderPaths: [],
  includeSubfoldersInFolderSelection: true,
  selectionPathWidthPercent: 72,
  backupBeforeApply: true,
  backupRootPath: "Omni Forge Backups",
  backupRetentionCount: 10,
  excludedFolderPatterns: ".obsidian,Omni Forge Backups",
  showProgressNotices: true,
  generateMoc: true,
  mocPath: "MOC/Selected Knowledge MOC.md"
};
var LOCAL_QA_VIEW_TYPE = "omni-forge-local-qa-view";
var LOCAL_QA_MAX_ATTACHMENTS = 10;
var LOCAL_QA_MAX_PANES = 3;
var LOCAL_QA_PDF_OCR_MAX_PAGES_FAST = 6;
var LOCAL_QA_PDF_OCR_MAX_PAGES_DETAILED = 16;
var ANALYSIS_CACHE_FILE = "analysis-proposal-cache.json";
var SELECTION_DIFF_AUDIT_LOG_FILE = "selection-diff-audit.jsonl";
var ANALYSIS_CACHE_VERSION = 1;
var ANALYSIS_CACHE_MAX_ENTRIES = 4e3;
var ANALYSIS_HARD_MAX_CANDIDATES = 120;
var LINKED_SCOPE_MAX_CANDIDATES_HARD = 600;
var LINKED_SCOPE_TIME_BUDGET_MS_HARD = 2e3;
var MAX_SELECTION_DIFF_CONTEXT_CHARS = 4e3;
var MAX_SELECTION_DIFF_CHANGED_LINES = 200;
var MAX_SELECTION_DIFF_HUNKS = 20;
var CODER_PROMPT_CONTRACT_VERSION = "v1.0";
var CODER_PROMPT_CONTRACT_SELECTION_HEADER = "CURRENT_SELECTION";
var FRONTMATTER_GUARD_ALLOWED_KEYS = ["linked", "tags", "topic", "index", "created", "updated"];
var FRONTMATTER_GUARD_ALLOWED_KEY_SET = new Set(FRONTMATTER_GUARD_ALLOWED_KEYS);
var DEFAULT_DENY_SCOPE_VIOLATION = "DEFAULT_DENY_SCOPE_VIOLATION";
var CONTRACT_INVALID_PATH = "CONTRACT_INVALID_PATH";
var ROUTER_TASK_ROLE_PIPELINE = {
  EDIT_NOTE: ["Architect", "Coder", "Reviewer", "Safeguard"],
  DOC_PIPELINE: ["Orchestrator", "Coder", "Reviewer", "Safeguard"],
  AUTOLINK_GRAPH: ["Architect", "Orchestrator", "Reviewer", "Safeguard"],
  QA_CHAT: ["Architect", "Reviewer"],
  GENERATE_PROJECT: ["Architect", "Coder", "Reviewer", "Safeguard"],
  EXPORT: ["Orchestrator", "Reviewer", "Safeguard"]
};
var ROUTER_ROLE_STAGE_MAP = {
  Architect: "architect",
  Orchestrator: "orchestrator",
  Coder: "coder",
  Reviewer: "debugger",
  Safeguard: "safeguard",
  Ask: null
};
var ROUTER_ROLE_MODEL_PRIORITY = {
  Architect: ["architect", "ask"],
  Orchestrator: ["orchestrator", "architect"],
  Coder: ["coder", "architect"],
  Reviewer: ["debugger", "coder"],
  Safeguard: ["safeguard", "ask"],
  Ask: ["ask"]
};
function stringifyValue(value) {
  if (value === void 0 || value === null) {
    return "(empty)";
  }
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return "(empty)";
    }
    return value.join(", ");
  }
  if (typeof value === "string") {
    return value.trim().length > 0 ? value : "(empty)";
  }
  return String(value);
}
function readManagedValueByKey(managed, key) {
  return managed[key];
}
function formatDurationMs(ms) {
  if (!Number.isFinite(ms) || ms < 0) {
    return "0ms";
  }
  if (ms < 1e3) {
    return `${ms}ms`;
  }
  return `${(ms / 1e3).toFixed(1)}s`;
}
function formatSimilarity(score) {
  const clamped = Math.max(-1, Math.min(1, score));
  return `${(clamped * 100).toFixed(1)}%`;
}
function formatBackupStamp(date) {
  const yyyy = date.getFullYear();
  const mm = String(date.getMonth() + 1).padStart(2, "0");
  const dd = String(date.getDate()).padStart(2, "0");
  const hh = String(date.getHours()).padStart(2, "0");
  const min = String(date.getMinutes()).padStart(2, "0");
  const sec = String(date.getSeconds()).padStart(2, "0");
  return `${yyyy}-${mm}-${dd}_${hh}-${min}-${sec}`;
}
function splitThinkingBlocks(rawText) {
  const raw = rawText != null ? rawText : "";
  if (!raw) {
    return { answer: "", thinking: "", hasOpenThinking: false };
  }
  let cursor = 0;
  let answer = "";
  let hasOpenThinking = false;
  const thinkingParts = [];
  while (cursor < raw.length) {
    const start = raw.indexOf("<think>", cursor);
    if (start < 0) {
      answer += raw.slice(cursor);
      break;
    }
    answer += raw.slice(cursor, start);
    const thinkStart = start + "<think>".length;
    const end = raw.indexOf("</think>", thinkStart);
    if (end < 0) {
      thinkingParts.push(raw.slice(thinkStart));
      hasOpenThinking = true;
      cursor = raw.length;
      break;
    }
    thinkingParts.push(raw.slice(thinkStart, end));
    cursor = end + "</think>".length;
  }
  return {
    answer: answer.replace(/<\/?think>/g, ""),
    thinking: thinkingParts.join("\n\n").trim(),
    hasOpenThinking
  };
}
function mergeUniqueStrings(base, additions) {
  const out = [...base];
  const seen = new Set(base);
  for (const item of additions) {
    if (!seen.has(item)) {
      seen.add(item);
      out.push(item);
    }
  }
  return out;
}
function parsePositiveInt(value, fallback) {
  const parsed = Number.parseInt(value, 10);
  if (!Number.isFinite(parsed) || parsed < 1) {
    return fallback;
  }
  return parsed;
}
function isEnterLikeKey(event) {
  var _a, _b;
  const legacyCode = (_b = (_a = event.keyCode) != null ? _a : event.which) != null ? _b : 0;
  return event.key === "Enter" || event.code === "Enter" || event.code === "NumpadEnter" || legacyCode === 13;
}
function shouldSubmitChatOnEnter(event) {
  return isEnterLikeKey(event) && !event.shiftKey && !event.ctrlKey && !event.metaKey && !event.altKey && !event.isComposing;
}
function insertTextareaLineBreak(target) {
  var _a, _b;
  const start = (_a = target.selectionStart) != null ? _a : target.value.length;
  const end = (_b = target.selectionEnd) != null ? _b : start;
  target.setRangeText("\n", start, end, "end");
}
function handleChatTextareaEnterKey(event, target, onSubmit) {
  if (!isEnterLikeKey(event)) {
    return;
  }
  if (event.shiftKey || event.ctrlKey || event.metaKey || event.altKey) {
    event.preventDefault();
    event.stopPropagation();
    event.stopImmediatePropagation();
    insertTextareaLineBreak(target);
    return;
  }
  if (event.isComposing) {
    return;
  }
  if (!shouldSubmitChatOnEnter(event)) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  event.stopImmediatePropagation();
  void onSubmit();
}
function cloneMetadataProposal(proposal) {
  return {
    tags: Array.isArray(proposal.tags) ? [...proposal.tags] : [],
    topic: proposal.topic,
    linked: Array.isArray(proposal.linked) ? [...proposal.linked] : [],
    index: proposal.index,
    reasons: proposal.reasons ? {
      tags: proposal.reasons.tags,
      topic: proposal.reasons.topic,
      linked: proposal.reasons.linked,
      index: proposal.reasons.index
    } : {}
  };
}
function cloneSuggestionMeta(meta) {
  return {
    provider: meta.provider,
    model: meta.model,
    elapsedMs: meta.elapsedMs,
    usedFallback: meta.usedFallback
  };
}
var SelectionModal = class extends import_obsidian4.Modal {
  constructor(app, allFiles, allFolders, initialFiles, initialFolders, includeSubfolders, pathWidthPercent, onSubmit, context = null) {
    super(app);
    this.searchValue = "";
    this.activeTab = "files";
    this.allFiles = allFiles;
    this.allFolders = allFolders;
    this.onSubmit = onSubmit;
    this.selectedFilePaths = new Set(initialFiles);
    this.selectedFolderPaths = new Set(initialFolders);
    this.includeSubfolders = includeSubfolders;
    this.pathWidthPercent = pathWidthPercent;
    this.context = context || {};
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.context.modalWidth) {
      this.modalEl.style.width = this.context.modalWidth;
      this.modalEl.style.maxWidth = "96vw";
    }
    contentEl.createEl("h2", { text: this.context.title || "Select target notes and folders" });
    const info = contentEl.createEl("p", {
      text: this.context.description || "Use tabs to switch between Files and Folders. Long paths are shown compactly with full path on hover."
    });
    info.style.marginTop = "0";
    if (Array.isArray(this.context.snapshotLines) && this.context.snapshotLines.length > 0) {
      const snapshot = contentEl.createDiv();
      snapshot.style.marginTop = "8px";
      snapshot.style.padding = "8px 10px";
      snapshot.style.border = "1px solid var(--background-modifier-border)";
      snapshot.style.borderRadius = "8px";
      snapshot.style.background = "var(--background-secondary)";
      for (const line of this.context.snapshotLines) {
        snapshot.createEl("div", { text: line });
      }
    }
    const searchWrapper = contentEl.createDiv();
    searchWrapper.createEl("label", { text: "Filter files/folders" });
    const searchInput = searchWrapper.createEl("input", {
      type: "text",
      placeholder: "Type part of file or folder path"
    });
    searchInput.style.width = "100%";
    searchInput.oninput = () => {
      this.searchValue = searchInput.value.trim().toLowerCase();
      this.renderList();
    };
    const subfolderRow = contentEl.createDiv();
    subfolderRow.style.display = "flex";
    subfolderRow.style.alignItems = "center";
    subfolderRow.style.gap = "8px";
    subfolderRow.style.marginTop = "8px";
    const subfolderCheckbox = subfolderRow.createEl("input", { type: "checkbox" });
    subfolderCheckbox.checked = this.includeSubfolders;
    subfolderCheckbox.onchange = () => {
      this.includeSubfolders = subfolderCheckbox.checked;
      this.updateFooterCounter();
    };
    subfolderRow.createEl("span", { text: "Include subfolders when folder is selected" });
    const widthRow = contentEl.createDiv();
    widthRow.style.display = "flex";
    widthRow.style.alignItems = "center";
    widthRow.style.gap = "8px";
    widthRow.style.marginTop = "6px";
    widthRow.createEl("span", { text: "Path width" });
    const widthInput = widthRow.createEl("input", {
      type: "range",
      attr: { min: "45", max: "100", step: "1" }
    });
    widthInput.value = String(this.pathWidthPercent);
    const widthLabel = widthRow.createEl("span", {
      text: `${this.pathWidthPercent}%`
    });
    widthInput.oninput = () => {
      const next = Number.parseInt(widthInput.value, 10);
      if (Number.isFinite(next) && next >= 45 && next <= 100) {
        this.pathWidthPercent = next;
        widthLabel.setText(`${next}%`);
        this.renderList();
      }
    };
    const tabRow = contentEl.createDiv();
    tabRow.style.display = "flex";
    tabRow.style.gap = "8px";
    tabRow.style.marginTop = "10px";
    const filesTab = tabRow.createEl("button", { text: "Files" });
    const foldersTab = tabRow.createEl("button", { text: "Folders" });
    const switchTab = (tab) => {
      this.activeTab = tab;
      filesTab.toggleClass("mod-cta", tab === "files");
      foldersTab.toggleClass("mod-cta", tab === "folders");
      this.renderList();
    };
    filesTab.onclick = () => switchTab("files");
    foldersTab.onclick = () => switchTab("folders");
    const actionRow = contentEl.createDiv();
    actionRow.style.display = "flex";
    actionRow.style.gap = "8px";
    actionRow.style.marginTop = "10px";
    const selectFilteredButton = actionRow.createEl("button", {
      text: "Select filtered"
    });
    selectFilteredButton.onclick = () => {
      if (this.activeTab === "files") {
        for (const file of this.filteredFiles()) {
          this.selectedFilePaths.add(file.path);
        }
      } else {
        for (const folder of this.filteredFolders()) {
          this.selectedFolderPaths.add(folder.path);
        }
      }
      this.renderList();
    };
    const clearFilteredButton = actionRow.createEl("button", {
      text: "Clear filtered"
    });
    clearFilteredButton.onclick = () => {
      if (this.activeTab === "files") {
        for (const file of this.filteredFiles()) {
          this.selectedFilePaths.delete(file.path);
        }
      } else {
        for (const folder of this.filteredFolders()) {
          this.selectedFolderPaths.delete(folder.path);
        }
      }
      this.renderList();
    };
    this.listContainer = contentEl.createDiv();
    this.listContainer.style.maxHeight = this.context.modalWidth ? "56vh" : "48vh";
    this.listContainer.style.overflow = "auto";
    this.listContainer.style.border = "1px solid var(--background-modifier-border)";
    this.listContainer.style.borderRadius = "8px";
    this.listContainer.style.marginTop = "10px";
    this.footerCounterEl = contentEl.createEl("p");
    this.footerCounterEl.style.marginTop = "8px";
    switchTab("files");
    const footer = contentEl.createDiv();
    footer.style.display = "flex";
    footer.style.gap = "8px";
    footer.style.justifyContent = "flex-end";
    footer.style.marginTop = "10px";
    const cancelButton = footer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => this.close();
    const saveButton = footer.createEl("button", {
      text: "Save selection",
      cls: "mod-cta"
    });
    saveButton.onclick = async () => {
      await this.onSubmit({
        selectedFilePaths: [...this.selectedFilePaths].sort(
          (a, b) => a.localeCompare(b)
        ),
        selectedFolderPaths: [...this.selectedFolderPaths].sort(
          (a, b) => a.localeCompare(b)
        ),
        includeSubfolders: this.includeSubfolders,
        pathWidthPercent: this.pathWidthPercent
      });
      this.close();
    };
  }
  filteredFiles() {
    if (!this.searchValue) {
      return this.allFiles;
    }
    return this.allFiles.filter(
      (file) => file.path.toLowerCase().includes(this.searchValue)
    );
  }
  filteredFolders() {
    if (!this.searchValue) {
      return this.allFolders;
    }
    return this.allFolders.filter(
      (folder) => folder.path.toLowerCase().includes(this.searchValue)
    );
  }
  renderList() {
    this.listContainer.empty();
    if (this.activeTab === "files") {
      for (const file of this.filteredFiles()) {
        const row = this.createRow(file.path, this.selectedFilePaths.has(file.path));
        const checkbox = row.querySelector("input");
        checkbox.onchange = () => {
          if (checkbox.checked) {
            this.selectedFilePaths.add(file.path);
          } else {
            this.selectedFilePaths.delete(file.path);
          }
          this.updateFooterCounter();
        };
      }
    } else {
      for (const folder of this.filteredFolders()) {
        const row = this.createRow(folder.path, this.selectedFolderPaths.has(folder.path));
        const checkbox = row.querySelector("input");
        checkbox.onchange = () => {
          if (checkbox.checked) {
            this.selectedFolderPaths.add(folder.path);
          } else {
            this.selectedFolderPaths.delete(folder.path);
          }
          this.updateFooterCounter();
        };
      }
    }
    this.updateFooterCounter();
  }
  createRow(path, checked) {
    const row = this.listContainer.createDiv();
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.gap = "8px";
    row.style.padding = "6px 8px";
    row.style.borderBottom = "1px solid var(--background-modifier-border)";
    const checkbox = row.createEl("input", { type: "checkbox" });
    checkbox.checked = checked;
    const pathEl = row.createEl("span", { text: path });
    pathEl.style.flex = "1";
    pathEl.style.whiteSpace = "nowrap";
    pathEl.style.overflow = "hidden";
    pathEl.style.textOverflow = "ellipsis";
    pathEl.style.maxWidth = `${this.pathWidthPercent}%`;
    pathEl.title = path;
    return row;
  }
  updateFooterCounter() {
    this.footerCounterEl.setText(
      `Selected files: ${this.selectedFilePaths.size}, selected folders: ${this.selectedFolderPaths.size}, include subfolders: ${this.includeSubfolders ? "yes" : "no"}, path width: ${this.pathWidthPercent}%`
    );
  }
};
var CleanupKeyPickerModal = class extends import_obsidian4.Modal {
  constructor(app, keyStats, initialSelectedKeys, onSubmit) {
    super(app);
    this.searchValue = "";
    this.keyStats = keyStats;
    this.onSubmit = onSubmit;
    this.selectedKeys = new Set(initialSelectedKeys);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select cleanup keys from selected notes" });
    contentEl.createEl("p", {
      text: "Only checked keys will be written to 'Cleanup exact keys'. Counts show in how many selected notes each key appears."
    });
    const searchWrapper = contentEl.createDiv();
    searchWrapper.createEl("label", { text: "Filter keys" });
    const searchInput = searchWrapper.createEl("input", { type: "text" });
    searchInput.style.width = "100%";
    searchInput.placeholder = "type key fragment...";
    searchInput.oninput = () => {
      this.searchValue = searchInput.value.trim().toLowerCase();
      this.renderList();
    };
    const actions = contentEl.createDiv();
    actions.style.display = "flex";
    actions.style.gap = "8px";
    actions.style.marginTop = "8px";
    const selectAll = actions.createEl("button", { text: "Select all (filtered)" });
    const clearAll = actions.createEl("button", { text: "Clear all (filtered)" });
    this.listContainer = contentEl.createDiv();
    this.listContainer.style.maxHeight = "48vh";
    this.listContainer.style.overflow = "auto";
    this.listContainer.style.border = "1px solid var(--background-modifier-border)";
    this.listContainer.style.borderRadius = "8px";
    this.listContainer.style.marginTop = "8px";
    this.listContainer.style.padding = "6px";
    this.footerSummaryEl = contentEl.createDiv();
    this.footerSummaryEl.style.marginTop = "8px";
    const footer = contentEl.createDiv();
    footer.style.display = "flex";
    footer.style.justifyContent = "flex-end";
    footer.style.gap = "8px";
    footer.style.marginTop = "12px";
    const cancelButton = footer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => this.close();
    const saveButton = footer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveButton.onclick = async () => {
      const selected = [...this.selectedKeys].sort((a, b) => a.localeCompare(b));
      await this.onSubmit(selected);
      this.close();
    };
    selectAll.onclick = () => {
      for (const item of this.filteredStats()) {
        this.selectedKeys.add(item.key);
      }
      this.renderList();
    };
    clearAll.onclick = () => {
      for (const item of this.filteredStats()) {
        this.selectedKeys.delete(item.key);
      }
      this.renderList();
    };
    this.renderList();
  }
  filteredStats() {
    if (!this.searchValue) {
      return this.keyStats;
    }
    return this.keyStats.filter((item) => item.key.includes(this.searchValue));
  }
  renderList() {
    this.listContainer.empty();
    const rows = this.filteredStats();
    if (rows.length === 0) {
      this.listContainer.createEl("div", { text: "No matching keys." });
      this.footerSummaryEl.setText(`Selected: ${this.selectedKeys.size}`);
      return;
    }
    for (const item of rows) {
      const row = this.listContainer.createDiv();
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.gap = "8px";
      row.style.padding = "6px 8px";
      row.style.borderBottom = "1px solid var(--background-modifier-border)";
      const checkbox = row.createEl("input", { type: "checkbox" });
      checkbox.checked = this.selectedKeys.has(item.key);
      checkbox.onchange = () => {
        if (checkbox.checked) {
          this.selectedKeys.add(item.key);
        } else {
          this.selectedKeys.delete(item.key);
        }
        this.footerSummaryEl.setText(`Selected: ${this.selectedKeys.size}`);
      };
      row.createEl("span", { text: item.key });
      const countEl = row.createEl("small", { text: `${item.count}` });
      countEl.style.marginLeft = "auto";
    }
    this.footerSummaryEl.setText(
      `Listed: ${rows.length} keys | Selected: ${this.selectedKeys.size}`
    );
  }
};
var BackupConfirmModal = class _BackupConfirmModal extends import_obsidian4.Modal {
  constructor(app, defaultBackup, onResolve) {
    super(app);
    this.rememberAsDefault = false;
    this.defaultBackup = defaultBackup;
    this.onResolve = onResolve;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\uBC31\uC5C5\uC744 \uC9C4\uD589\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?" });
    contentEl.createEl("p", {
      text: "\uBD84\uC11D \uC804\uC5D0 \uC120\uD0DD\uB41C \uBB38\uC11C\uB97C \uBC31\uC5C5\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4. \uBCF5\uAD6C\uAC00 \uD544\uC694\uD560 \uB54C \uC548\uC804\uD569\uB2C8\uB2E4."
    });
    const defaultText = this.defaultBackup ? "\uD604\uC7AC \uAE30\uBCF8\uAC12: \uBC31\uC5C5 \uD6C4 \uC9C4\uD589" : "\uD604\uC7AC \uAE30\uBCF8\uAC12: \uBC31\uC5C5 \uC5C6\uC774 \uC9C4\uD589";
    contentEl.createEl("p", { text: defaultText });
    const rememberRow = contentEl.createDiv();
    rememberRow.style.display = "flex";
    rememberRow.style.alignItems = "center";
    rememberRow.style.gap = "8px";
    const rememberCheckbox = rememberRow.createEl("input", { type: "checkbox" });
    rememberCheckbox.onchange = () => {
      this.rememberAsDefault = rememberCheckbox.checked;
    };
    rememberRow.createEl("span", { text: "\uC774 \uC120\uD0DD\uC744 \uAE30\uBCF8\uAC12\uC73C\uB85C \uC800\uC7A5" });
    const footer = contentEl.createDiv();
    footer.style.display = "flex";
    footer.style.justifyContent = "flex-end";
    footer.style.gap = "8px";
    footer.style.marginTop = "12px";
    const cancelButton = footer.createEl("button", { text: "\uCDE8\uC18C" });
    cancelButton.onclick = () => {
      this.resolve({
        proceed: false,
        backupBeforeRun: this.defaultBackup,
        rememberAsDefault: false
      });
    };
    const noBackupButton = footer.createEl("button", { text: "\uBC31\uC5C5 \uC5C6\uC774 \uC9C4\uD589" });
    noBackupButton.onclick = () => {
      this.resolve({
        proceed: true,
        backupBeforeRun: false,
        rememberAsDefault: this.rememberAsDefault
      });
    };
    const backupButton = footer.createEl("button", {
      text: "\uBC31\uC5C5 \uD6C4 \uC9C4\uD589(\uAD8C\uC7A5)",
      cls: "mod-cta"
    });
    backupButton.onclick = () => {
      this.resolve({
        proceed: true,
        backupBeforeRun: true,
        rememberAsDefault: this.rememberAsDefault
      });
    };
  }
  onClose() {
    this.contentEl.empty();
  }
  resolve(decision) {
    this.onResolve(decision);
    this.close();
  }
  static ask(app, defaultBackup) {
    return new Promise((resolve2) => {
      new _BackupConfirmModal(app, defaultBackup, resolve2).open();
    });
  }
};
var CapacityGuardModal = class _CapacityGuardModal extends import_obsidian4.Modal {
  constructor(app, selectedCount, recommendedMax, modelName, semanticEnabled, onResolve) {
    super(app);
    this.selectedCount = selectedCount;
    this.recommendedMax = recommendedMax;
    this.modelName = modelName;
    this.semanticEnabled = semanticEnabled;
    this.onResolve = onResolve;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Large selection warning" });
    contentEl.createEl("p", {
      text: `Selected ${this.selectedCount} notes. Recommended max for this setup is about ${this.recommendedMax}.`
    });
    contentEl.createEl("p", {
      text: `Model: ${this.modelName || "(not set)"} | semantic linking: ${this.semanticEnabled ? "on" : "off"}`
    });
    contentEl.createEl("p", {
      text: "Too many candidates can lower linked quality and slow local analysis. Continue anyway?"
    });
    const footer = contentEl.createDiv();
    footer.style.display = "flex";
    footer.style.justifyContent = "flex-end";
    footer.style.gap = "8px";
    footer.style.marginTop = "12px";
    const cancelButton = footer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => this.resolve({ proceed: false });
    const proceedButton = footer.createEl("button", { text: "Continue", cls: "mod-cta" });
    proceedButton.onclick = () => this.resolve({ proceed: true });
  }
  resolve(decision) {
    this.onResolve(decision);
    this.close();
  }
  static ask(app, selectedCount, recommendedMax, modelName, semanticEnabled) {
    return new Promise((resolve2) => {
      new _CapacityGuardModal(
        app,
        selectedCount,
        recommendedMax,
        modelName,
        semanticEnabled,
        resolve2
      ).open();
    });
  }
};
var NewNoteWatchModal = class _NewNoteWatchModal extends import_obsidian4.Modal {
  constructor(app, filePath, watchedFolder, onResolve) {
    super(app);
    this.resolved = false;
    this.filePath = filePath;
    this.watchedFolder = watchedFolder;
    this.onResolve = onResolve;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "New note detected in watched folder" });
    contentEl.createEl("p", { text: `Folder: ${this.watchedFolder}` });
    contentEl.createEl("p", { text: `File: ${this.filePath}` });
    contentEl.createEl("p", {
      text: "Add this note to target selection and run analysis now?"
    });
    const footer = contentEl.createDiv();
    footer.style.display = "flex";
    footer.style.justifyContent = "flex-end";
    footer.style.gap = "8px";
    footer.style.marginTop = "12px";
    const ignoreButton = footer.createEl("button", { text: "Ignore" });
    ignoreButton.onclick = () => this.resolve({ action: "ignore" });
    const addOnlyButton = footer.createEl("button", { text: "Add to selection" });
    addOnlyButton.onclick = () => this.resolve({ action: "add_only" });
    const analyzeNowButton = footer.createEl("button", {
      text: "Add and analyze now",
      cls: "mod-cta"
    });
    analyzeNowButton.onclick = () => this.resolve({ action: "analyze_now" });
  }
  onClose() {
    if (!this.resolved) {
      this.onResolve({ action: "ignore" });
      this.resolved = true;
    }
    this.contentEl.empty();
  }
  resolve(decision) {
    if (this.resolved) {
      return;
    }
    this.resolved = true;
    this.onResolve(decision);
    this.close();
  }
  static ask(app, filePath, watchedFolder) {
    return new Promise((resolve2) => {
      new _NewNoteWatchModal(app, filePath, watchedFolder, resolve2).open();
    });
  }
};
var RunProgressModal = class extends import_obsidian4.Modal {
  constructor(app, titleText) {
    super(app);
    this.showOnlyErrors = true;
    this.cancelled = false;
    this.titleText = titleText;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: this.titleText });
    this.statusEl = contentEl.createEl("p", { text: "Preparing..." });
    this.currentFileEl = contentEl.createEl("p", { text: "Current file: -" });
    this.etaEl = contentEl.createEl("p", { text: "ETA: -" });
    const filterRow = contentEl.createDiv();
    filterRow.style.display = "flex";
    filterRow.style.alignItems = "center";
    filterRow.style.gap = "8px";
    const onlyErrorsCheckbox = filterRow.createEl("input", { type: "checkbox" });
    onlyErrorsCheckbox.checked = this.showOnlyErrors;
    onlyErrorsCheckbox.onchange = () => {
      this.showOnlyErrors = onlyErrorsCheckbox.checked;
    };
    filterRow.createEl("span", { text: "Show only errors" });
    this.errorsSummaryEl = contentEl.createEl("p", { text: "Errors: 0" });
    this.errorsListEl = contentEl.createDiv();
    this.errorsListEl.style.maxHeight = "22vh";
    this.errorsListEl.style.overflow = "auto";
    this.errorsListEl.style.border = "1px solid var(--background-modifier-border)";
    this.errorsListEl.style.borderRadius = "8px";
    this.errorsListEl.style.padding = "8px";
    const footer = contentEl.createDiv();
    footer.style.display = "flex";
    footer.style.justifyContent = "flex-end";
    footer.style.marginTop = "12px";
    const cancelButton = footer.createEl("button", {
      text: "\uC911\uC9C0",
      cls: "mod-warning"
    });
    cancelButton.onclick = () => {
      this.cancelled = true;
      this.statusEl.setText(`${this.titleText}: stopping after current file...`);
    };
  }
  isCancelled() {
    return this.cancelled;
  }
  update(params) {
    var _a;
    const elapsedMs = Date.now() - params.startedAt;
    const avgMs = params.current > 0 ? elapsedMs / params.current : 0;
    const remaining = Math.max(0, params.total - params.current);
    const etaMs = remaining * avgMs;
    this.statusEl.setText(`${params.stage}: ${params.current}/${params.total}`);
    this.currentFileEl.setText(`Current file: ${(_a = params.currentFile) != null ? _a : "-"}`);
    this.etaEl.setText(
      `Elapsed: ${formatDurationMs(elapsedMs)} | ETA: ${params.current > 0 ? formatDurationMs(Math.round(etaMs)) : "-"}`
    );
    this.errorsSummaryEl.setText(`Errors: ${params.errors.length}`);
    this.renderEvents(params.errors, params.events);
  }
  setFinished(message) {
    this.statusEl.setText(message);
  }
  renderEvents(errors, events) {
    var _a, _b, _c;
    this.errorsListEl.empty();
    const showRows = this.showOnlyErrors ? events.filter((item) => item.status === "error") : events;
    if (showRows.length === 0) {
      this.errorsListEl.createEl("div", {
        text: this.showOnlyErrors ? "No errors." : "No activity yet."
      });
      return;
    }
    for (const item of showRows.slice(-200)) {
      const row = this.errorsListEl.createDiv();
      row.style.marginBottom = "6px";
      const label = item.status === "error" ? "ERROR" : "OK";
      row.createEl("div", { text: `${label}: ${item.filePath}` });
      if (item.status === "error") {
        const errorMessage = (_c = (_b = (_a = errors.find((error) => error.filePath === item.filePath)) == null ? void 0 : _a.message) != null ? _b : item.message) != null ? _c : "Unknown error";
        row.createEl("small", { text: errorMessage });
      } else if (item.message) {
        row.createEl("small", { text: item.message });
      }
    }
  }
};
var SuggestionPreviewModal = class extends import_obsidian4.Modal {
  constructor(app, summary, suggestions, includeReasons, showAutoLinkScoreDetails, onApply) {
    super(app);
    this.summary = summary;
    this.suggestions = suggestions;
    this.includeReasons = includeReasons;
    this.showAutoLinkScoreDetails = showAutoLinkScoreDetails;
    this.onApply = onApply;
  }
  onOpen() {
    var _a;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "AI suggestions (preview mode)" });
    const summaryEl = contentEl.createDiv();
    summaryEl.style.border = "1px solid var(--background-modifier-border)";
    summaryEl.style.borderRadius = "8px";
    summaryEl.style.padding = "8px";
    summaryEl.style.marginBottom = "10px";
    summaryEl.createEl("div", {
      text: `Provider: ${this.summary.provider} | Model: ${this.summary.model}`
    });
    summaryEl.createEl("div", {
      text: `Analyzed: ${this.summary.totalFiles} | Changed: ${this.summary.changedFiles}`
    });
    summaryEl.createEl("div", {
      text: `Fallback used: ${this.summary.usedFallbackCount} | Errors: ${this.summary.errorCount} | Elapsed: ${formatDurationMs(this.summary.elapsedMs)}${this.summary.cancelled ? " | Cancelled" : ""}`
    });
    const list = contentEl.createDiv();
    list.style.maxHeight = "52vh";
    list.style.overflow = "auto";
    list.style.border = "1px solid var(--background-modifier-border)";
    list.style.borderRadius = "8px";
    list.style.padding = "8px";
    for (const suggestion of this.suggestions) {
      const section = list.createDiv();
      section.style.padding = "8px";
      section.style.marginBottom = "8px";
      section.style.border = "1px solid var(--background-modifier-border)";
      section.style.borderRadius = "8px";
      section.createEl("h3", { text: suggestion.file.path });
      section.createEl("p", {
        text: `Suggest source: ${suggestion.analysis.provider}/${suggestion.analysis.model} | ${formatDurationMs(suggestion.analysis.elapsedMs)}${suggestion.analysis.usedFallback ? " | fallback" : ""}`
      });
      this.renderSemanticCandidates(section, (_a = suggestion.semanticCandidates) != null ? _a : []);
      this.renderLinkedUnifiedDiff(section, suggestion);
      this.renderFieldChange(section, "tags", suggestion);
      this.renderFieldChange(section, "topic", suggestion);
      this.renderFieldChange(section, "linked", suggestion);
      this.renderFieldChange(section, "index", suggestion);
    }
    const footer = contentEl.createDiv();
    footer.style.display = "flex";
    footer.style.justifyContent = "flex-end";
    footer.style.gap = "8px";
    footer.style.marginTop = "12px";
    const cancelButton = footer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => this.close();
    const applyButton = footer.createEl("button", {
      text: "Apply changes",
      cls: "mod-cta"
    });
    applyButton.onclick = async () => {
      await this.onApply();
      this.close();
    };
  }
  renderFieldChange(parent, key, suggestion) {
    const before = readManagedValueByKey(suggestion.existing, key);
    const after = readManagedValueByKey(suggestion.proposed, key);
    if (stringifyValue(before) === stringifyValue(after)) {
      return;
    }
    const row = parent.createDiv();
    row.style.marginBottom = "6px";
    row.createEl("strong", { text: key });
    row.createEl("div", { text: `Before: ${stringifyValue(before)}` });
    row.createEl("div", { text: `After: ${stringifyValue(after)}` });
    if (key === "linked") {
      this.renderAutoLinkScoreDetails(row, suggestion);
    }
    if (!this.includeReasons) {
      return;
    }
    const reason = suggestion.reasons[key];
    if (reason) {
      row.createEl("div", { text: `Reason: ${reason}` });
    }
  }
  renderLinkedUnifiedDiff(parent, suggestion) {
    const preview = suggestion && suggestion.linkedUnifiedDiffPreview && typeof suggestion.linkedUnifiedDiffPreview === "object" ? suggestion.linkedUnifiedDiffPreview : null;
    if (!preview) {
      return;
    }
    const block = parent.createDiv();
    block.style.marginBottom = "8px";
    block.style.padding = "6px 8px";
    block.style.border = "1px solid var(--background-modifier-border)";
    block.style.borderRadius = "6px";
    block.createEl("strong", { text: "Linked unified diff (preview-only)" });
    const scope = preview.scope && typeof preview.scope === "object" ? preview.scope : null;
    if (scope && scope.hasScopeContext) {
      const scopeDecision = typeof scope.scopeDecision === "string" ? scope.scopeDecision : "unknown";
      const scopeWouldBlock = scope.scopeWouldBlock === true ? "yes" : "no";
      block.createEl("div", { text: `Scope would block: ${scopeWouldBlock} (decision: ${scopeDecision})` });
    }
    const diffText = typeof preview.diffText === "string" ? preview.diffText : "";
    const showNoChanges = preview.changed !== true || diffText.trim() === "";
    const pre = block.createEl("pre");
    pre.style.marginTop = "6px";
    pre.style.maxHeight = "220px";
    pre.style.overflow = "auto";
    const code = pre.createEl("code");
    code.setText(showNoChanges ? "No changes proposed" : diffText);
  }
  renderAutoLinkScoreDetails(row, suggestion) {
    if (!this.showAutoLinkScoreDetails) {
      return;
    }
    const details = Array.isArray(suggestion.autoLinkScoreDetails) ? suggestion.autoLinkScoreDetails.filter(
      (item) => item && typeof item.path === "string" && item._scoreBreakdown
    ) : [];
    if (details.length === 0) {
      return;
    }
    const toggleButton = row.createEl("button", { text: "Why?" });
    toggleButton.style.marginTop = "4px";
    const detailsWrap = row.createDiv();
    detailsWrap.style.display = "none";
    detailsWrap.style.marginTop = "4px";
    detailsWrap.style.padding = "6px 8px";
    detailsWrap.style.border = "1px solid var(--background-modifier-border)";
    detailsWrap.style.borderRadius = "6px";
    toggleButton.onclick = () => {
      const open = detailsWrap.style.display === "none";
      detailsWrap.style.display = open ? "block" : "none";
      toggleButton.setText(open ? "Hide" : "Why?");
    };
    for (const item of details) {
      const block = detailsWrap.createDiv();
      block.style.marginBottom = "6px";
      block.createEl("div", { text: item.path });
      const breakdown = item._scoreBreakdown;
      const total = typeof breakdown.rawScore === "number" ? breakdown.rawScore : 0;
      block.createEl("div", { text: `Total: ${total}` });
      const evidences = Array.isArray(breakdown.evidences) ? breakdown.evidences : [];
      for (const evidence of evidences) {
        const weight = typeof (evidence == null ? void 0 : evidence.weight) === "number" ? evidence.weight : 0;
        const type = typeof (evidence == null ? void 0 : evidence.type) === "string" ? evidence.type : "other";
        const detail = typeof (evidence == null ? void 0 : evidence.detail) === "string" ? evidence.detail : "";
        const evidenceLine = block.createEl("div", { text: `+${weight} ${type}: ${detail}` });
        if (evidence && evidence.scoring === true) {
          evidenceLine.style.fontWeight = "600";
        }
      }
    }
  }
  renderSemanticCandidates(parent, candidates) {
    if (candidates.length === 0) {
      return;
    }
    const section = parent.createDiv();
    section.style.marginBottom = "8px";
    section.createEl("strong", { text: "Semantic candidates" });
    const list = section.createDiv();
    const previewCount = Math.min(candidates.length, 8);
    for (const item of candidates.slice(0, previewCount)) {
      list.createEl("div", {
        text: `- ${item.path} (${formatSimilarity(item.similarity)})`
      });
    }
    if (candidates.length > previewCount) {
      list.createEl("small", {
        text: `...and ${candidates.length - previewCount} more`
      });
    }
  }
};
function ensurePR3ScopeStatusStyle() {
  if (typeof document === "undefined" || !document.head) {
    return;
  }
  const styleId = "omni-forge-pr3-scope-style";
  if (document.getElementById(styleId)) {
    return;
  }
  const styleEl = document.createElement("style");
  styleEl.id = styleId;
  styleEl.textContent = `.pr3-scope-status {
  margin-bottom: 8px;
  padding: 8px;
  border: 1px solid var(--background-modifier-border);
  border-radius: 8px;
}
.pr3-scope-status small {
  display: block;
  margin-top: 4px;
  opacity: 0.85;
}`;
  document.head.appendChild(styleEl);
}
var FolderReclassPreviewModal = class extends import_obsidian4.Modal {
  constructor(app, recommendations, pluginSettings) {
    super(app);
    this.settings = pluginSettings || { ...DEFAULT_SETTINGS };
    this.recommendations = Array.isArray(recommendations) ? recommendations : [];
    this.selectedFilePaths = /* @__PURE__ */ new Set();
    this.latestMovePlan = null;
    this.movePreviewEl = null;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    ensurePR3ScopeStatusStyle();
    contentEl.createEl("h2", { text: "Folder reclassification preview + move apply" });
    const scope = createPR3Step2ScopeFromSettings(this.settings);
    const scopeStatus = contentEl.createDiv({ cls: "pr3-scope-status" });
    scopeStatus.createEl("div", { text: `Scope Policy: ${scope.policy}` });
    scopeStatus.createEl("div", { text: `Mode: ${scope.mode}` });
    scopeStatus.createEl("div", { text: `Path Semantics: ${scope.pathSemantics}` });
    if (scope.roots.length === 0) {
      scopeStatus.createEl("div", { text: "Roots: (none - deny-all)" });
    } else {
      scopeStatus.createEl("div", { text: `Roots: ${scope.roots.join(", ")}` });
    }
    if (scope.status !== "ok") {
      scopeStatus.createEl("small", { text: scope.message });
    }
    if (this.settings.showPr3ScopeFingerprint) {
      const fingerprint = computePR3ScopeFingerprint(scope);
      // Display-only debug metadata for warn-only context; never a policy/enforcement signal.
      scopeStatus.createEl("small", { text: `Debug: Fingerprint: ${fingerprint}` });
    }
    if (scope.mode === "warn-only") {
      scopeStatus.createEl("small", {
        text: "Scope is informational only. No enforcement is applied."
      });
    }
    scopeStatus.createEl("small", {
      text: `Move Apply: mode=${this.getCurrentApplyMode()}, autoCreateTargetFolders=${this.getAutoCreateTargetFolders() ? "true" : "false"}, conflictPolicy=${this.getCurrentMoveConflictPolicy()}`
    });
    this.rows = this.buildRows(this.recommendations);
    for (const row of this.rows) {
      if (!row.needsReview) {
        this.selectedFilePaths.add(row.filePath);
      }
    }
    this.summaryEl = contentEl.createEl("p");
    this.updateSummary();
    const diagnosis = this.buildFolderDiagnosisSummary(this.rows);
    const dominantFolder = typeof diagnosis.dominantFolder === "string" ? diagnosis.dominantFolder : "";
    const totalRows = this.rows.length;
    let alignedCount = 0;
    let outlierCount = 0;
    let needsReviewCount = 0;
    for (const row of this.rows) {
      if (row.needsReview === true) {
        needsReviewCount += 1;
      }
      if (dominantFolder) {
        if (row.suggestedFolder === dominantFolder) {
          alignedCount += 1;
        } else {
          outlierCount += 1;
        }
      }
    }
    if (typeof console !== "undefined" && typeof console.debug === "function") {
      console.debug("[Omni-Forge][PR3][Telemetry]", {
        totalRows,
        dominantFolder,
        alignedCount,
        outlierCount,
        needsReviewCount,
        cohesionScore: diagnosis.cohesionScore
      });
    }
    const cohesionRiskLevel = diagnosis.cohesionScore >= 70 ? "Stable" : diagnosis.cohesionScore >= 40 ? "Moderate" : "Fragmented";
    const dominantInstability = dominantFolder !== "" && totalRows > 0 && outlierCount / totalRows > 0.5;
    const interpretationText = dominantInstability ? `Risk Level: ${cohesionRiskLevel} | Dominant Cluster: Unstable` : `Risk Level: ${cohesionRiskLevel}`;
    const diagnosisText = `Folder diagnosis (preview): Cohesion ${diagnosis.cohesionScore}/100 | Note count: ${diagnosis.noteCount} | Possible outliers: ${diagnosis.possibleOutlierCount}`;
    if (diagnosisText.length <= 240) {
      const diagnosisEl = contentEl.createEl("p");
      diagnosisEl.setText(diagnosisText);
      diagnosisEl.style.opacity = "0.85";
      diagnosisEl.style.marginTop = "-6px";
      diagnosisEl.style.marginBottom = "10px";
      const interpretationEl = contentEl.createEl("p");
      interpretationEl.setText(interpretationText);
      interpretationEl.style.opacity = "0.8";
      interpretationEl.style.marginTop = "-8px";
      interpretationEl.style.marginBottom = "10px";
    } else if (typeof console !== "undefined" && typeof console.warn === "function") {
      console.warn("[Omni-Forge] PR3 folder diagnosis summary skipped due to UI payload risk", diagnosis);
    }
    const templateSection = contentEl.createDiv();
    templateSection.style.marginBottom = "12px";
    const templateLabel = templateSection.createEl("small", {
      text: "v1.4 Folder Intelligence output template"
    });
    templateLabel.style.opacity = "0.8";
    const templateBlock = templateSection.createEl("pre", {
      text: this.buildFolderIntelligenceTemplateMarkdown(this.rows, diagnosis)
    });
    templateBlock.style.whiteSpace = "pre-wrap";
    templateBlock.style.border = "1px solid var(--background-modifier-border)";
    templateBlock.style.borderRadius = "8px";
    templateBlock.style.padding = "8px";
    templateBlock.style.marginTop = "6px";
    templateBlock.style.background = "var(--background-secondary)";
    const list = contentEl.createDiv();
    list.style.maxHeight = "52vh";
    list.style.overflow = "auto";
    list.style.border = "1px solid var(--background-modifier-border)";
    list.style.borderRadius = "8px";
    list.style.padding = "8px";
    if (this.rows.length === 0) {
      list.createEl("div", { text: "No preview items." });
    } else {
      for (const row of this.rows) {
        const section = list.createDiv();
        section.style.padding = "8px";
        section.style.marginBottom = "8px";
        section.style.border = "1px solid var(--background-modifier-border)";
        section.style.borderRadius = "8px";
        const top = section.createDiv();
        top.style.display = "flex";
        top.style.alignItems = "center";
        top.style.gap = "8px";
        const checkbox = top.createEl("input", { type: "checkbox" });
        checkbox.checked = this.selectedFilePaths.has(row.filePath);
        checkbox.onchange = () => {
          if (checkbox.checked) {
            this.selectedFilePaths.add(row.filePath);
          } else {
            this.selectedFilePaths.delete(row.filePath);
          }
          this.updateSummary();
          this.refreshMovePreview(false);
        };
        const clusterBadgeText = row.needsReview === true ? "🟡 Needs Review" : row.suggestedFolder !== dominantFolder ? "🔴 Outlier" : "🟢 Dominant Cluster";
        const clusterBadge = top.createEl("small", { text: clusterBadgeText });
        clusterBadge.style.fontWeight = "600";
        clusterBadge.style.padding = "2px 6px";
        clusterBadge.style.border = "1px solid var(--background-modifier-border)";
        clusterBadge.style.borderRadius = "999px";
        if (dominantFolder) {
          const alignmentScore = row.suggestedFolder === dominantFolder ? 1 : 0;
          const alignmentIndicator = top.createEl("small", {
            text: alignmentScore === 1 ? "Aligned with dominant cluster" : "Diverges from dominant cluster"
          });
          alignmentIndicator.style.opacity = "0.75";
          let alignmentFactor = 1;
          if (alignmentScore !== 1) {
            if (diagnosis.cohesionScore >= 70) {
              alignmentFactor = 0.85;
            } else if (diagnosis.cohesionScore >= 40) {
              alignmentFactor = 0.75;
            } else {
              alignmentFactor = 0.6;
            }
          }
          const hasNumericConfidence = typeof row.confidence === "number" && Number.isFinite(row.confidence);
          const shadowConfidenceText = hasNumericConfidence ? `Shadow Confidence: ${row.confidence.toFixed(3)} → ${(row.confidence * alignmentFactor).toFixed(3)} (x${alignmentFactor.toFixed(2)})` : `Shadow Confidence: n/a (x${alignmentFactor.toFixed(2)})`;
          const shadowConfidenceEl = top.createEl("small", { text: shadowConfidenceText });
          shadowConfidenceEl.style.opacity = "0.78";
        }
        top.createEl("strong", { text: row.filePath });
        const reviewBadge = top.createEl("small", {
          text: row.needsReview ? "needsReview=true" : "needsReview=false"
        });
        reviewBadge.style.marginLeft = "auto";
        section.createEl("div", { text: `Current folder: ${row.currentFolder}` });
        section.createEl("div", { text: `Suggested folder: ${row.suggestedFolder}` });
        section.createEl("div", { text: `Reason: ${row.reasonSummary}` });
        section.createEl("div", { text: `Score: ${row.score.toFixed(3)}` });
        section.createEl("div", { text: `Confidence: ${row.confidence}` });
        if (row.evidence.length > 0) {
          const evidenceBlock = section.createDiv();
          evidenceBlock.style.marginTop = "4px";
          evidenceBlock.createEl("strong", { text: "Evidence" });
          for (const evidenceLine of row.evidence) {
            evidenceBlock.createEl("div", { text: `- ${evidenceLine}` });
          }
        }
      }
    }
    this.movePreviewEl = contentEl.createDiv({ cls: "pr3-move-preview" });
    this.movePreviewEl.style.marginTop = "10px";
    this.movePreviewEl.style.padding = "8px";
    this.movePreviewEl.style.border = "1px dashed var(--background-modifier-border)";
    this.movePreviewEl.style.borderRadius = "8px";
    this.refreshMovePreview(false);
    const footer = contentEl.createDiv();
    footer.style.display = "flex";
    footer.style.justifyContent = "flex-end";
    footer.style.gap = "8px";
    footer.style.marginTop = "12px";
    const cancelButton = footer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => this.close();
    const refreshButton = footer.createEl("button", { text: "Dry-run preview" });
    refreshButton.onclick = () => this.refreshMovePreview(true);
    const applyButton = footer.createEl("button", { text: "Apply Move", cls: "mod-cta" });
    applyButton.onclick = async () => {
      applyButton.disabled = true;
      try {
        const result = await this.applySelectedMoves();
        if (result.applied || result.closed) {
          this.close();
        }
      } finally {
        applyButton.disabled = false;
      }
    };
  }
  onClose() {
    this.latestMovePlan = null;
    this.movePreviewEl = null;
    this.contentEl.empty();
  }
  updateSummary() {
    if (!this.summaryEl) {
      return;
    }
    this.summaryEl.setText(
      `Shown: ${this.rows.length} | Selected: ${this.selectedFilePaths.size} | ApplyMode: ${this.getCurrentApplyMode()}`
    );
  }
  getCurrentApplyMode() {
    return normalizeFolderReclassApplyMode(this.settings.applyMode);
  }
  getCurrentMoveConflictPolicy() {
    return normalizeFolderReclassMoveConflictPolicy(this.settings.moveConflictPolicy);
  }
  getAutoCreateTargetFolders() {
    return this.settings.autoCreateTargetFolders === true;
  }
  getFolderPathFromFilePath(filePath) {
    const normalized = (0, import_obsidian4.normalizePath)(typeof filePath === "string" ? filePath : "");
    if (!normalized.includes("/")) {
      return "";
    }
    return normalized.slice(0, normalized.lastIndexOf("/"));
  }
  getFileNameFromPath(filePath) {
    const normalized = (0, import_obsidian4.normalizePath)(typeof filePath === "string" ? filePath : "");
    const chunks = normalized.split("/");
    return chunks[chunks.length - 1] || "";
  }
  formatMovePlanReason(reasonCode) {
    const map = {
      source_missing: "source note missing",
      source_not_markdown: "source is not markdown",
      invalid_file_name: "invalid file name",
      same_path: "already in target path",
      apply_mode_metadata_only: "applyMode=metadata_only",
      target_folder_missing: "target folder missing and autoCreate disabled",
      target_conflict_skip: "target conflict (policy=skip)",
      target_conflict_unresolved: "target conflict unresolved",
      conflict_suffix: "target conflict resolved by suffix"
    };
    return map[reasonCode] || reasonCode || "unknown";
  }
  resolveMoveConflictPath(targetPath, sourcePath, policy) {
    const normalizedTargetPath = (0, import_obsidian4.normalizePath)(targetPath);
    const normalizedSourcePath = (0, import_obsidian4.normalizePath)(sourcePath);
    const existing = this.app.vault.getAbstractFileByPath(normalizedTargetPath);
    if (!existing || existing.path === normalizedSourcePath) {
      return { ok: true, path: normalizedTargetPath, wasAdjusted: false };
    }
    if (policy === "skip") {
      return { ok: false, reason: "target_conflict_skip" };
    }
    const slashIdx = normalizedTargetPath.lastIndexOf("/");
    const fileName = slashIdx >= 0 ? normalizedTargetPath.slice(slashIdx + 1) : normalizedTargetPath;
    const folderPath = slashIdx >= 0 ? normalizedTargetPath.slice(0, slashIdx) : "";
    const dotIdx = fileName.lastIndexOf(".");
    const hasExt = dotIdx > 0;
    const stem = hasExt ? fileName.slice(0, dotIdx) : fileName;
    const ext = hasExt ? fileName.slice(dotIdx) : "";
    for (let i = 1; i <= 999; i += 1) {
      const candidateName = `${stem} (${i})${ext}`;
      const candidatePath = folderPath ? (0, import_obsidian4.normalizePath)(`${folderPath}/${candidateName}`) : (0, import_obsidian4.normalizePath)(candidateName);
      const candidateExisting = this.app.vault.getAbstractFileByPath(candidatePath);
      if (!candidateExisting || candidateExisting.path === normalizedSourcePath) {
        return { ok: true, path: candidatePath, wasAdjusted: true };
      }
    }
    return { ok: false, reason: "target_conflict_unresolved" };
  }
  buildMovePlanForSelection() {
    const applyMode = this.getCurrentApplyMode();
    const conflictPolicy = this.getCurrentMoveConflictPolicy();
    const autoCreateTargetFolders = this.getAutoCreateTargetFolders();
    const selectedRows = this.rows.filter((row) => this.selectedFilePaths.has(row.filePath));
    const items = [];
    for (const row of selectedRows) {
      const sourcePath = (0, import_obsidian4.normalizePath)(row.filePath);
      const sourceEntry = this.app.vault.getAbstractFileByPath(sourcePath);
      if (!sourceEntry) {
        items.push({ sourcePath, status: "skip", reason: "source_missing" });
        continue;
      }
      if (!(sourceEntry instanceof import_obsidian4.TFile) || sourceEntry.extension !== "md") {
        items.push({ sourcePath, status: "skip", reason: "source_not_markdown" });
        continue;
      }
      const fileName = this.getFileNameFromPath(sourcePath);
      if (!fileName) {
        items.push({ sourcePath, status: "skip", reason: "invalid_file_name" });
        continue;
      }
      const targetFolder = normalizeFolderReclassSuggestedFolder(row.suggestedFolder);
      const targetPath = targetFolder === "(root)" ? fileName : (0, import_obsidian4.normalizePath)(`${targetFolder}/${fileName}`);
      if (targetPath === sourcePath) {
        items.push({ sourcePath, targetPath, status: "noop", reason: "same_path" });
        continue;
      }
      if (applyMode === "metadata_only") {
        items.push({
          sourcePath,
          targetPath,
          status: "skip",
          reason: "apply_mode_metadata_only",
          reasonSummary: row.reasonSummary
        });
        continue;
      }
      const targetFolderPath = this.getFolderPathFromFilePath(targetPath);
      if (targetFolderPath) {
        const folderEntry = this.app.vault.getAbstractFileByPath(targetFolderPath);
        if (!(folderEntry instanceof import_obsidian4.TFolder) && !autoCreateTargetFolders) {
          items.push({
            sourcePath,
            targetPath,
            status: "skip",
            reason: "target_folder_missing",
            reasonSummary: row.reasonSummary
          });
          continue;
        }
      }
      const resolved = this.resolveMoveConflictPath(targetPath, sourcePath, conflictPolicy);
      if (!resolved.ok) {
        items.push({
          sourcePath,
          targetPath,
          status: "skip",
          reason: resolved.reason || "target_conflict_unresolved",
          reasonSummary: row.reasonSummary
        });
        continue;
      }
      items.push({
        sourcePath,
        targetPath: resolved.path,
        status: "move",
        reason: resolved.wasAdjusted ? "conflict_suffix" : "ok",
        reasonSummary: row.reasonSummary
      });
    }
    const moveCount = items.filter((item) => item.status === "move").length;
    const skipCount = items.filter((item) => item.status === "skip").length;
    const noopCount = items.filter((item) => item.status === "noop").length;
    return {
      applyMode,
      conflictPolicy,
      autoCreateTargetFolders,
      items,
      moveCount,
      skipCount,
      noopCount
    };
  }
  refreshMovePreview(notify) {
    if (!this.movePreviewEl) {
      return;
    }
    const plan = this.buildMovePlanForSelection();
    this.latestMovePlan = plan;
    this.movePreviewEl.empty();
    this.movePreviewEl.createEl("strong", { text: "Dry-run move preview" });
    this.movePreviewEl.createEl("div", {
      text: `mode=${plan.applyMode} | conflictPolicy=${plan.conflictPolicy} | autoCreateTargetFolders=${plan.autoCreateTargetFolders ? "true" : "false"}`
    });
    this.movePreviewEl.createEl("div", {
      text: `Selected=${plan.items.length} | move=${plan.moveCount} | skip=${plan.skipCount} | noop=${plan.noopCount}`
    });
    if (plan.items.length === 0) {
      this.movePreviewEl.createEl("small", { text: "No selected rows." });
      return;
    }
    const list = this.movePreviewEl.createDiv();
    list.style.marginTop = "6px";
    const previewItems = plan.items.slice(0, 24);
    for (const item of previewItems) {
      const targetText = item.targetPath ? ` -> ${item.targetPath}` : "";
      const reasonText = item.reason && item.reason !== "ok" ? ` (${this.formatMovePlanReason(item.reason)})` : "";
      list.createEl("div", {
        text: `[${item.status}] ${item.sourcePath}${targetText}${reasonText}`
      });
    }
    if (plan.items.length > previewItems.length) {
      list.createEl("small", { text: `...and ${plan.items.length - previewItems.length} more` });
    }
    if (notify) {
      new import_obsidian4.Notice(
        `Dry-run: move=${plan.moveCount}, skip=${plan.skipCount}, noop=${plan.noopCount}`,
        4e3
      );
    }
  }
  async ensureFolderPathForMove(folderPath) {
    const normalized = (0, import_obsidian4.normalizePath)(folderPath);
    if (!normalized) {
      return;
    }
    const parts = normalized.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const existing = this.app.vault.getAbstractFileByPath(currentPath);
      if (existing instanceof import_obsidian4.TFolder) {
        continue;
      }
      if (existing instanceof import_obsidian4.TFile) {
        throw new Error(`Cannot create folder because file exists at ${currentPath}`);
      }
      await this.app.vault.createFolder(currentPath);
    }
  }
  async applySelectedMoves() {
    const plan = this.buildMovePlanForSelection();
    this.latestMovePlan = plan;
    this.refreshMovePreview(false);
    if (plan.applyMode === "metadata_only") {
      new import_obsidian4.Notice(
        "Apply mode is metadata_only. Move flow is dry-run only.",
        5e3
      );
      return { applied: false, closed: false };
    }
    if (plan.moveCount <= 0) {
      new import_obsidian4.Notice(
        `No movable files in dry-run (skip=${plan.skipCount}, noop=${plan.noopCount}).`,
        5e3
      );
      return { applied: false, closed: false };
    }
    const approved = typeof window !== "undefined" && typeof window.confirm === "function" ? window.confirm(`Apply folder moves now? move=${plan.moveCount}, skip=${plan.skipCount}, noop=${plan.noopCount}`) : true;
    if (!approved) {
      return { applied: false, closed: false };
    }
    let moved = 0;
    let skipped = 0;
    const errors = [];
    for (const item of plan.items) {
      if (item.status !== "move") {
        skipped += 1;
        continue;
      }
      try {
        const source = this.app.vault.getAbstractFileByPath(item.sourcePath);
        if (!(source instanceof import_obsidian4.TFile) || source.extension !== "md") {
          skipped += 1;
          continue;
        }
        const resolvedConflict = this.resolveMoveConflictPath(
          item.targetPath,
          source.path,
          plan.conflictPolicy
        );
        if (!resolvedConflict.ok) {
          skipped += 1;
          continue;
        }
        const finalTargetPath = resolvedConflict.path;
        const folderPath = this.getFolderPathFromFilePath(finalTargetPath);
        if (folderPath) {
          const folderEntry = this.app.vault.getAbstractFileByPath(folderPath);
          if (!(folderEntry instanceof import_obsidian4.TFolder)) {
            if (!plan.autoCreateTargetFolders) {
              skipped += 1;
              continue;
            }
            await this.ensureFolderPathForMove(folderPath);
          }
        }
        await this.app.fileManager.renameFile(source, finalTargetPath);
        moved += 1;
      } catch (error) {
        const message = error instanceof Error ? error.message : "Unknown folder move error";
        errors.push(`${item.sourcePath} -> ${item.targetPath}: ${message}`);
      }
    }
    if (errors.length > 0 && typeof console !== "undefined" && typeof console.warn === "function") {
      console.warn("[Omni-Forge] Folder move apply errors", errors);
    }
    new import_obsidian4.Notice(
      `Folder move apply complete: moved=${moved}, skipped=${skipped}, errors=${errors.length}`,
      6e3
    );
    return { applied: moved > 0, closed: true };
  }
  buildFolderIntelligenceTemplateMarkdown(rows, diagnosis) {
    const safeRows = Array.isArray(rows) ? rows : [];
    const safeDiagnosis = diagnosis && typeof diagnosis === "object" ? diagnosis : {
      cohesionScore: 0,
      possibleOutlierCount: 0
    };
    const clusterCounts = /* @__PURE__ */ new Map();
    const externalFolderCounts = /* @__PURE__ */ new Map();
    for (const row of safeRows) {
      const suggested = row && typeof row.suggestedFolder === "string" && row.suggestedFolder.trim() ? row.suggestedFolder.trim() : "(unknown)";
      const current = row && typeof row.currentFolder === "string" && row.currentFolder.trim() ? row.currentFolder.trim() : "(unknown)";
      clusterCounts.set(suggested, (clusterCounts.get(suggested) || 0) + 1);
      if (suggested !== current) {
        externalFolderCounts.set(suggested, (externalFolderCounts.get(suggested) || 0) + 1);
      }
    }
    const summarizeMap = (map) => {
      if (map.size === 0) {
        return "(none)";
      }
      return [...map.entries()].sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0])).slice(0, 5).map(([folder, count]) => `${folder} (${count})`).join(", ");
    };
    const recommendations = safeRows.filter((row) => row && (row.currentFolder !== row.suggestedFolder || row.needsReview === true)).slice(0, 30);
    const lines = [
      "## 📂 폴더 진단",
      "",
      `- 응집도 점수: ${Number.isFinite(safeDiagnosis.cohesionScore) ? safeDiagnosis.cohesionScore : 0}/100`,
      `- 내부 클러스터: ${summarizeMap(clusterCounts)}`,
      `- 외부 후보 폴더: ${summarizeMap(externalFolderCounts)}`,
      `- 고립 노트 후보: ${Number.isFinite(safeDiagnosis.possibleOutlierCount) ? safeDiagnosis.possibleOutlierCount : 0}개`,
      "",
      "## 🔄 이동 추천 (검증 필요)",
      ""
    ];
    if (recommendations.length === 0) {
      lines.push("- (추천 항목 없음)");
      return lines.join("\n");
    }
    for (const row of recommendations) {
      const notePath = typeof row.filePath === "string" ? row.filePath.trim() : "";
      const noteLink = notePath ? `[[${notePath.replace(/\.md$/i, "")}]]` : "[[unknown-note]]";
      const target = typeof row.suggestedFolder === "string" && row.suggestedFolder.trim() ? row.suggestedFolder.trim() : "(unknown)";
      const reasonSummary = typeof row.reasonSummary === "string" && row.reasonSummary.trim() ? row.reasonSummary.trim() : "규칙 기반 분류 결과";
      const evidence = Array.isArray(row.evidence) && row.evidence.length > 0 && typeof row.evidence[0] === "string" ? row.evidence[0].trim() : "규칙 기반 분류 결과";
      const confidence = typeof row.confidence === "string" && row.confidence.trim() ? row.confidence.trim() : row.needsReview ? "low" : "high";
      lines.push(`- ${noteLink} → ${target} (사유: ${reasonSummary} / 근거: ${evidence} / 신뢰도: ${confidence})`);
    }
    return lines.join("\n");
  }
  buildFolderDiagnosisSummary(rows) {
    const safeRows = Array.isArray(rows) ? rows : [];
    const noteCount = safeRows.length;
    if (noteCount === 0) {
      return {
        dominantFolder: "",
        cohesionScore: 0,
        noteCount: 0,
        possibleOutlierCount: 0
      };
    }
    const suggestedCounts = /* @__PURE__ */ new Map();
    for (const row of safeRows) {
      const suggestedFolder = row && typeof row.suggestedFolder === "string" && row.suggestedFolder.trim() ? row.suggestedFolder.trim() : "(unknown)";
      const prev = suggestedCounts.get(suggestedFolder) || 0;
      suggestedCounts.set(suggestedFolder, prev + 1);
    }
    const orderedFolders = [...suggestedCounts.entries()].sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]));
    const dominantFolder = orderedFolders.length > 0 ? orderedFolders[0][0] : "";
    const dominantCount = dominantFolder ? suggestedCounts.get(dominantFolder) || 0 : 0;
    const cohesionScore = Math.round(dominantCount / noteCount * 100);
    let possibleOutlierCount = 0;
    for (const row of safeRows) {
      const suggestedFolder = row && typeof row.suggestedFolder === "string" ? row.suggestedFolder : "";
      if (row && (row.needsReview === true || suggestedFolder !== dominantFolder)) {
        possibleOutlierCount += 1;
      }
    }
    return {
      dominantFolder,
      cohesionScore,
      noteCount,
      possibleOutlierCount
    };
  }
  buildRows(recommendations) {
    const bestByFilePath = /* @__PURE__ */ new Map();
    for (const item of recommendations) {
      if (!item || typeof item.filePath !== "string") {
        continue;
      }
      const filePath = item.filePath.trim();
      if (!filePath) {
        continue;
      }
      const needsReview = item.needsReview === true || item.reviewNeeded === true || item.verifyRequired === true;
      const evidenceRaw = Array.isArray(item.evidence) ? item.evidence : Array.isArray(item.reasonEvidence) ? item.reasonEvidence : Array.isArray(item.evidenceLines) ? item.evidenceLines : [];
      const candidate = {
        filePath,
        currentFolder: normalizeFolderReclassCurrentFolder(item.currentFolder, filePath),
        suggestedFolder: normalizeFolderReclassSuggestedFolder(
          typeof item.suggestedFolder === "string" && item.suggestedFolder.trim() ? item.suggestedFolder : item.targetFolder
        ),
        score: Number.isFinite(item.score) ? Number(item.score) : 0,
        needsReview,
        reasonSummary: normalizeFolderReclassReasonSummary(
          typeof item.reasonSummary === "string" && item.reasonSummary.trim() ? item.reasonSummary : typeof item.reason === "string" && item.reason.trim() ? item.reason : item.recommendationReason,
          evidenceRaw
        ),
        confidence: normalizeFolderReclassConfidence(
          typeof item.confidence === "string" && item.confidence.trim() ? item.confidence : typeof item.confidenceLabel === "string" && item.confidenceLabel.trim() ? item.confidenceLabel : item.confidenceLevel,
          needsReview
        ),
        evidence: normalizeFolderReclassEvidenceLines(evidenceRaw)
      };
      const current = bestByFilePath.get(filePath);
      if (!current || this.isBetterCandidateForFile(candidate, current)) {
        bestByFilePath.set(filePath, candidate);
      }
    }
    const rows = [...bestByFilePath.values()];
    rows.sort((a, b) => this.compareRows(a, b));
    return rows;
  }
  compareRows(a, b) {
    if (a.needsReview !== b.needsReview) {
      return a.needsReview ? 1 : -1;
    }
    if (a.score !== b.score) {
      return b.score - a.score;
    }
    return a.filePath.localeCompare(b.filePath);
  }
  isBetterCandidateForFile(candidate, current) {
    if (candidate.needsReview !== current.needsReview) {
      return current.needsReview;
    }
    if (candidate.score !== current.score) {
      return candidate.score > current.score;
    }
    const suggestedFolderCmp = candidate.suggestedFolder.localeCompare(current.suggestedFolder);
    if (suggestedFolderCmp !== 0) {
      return suggestedFolderCmp < 0;
    }
    return candidate.filePath.localeCompare(current.filePath) < 0;
  }
};
var FolderReclassActiveFileSource = class {
  toCandidate(file) {
    if (!(file instanceof import_obsidian4.TFile) || file.extension !== "md") {
      return null;
    }
    const name = typeof file.basename === "string" ? file.basename : "";
    return {
      filePath: file.path,
      name: name || void 0
    };
  }
  getCandidates(ctx) {
    if (!ctx || !ctx.app) {
      return [];
    }
    const selectedFiles = Array.isArray(ctx.selectedFiles) ? ctx.selectedFiles : [];
    if (selectedFiles.length > 0) {
      const out = [];
      for (const file of selectedFiles) {
        const candidate = this.toCandidate(file);
        if (candidate) {
          out.push(candidate);
        }
      }
      return out;
    }
    if (!ctx.app.workspace) {
      return [];
    }
    const activeFile = ctx.app.workspace.getActiveFile();
    const candidate = this.toCandidate(activeFile);
    return candidate ? [candidate] : [];
  }
};
const PR3_FOLDER_RECLASS_DEFAULT_DENY = true;
const PR3_FOLDER_RECLASS_MAX_SCOPE_ROOTS = 20;
const PR3_SOFT_WARNING_ENABLED = false;
const PR3_ENFORCEMENT_ENABLED = false;
const PR3_POLICY_STATE = Object.freeze({
  TELEMETRY: "telemetry",
  WARN: "warn",
  ENFORCE: "enforce",
  BLOCKED: "blocked"
});
const PR3_POLICY_VERSION = "v1";
const PR3_POLICY_REASON_MESSAGES = Object.freeze({
  OOS_GT_THRESHOLD: Object.freeze({
    user: "[Omni-Forge][PR3] Scope warning: out-of-scope notes detected (soft-warning only).",
    dev: "Out-of-scope count exceeded maxOutOfScopeBeforeBlock."
  }),
  INSUFFICIENT_METRICS: Object.freeze({
    user: "[Omni-Forge][PR3] Scope info incomplete; enforcement deferred (telemetry only).",
    dev: "Missing outOfScopeCount and/or maxOutOfScopeBeforeBlock metrics."
  })
});
var PR3ScopeWarningModal = class extends import_obsidian4.Modal {
  constructor(app, policy) {
    super(app);
    this.policy = policy && typeof policy === "object" ? policy : null;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Omni-Forge PR3 Scope Warning" });
    const explain = this.policy && this.policy.explain && typeof this.policy.explain === "object" ? this.policy.explain : null;
    const userMessage = explain && typeof explain.userMessage === "string" ? explain.userMessage : "[Omni-Forge][PR3] Scope warning detected (telemetry only).";
    contentEl.createEl("p", { text: userMessage });
    const reasonCodes = explain && Array.isArray(explain.reasonCodes) ? explain.reasonCodes.filter((code) => typeof code === "string" && code.length > 0) : [];
    const metrics = this.policy && this.policy.metrics && typeof this.policy.metrics === "object" ? this.policy.metrics : null;
    const outOfScopeCount = metrics && Number.isFinite(metrics.outOfScopeCount) ? metrics.outOfScopeCount : null;
    const maxOutOfScopeBeforeBlock = metrics && Number.isFinite(metrics.maxOutOfScopeBeforeBlock) ? metrics.maxOutOfScopeBeforeBlock : null;
    if (reasonCodes.length > 0 || typeof outOfScopeCount === "number" || typeof maxOutOfScopeBeforeBlock === "number") {
      const details = contentEl.createDiv();
      if (reasonCodes.length > 0) {
        details.createEl("div", { text: `Reason codes: ${reasonCodes.join(", ")}` });
      }
      if (typeof outOfScopeCount === "number" || typeof maxOutOfScopeBeforeBlock === "number") {
        const outOfScopeText = typeof outOfScopeCount === "number" ? String(outOfScopeCount) : "n/a";
        const thresholdText = typeof maxOutOfScopeBeforeBlock === "number" ? String(maxOutOfScopeBeforeBlock) : "n/a";
        details.createEl("div", {
          text: `Metrics: outOfScopeCount=${outOfScopeText}, maxOutOfScopeBeforeBlock=${thresholdText}`
        });
      }
    }
    const footer = contentEl.createDiv();
    footer.style.display = "flex";
    footer.style.justifyContent = "flex-end";
    footer.style.gap = "8px";
    footer.style.marginTop = "12px";
    const cancelButton = footer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => this.close();
    const continueButton = footer.createEl("button", { text: "Continue", cls: "mod-cta" });
    continueButton.onclick = () => this.close();
  }
  onClose() {
    this.contentEl.empty();
  }
};
/**
 * @typedef {Object} PR3ScopeEnforcementDecision
 * @property {"telemetry-only" | "enforce" | "blocked"} mode
 * @property {string} [reason]
 * @property {number} [outOfScopeCount]
 * @property {number} [unknownPathCount]
 */
/**
 * @typedef {Object} PR3ScopeEnforcementContract
 * @property {"v1"} version
 * @property {{mode:"default-deny", behavior:"telemetry-only"}} policy
 * @property {{maxOutOfScopeBeforeBlock:number}} thresholds
 * @property {string} [notes]
 */
function evaluatePR3ScopeEnforcementDecision(contract, shadowPayload) {
  const safeContract = contract && typeof contract === "object" ? contract : null;
  const safePayload = shadowPayload && typeof shadowPayload === "object" ? shadowPayload : {};
  const outOfScopeCount = Number.isFinite(safePayload.outOfScopeCount) ? Math.max(0, Math.floor(safePayload.outOfScopeCount)) : 0;
  const unknownPathCount = Number.isFinite(safePayload.unknownPathCount) ? Math.max(0, Math.floor(safePayload.unknownPathCount)) : 0;
  if (safeContract && safeContract.thresholds && Number.isFinite(safeContract.thresholds.maxOutOfScopeBeforeBlock)) {
    void safeContract.thresholds.maxOutOfScopeBeforeBlock;
  }
  const decision = {
    mode: "telemetry-only",
    outOfScopeCount,
    unknownPathCount
  };
  if (outOfScopeCount > 0) {
    decision.reason = "out_of_scope_detected";
  }
  return decision;
}
function buildPR3EvaluationSnapshot({
  selectionInfo,
  scopeInfo,
  shadowPayload,
  decision,
  policyDecision
}) {
  const snapshot = {
    version: "v1"
  };
  if (typeof selectionInfo !== "undefined") {
    snapshot.selection = selectionInfo;
  }
  if (typeof scopeInfo !== "undefined") {
    snapshot.scope = scopeInfo;
  }
  if (typeof shadowPayload !== "undefined") {
    snapshot.shadow = shadowPayload;
  }
  if (typeof decision !== "undefined") {
    snapshot.decision = decision;
  }
  if (typeof policyDecision !== "undefined") {
    snapshot.policy = policyDecision;
  }
  return snapshot;
}
function buildPR3PolicyDecision({
  decision,
  snapshot
}) {
  const safeDecision = decision && typeof decision === "object" ? decision : null;
  const safeSnapshot = snapshot && typeof snapshot === "object" ? snapshot : null;
  const policyDecision = {
    version: PR3_POLICY_VERSION,
    state: PR3_POLICY_STATE.TELEMETRY
  };
  if (safeDecision && typeof safeDecision.reason === "string") {
    policyDecision.reasons = [safeDecision.reason];
  }
  const shadow = safeSnapshot && safeSnapshot.shadow && typeof safeSnapshot.shadow === "object" ? safeSnapshot.shadow : null;
  const contract = safeDecision && safeDecision.contract && typeof safeDecision.contract === "object" ? safeDecision.contract : null;
  const thresholds = contract && contract.thresholds && typeof contract.thresholds === "object" ? contract.thresholds : null;
  const outOfScopeCount = shadow && Number.isFinite(shadow.outOfScopeCount) ? shadow.outOfScopeCount : null;
  const maxOutOfScopeBeforeBlock = thresholds && Number.isFinite(thresholds.maxOutOfScopeBeforeBlock) ? thresholds.maxOutOfScopeBeforeBlock : null;
  const hasOutOfScopeMetric = typeof outOfScopeCount === "number";
  const hasThresholdMetric = typeof maxOutOfScopeBeforeBlock === "number";
  if (hasOutOfScopeMetric || hasThresholdMetric) {
    policyDecision.metrics = {
      outOfScopeCount: hasOutOfScopeMetric ? outOfScopeCount : null,
      maxOutOfScopeBeforeBlock: hasThresholdMetric ? maxOutOfScopeBeforeBlock : null
    };
  }
  if (hasOutOfScopeMetric && hasThresholdMetric && outOfScopeCount > maxOutOfScopeBeforeBlock) {
    policyDecision.candidateState = PR3_POLICY_STATE.WARN;
    policyDecision.transitionReasons = ["OOS_GT_THRESHOLD"];
  } else {
    policyDecision.candidateState = PR3_POLICY_STATE.TELEMETRY;
    policyDecision.transitionReasons = hasOutOfScopeMetric && hasThresholdMetric ? [] : ["INSUFFICIENT_METRICS"];
  }
  policyDecision.state = policyDecision.candidateState === PR3_POLICY_STATE.WARN ? PR3_POLICY_STATE.WARN : PR3_POLICY_STATE.TELEMETRY;
  const reasonCodes = Array.isArray(policyDecision.transitionReasons) && policyDecision.transitionReasons.length > 0 ? policyDecision.transitionReasons : Array.isArray(policyDecision.reasons) && policyDecision.reasons.length > 0 ? policyDecision.reasons : [];
  let primaryReasonCode = null;
  for (const reasonCode of reasonCodes) {
    if (typeof reasonCode === "string" && PR3_POLICY_REASON_MESSAGES[reasonCode]) {
      primaryReasonCode = reasonCode;
      break;
    }
  }
  if (primaryReasonCode) {
    const messageSet = PR3_POLICY_REASON_MESSAGES[primaryReasonCode];
    policyDecision.explain = {
      userMessage: messageSet.user,
      developerMessage: messageSet.dev,
      reasonCodes: reasonCodes.slice()
    };
  } else if (policyDecision.state === PR3_POLICY_STATE.WARN) {
    policyDecision.explain = {
      userMessage: "[Omni-Forge][PR3] Scope warning: policy transition candidate detected (soft-warning only).",
      developerMessage: "Policy state promoted to WARN without mapped reason code.",
      reasonCodes: reasonCodes.slice()
    };
  }
  return policyDecision;
}
function handlePR3ScopeEnforcementDecision(decision, runtimeContext) {
  if (PR3_SOFT_WARNING_ENABLED) {
    const snapshot = runtimeContext && typeof runtimeContext === "object" && runtimeContext.snapshot && typeof runtimeContext.snapshot === "object" ? runtimeContext.snapshot : null;
    const shadow = snapshot && snapshot.shadow && typeof snapshot.shadow === "object" ? snapshot.shadow : null;
    const contract = decision && typeof decision === "object" && decision.contract && typeof decision.contract === "object" ? decision.contract : null;
    const thresholds = contract && contract.thresholds && typeof contract.thresholds === "object" ? contract.thresholds : null;
    const outOfScopeCount = shadow && Number.isFinite(shadow.outOfScopeCount) ? shadow.outOfScopeCount : null;
    const maxOutOfScopeBeforeBlock = thresholds && Number.isFinite(thresholds.maxOutOfScopeBeforeBlock) ? thresholds.maxOutOfScopeBeforeBlock : null;
    if (typeof outOfScopeCount === "number" && typeof maxOutOfScopeBeforeBlock === "number" && outOfScopeCount > maxOutOfScopeBeforeBlock) {
      new import_obsidian4.Notice("[Omni-Forge][PR3] Scope warning: out-of-scope notes detected (soft-warning only).", 4e3);
    }
  }
  if (PR3_ENFORCEMENT_ENABLED) {
    const snapshot = runtimeContext && typeof runtimeContext === "object" && runtimeContext.snapshot && typeof runtimeContext.snapshot === "object" ? runtimeContext.snapshot : null;
    const policy = snapshot && snapshot.policy && typeof snapshot.policy === "object" ? snapshot.policy : null;
    const app = runtimeContext && typeof runtimeContext === "object" && runtimeContext.app ? runtimeContext.app : snapshot && snapshot.app ? snapshot.app : null;
    const modalOpenGuard = runtimeContext && typeof runtimeContext === "object" && runtimeContext.modalOpenGuard && typeof runtimeContext.modalOpenGuard === "object" ? runtimeContext.modalOpenGuard : null;
    const modalAlreadyOpened = modalOpenGuard && modalOpenGuard.opened === true;
    if (policy && policy.state === PR3_POLICY_STATE.WARN && app && !modalAlreadyOpened) {
      if (modalOpenGuard) {
        modalOpenGuard.opened = true;
      }
      new PR3ScopeWarningModal(app, policy).open();
    }
  }
  void decision;
  void runtimeContext;
}
function derivePR3DefaultDenyScopeFromSelection(selectedFilePaths, selectedFolderPaths, isPathExcluded) {
  const roots = [];
  const seen = /* @__PURE__ */ new Set();
  const isExcluded = typeof isPathExcluded === "function" ? isPathExcluded : () => false;
  let rootsTruncated = false;
  const addRoot = (rawPath) => {
    if (typeof rawPath !== "string" || rawPath.length === 0 || isExcluded(rawPath)) {
      return;
    }
    const normalized = (0, import_obsidian4.normalizePath)(rawPath);
    if (!normalized || normalized === "." || isExcluded(normalized) || seen.has(normalized)) {
      return;
    }
    if (roots.length >= PR3_FOLDER_RECLASS_MAX_SCOPE_ROOTS) {
      rootsTruncated = true;
      return;
    }
    seen.add(normalized);
    roots.push(normalized);
  };
  const safeFolderPaths = Array.isArray(selectedFolderPaths) ? selectedFolderPaths : [];
  for (const folderPath of safeFolderPaths) {
    addRoot(folderPath);
  }
  const safeFilePaths = Array.isArray(selectedFilePaths) ? selectedFilePaths : [];
  for (const filePath of safeFilePaths) {
    if (typeof filePath !== "string" || filePath.length === 0 || isExcluded(filePath)) {
      continue;
    }
    const normalizedFilePath = (0, import_obsidian4.normalizePath)(filePath);
    if (!normalizedFilePath || normalizedFilePath === ".") {
      continue;
    }
    const lastSlash = normalizedFilePath.lastIndexOf("/");
    if (lastSlash < 0) {
      continue;
    }
    addRoot(normalizedFilePath.slice(0, lastSlash));
  }
  return {
    scope: {
      mode: "default-deny",
      roots
    },
    rootsTruncated
  };
}
/**
 * @typedef {Object} FolderReclassScope
 * @property {"default-deny"} mode
 * @property {string[]} roots
 */
/**
 * @typedef {Object} ScopeValidationResult
 * @property {boolean} ok
 * @property {FolderReclassScope} scope
 * @property {string[]} warnings
 */
/**
 * Inert scaffold for PR3 Step 2 scope representation (not wired).
 * Step 2 scaffold only; path semantics fixed to vault-relative strict; enforcement still disabled without explicit approval; no UI wiring.
 * @typedef {Object} PR3Step2FolderReclassScope
 * @property {"default-deny"} policy
 * @property {"warn-only" | "enforce"} mode
 * @property {string[]} roots
 * @property {"VAULT_RELATIVE_STRICT"} pathSemantics
 * @property {boolean} enforceAck
 * @property {string} notes
 * @property {"ok" | "empty" | "ambiguous" | "invalid"} status
 * @property {string} message
 */
/**
 * @typedef {Object} PR3AllowedRootsResolution
 * @property {string[]} roots
 * @property {"ok" | "empty" | "ambiguous" | "invalid"} status
 * @property {string} message
 */
/**
 * Creates the inert default scope scaffold for PR3 Step 2.
 * This helper is intentionally not referenced by runtime flows yet.
 * @returns {PR3Step2FolderReclassScope}
 */
function createPR3Step2DefaultScope() {
  return {
    policy: "default-deny",
    mode: "warn-only",
    roots: [],
    pathSemantics: "VAULT_RELATIVE_STRICT",
    enforceAck: false,
    notes: "Path semantics: vault-relative strict. Enforcement remains disabled until explicitly approved.",
    status: "empty",
    message: "No allowed roots (default-deny)."
  };
}
/**
 * PR3 scope resolver single source of truth (settings -> resolved roots/status).
 * Empty, ambiguous, and invalid inputs all resolve to deny-all roots=[].
 * @param {any} settings
 * @returns {PR3AllowedRootsResolution}
 */
function resolveAllowedRootsFromSettings(settings) {
  const rawRoots = typeof (settings == null ? void 0 : settings.pr3ScopeRoots) === "string" ? settings.pr3ScopeRoots : "";
  const lines = rawRoots.split(/\r?\n/).map((line) => line.trim()).filter(Boolean);
  if (lines.length === 0) {
    return {
      roots: [],
      status: "empty",
      message: "No allowed roots (default-deny)."
    };
  }
  const normalizedRoots = [];
  const seen = /* @__PURE__ */ new Set();
  let hasAmbiguous = false;
  let hasInvalid = false;
  for (const line of lines) {
    if (/[;,]/.test(line)) {
      hasAmbiguous = true;
      break;
    }
    let normalized = line.replace(/\\/g, "/");
    normalized = normalized.replace(/\/+/g, "/");
    normalized = normalized.replace(/\/+$/, "");
    if (!normalized || normalized === "." || normalized === "/" || normalized.startsWith("/") || normalized.startsWith("~") || normalized.includes(":") || normalized.startsWith("./") || normalized.includes("/./")) {
      hasInvalid = true;
      break;
    }
    const segments = normalized.split("/");
    if (segments.some((segment) => segment === "..")) {
      hasInvalid = true;
      break;
    }
    if (seen.has(normalized)) {
      continue;
    }
    seen.add(normalized);
    normalizedRoots.push(normalized);
  }
  if (hasAmbiguous) {
    return {
      roots: [],
      status: "ambiguous",
      message: "Ambiguous roots detected. No allowed roots (default-deny)."
    };
  }
  if (hasInvalid) {
    return {
      roots: [],
      status: "invalid",
      message: "Invalid roots detected. No allowed roots (default-deny)."
    };
  }
  if (normalizedRoots.length === 0) {
    return {
      roots: [],
      status: "empty",
      message: "No allowed roots (default-deny)."
    };
  }
  normalizedRoots.sort((a, b) => a.localeCompare(b));
  const roots = normalizedRoots.slice(0, PR3_FOLDER_RECLASS_MAX_SCOPE_ROOTS);
  if (roots.length === 0) {
    return {
      roots: [],
      status: "empty",
      message: "No allowed roots (default-deny)."
    };
  }
  return {
    roots,
    status: "ok",
    message: "Allowed roots resolved."
  };
}
// Step 3.0 warn-only helper; not wired; no enforcement; no scope expansion; no vault scans.
function checkPR3ScopeGate(input) {
  const pathRaw = typeof (input == null ? void 0 : input.vaultRelativePath) === "string" ? input.vaultRelativePath : "";
  let normalizedPath = pathRaw.replace(/\\/g, "/");
  normalizedPath = normalizedPath.replace(/\/+/g, "/");
  normalizedPath = normalizedPath.replace(/\/+$/, "");
  if (!normalizedPath) {
    return {
      decision: "deny",
      reason: "PATH_INVALID_DEFAULT_DENY",
      wouldBlock: true,
      matchedRoot: null
    };
  }
  const scope = input && typeof input === "object" ? input.scope : void 0;
  const status = scope && (scope.status === "ok" || scope.status === "empty" || scope.status === "ambiguous" || scope.status === "invalid") ? scope.status : "invalid";
  if (status === "empty") {
    return {
      decision: "deny",
      reason: "SCOPE_EMPTY_DEFAULT_DENY",
      wouldBlock: true,
      matchedRoot: null
    };
  }
  if (status === "invalid") {
    return {
      decision: "deny",
      reason: "SCOPE_INVALID_DEFAULT_DENY",
      wouldBlock: true,
      matchedRoot: null
    };
  }
  if (status === "ambiguous") {
    return {
      decision: "indeterminate",
      reason: "SCOPE_AMBIGUOUS_INDETERMINATE",
      wouldBlock: true,
      matchedRoot: null
    };
  }
  const roots = Array.isArray(scope == null ? void 0 : scope.roots) ? scope.roots : [];
  for (const root of roots) {
    if (typeof root !== "string") {
      continue;
    }
    let normalizedRoot = root.replace(/\\/g, "/");
    normalizedRoot = normalizedRoot.replace(/\/+/g, "/");
    normalizedRoot = normalizedRoot.replace(/\/+$/, "");
    if (!normalizedRoot) {
      continue;
    }
    if (normalizedPath === normalizedRoot || normalizedPath.startsWith(`${normalizedRoot}/`)) {
      return {
        decision: "allow",
        reason: "SCOPE_OK_IN_ROOT",
        wouldBlock: false,
        matchedRoot: root
      };
    }
  }
  return {
    decision: "deny",
    reason: "SCOPE_OK_OUTSIDE_ROOT",
    wouldBlock: true,
    matchedRoot: null
  };
}
function normalizePathForScopeDiagnosticsV1(pathRaw) {
  const raw = typeof pathRaw === "string" ? pathRaw : "";
  let normalized = raw.replace(/\\/g, "/");
  normalized = normalized.replace(/\/+/g, "/");
  const absoluteLike = normalized.startsWith("/") || normalized.startsWith("~") || /^[A-Za-z]:\//.test(normalized);
  const segments = normalized.split("/");
  const out = [];
  let escaped = false;
  let hadDotSegments = false;
  for (const segment of segments) {
    if (!segment || segment === ".") {
      if (segment === ".") {
        hadDotSegments = true;
      }
      continue;
    }
    if (segment === "..") {
      hadDotSegments = true;
      if (out.length === 0) {
        escaped = true;
        continue;
      }
      out.pop();
      continue;
    }
    out.push(segment);
  }
  const value = out.join("/").replace(/\/+$/, "");
  return {
    value,
    absoluteLike,
    escaped,
    hadDotSegments
  };
}
// Diagnostics-only helper for finalized Step 2 path semantics; never changes enforcement decisions.
function diagnosePathAgainstRootsV1(pathRaw, rootsRaw) {
  const diagnostics = [];
  const pathInfo = normalizePathForScopeDiagnosticsV1(pathRaw);
  if (pathInfo.absoluteLike) {
    diagnostics.push("PATH_NOT_VAULT_RELATIVE");
  }
  if (pathInfo.hadDotSegments) {
    diagnostics.push("PATH_DOT_SEGMENTS_NORMALIZED");
  }
  if (pathInfo.escaped) {
    diagnostics.push("PATH_ESCAPES_ROOTS_OUT_OF_SCOPE");
  }
  if (!pathInfo.value) {
    diagnostics.push("PATH_EMPTY_AFTER_NORMALIZE");
  }
  const roots = Array.isArray(rootsRaw) ? rootsRaw : [];
  const normalizedRoots = [];
  for (const root of roots) {
    if (typeof root !== "string") {
      continue;
    }
    const rootInfo = normalizePathForScopeDiagnosticsV1(root);
    if (rootInfo.absoluteLike) {
      diagnostics.push("ROOT_NOT_VAULT_RELATIVE");
    }
    if (rootInfo.hadDotSegments) {
      diagnostics.push("ROOT_DOT_SEGMENTS_NORMALIZED");
    }
    if (rootInfo.escaped) {
      diagnostics.push("ROOT_ESCAPES_SCOPE");
    }
    if (!rootInfo.value) {
      continue;
    }
    normalizedRoots.push(rootInfo.value);
  }
  if (normalizedRoots.length === 0) {
    diagnostics.push("ROOTS_EMPTY_DEFAULT_DENY");
    return [...new Set(diagnostics)];
  }
  if (!pathInfo.value) {
    return [...new Set(diagnostics)];
  }
  let matched = false;
  let prefixOverreach = false;
  for (const root of normalizedRoots) {
    if (pathInfo.value === root || pathInfo.value.startsWith(`${root}/`)) {
      matched = true;
      break;
    }
    if (pathInfo.value.startsWith(root) && !pathInfo.value.startsWith(`${root}/`)) {
      prefixOverreach = true;
    }
  }
  if (prefixOverreach) {
    diagnostics.push("ROOT_PREFIX_OVERREACH_PREVENTED");
  }
  if (!matched) {
    diagnostics.push("PATH_OUT_OF_SCOPE_BY_ROOTS");
  }
  return [...new Set(diagnostics)];
}
// Brain Link Quality Engine scaffolding (pure functions only, not wired).
/**
 * @typedef {Object} NoteSnapshotV1
 * @property {string} path
 * @property {string} folderPath
 * @property {string} content
 * @property {string[]} [outboundLinks]
 * @property {string[]} [inboundLinks]
 * @property {string[]} [tags]
 */
/**
 * @typedef {Object} CandidateCollectionInputV1
 * @property {NoteSnapshotV1} target
 * @property {{folderIndex?: Object.<string, string[]>, recentIndex?: string[], tagIndex?: Object.<string, string[]>}} [indexes]
 * @property {{maxCandidates?: number, maxFolderNotes?: number, maxRecent?: number, maxTagMatches?: number}} [policy]
 */
/**
 * @typedef {Object} CandidateCollectionResultV1
 * @property {string[]} candidates
 * @property {{counts:{directLinks:number, sameFolder:number, recent:number, tagMatches:number, totalBeforeCap:number, totalReturned:number}, capped:boolean}} meta
 */
/**
 * @typedef {Object} LinkSuggestionV1
 * @property {string} path
 * @property {number} score
 * @property {string} [reasonCode]
 */
/**
 * @typedef {Object} MergeLinkedInputV1
 * @property {string[]} [existingLinked]
 * @property {LinkSuggestionV1[]} [suggestions]
 * @property {{maxLinked?: number, topN?: number, minScore?: number}} [policy]
 * @property {{pr3Status?: string, scopeDecision?: string}} [scopeContext]
 */
/**
 * @typedef {Object} MergeLinkedResultV1
 * @property {string[]} mergedLinked
 * @property {string[]} added
 * @property {{path:string, reason:string}[]} skipped
 * @property {boolean} changed
 * @property {{hasScopeContext:boolean, scopeDecision:any, scopeWouldBlock:boolean}} meta
 */
/**
 * @typedef {Object} NoteIndexSourceV1
 * @property {NoteSnapshotV1[]} notes explicitly scoped notes only
 * @property {string[]} [recentPaths] optional explicit ordering
 */
/**
 * @typedef {Object} PreviewPolicyV1
 * @property {number} [maxCandidates]
 * @property {number} [topN]
 * @property {number} [minScore]
 * @property {number} [tauDays]
 * @property {{avg:number, std:number, k?:number, t?:number}} [hub]
 */
/**
 * @typedef {Object} PreviewSuggestionV1
 * @property {string} path
 * @property {number} score
 * @property {number} confidence
 * @property {{semantic:number, tagOverlap:number, context:number, recency:number, structureRaw:number, hubFactor:number, structureAdjusted:number}} features
 * @property {string[]} reasons short reason codes like "DIRECT_LINK","SAME_FOLDER","TAG_OVERLAP","RECENT"
 */
/**
 * @typedef {Object} PreviewSuggestInputV1
 * @property {NoteSnapshotV1} target
 * @property {NoteIndexSourceV1} source
 * @property {PreviewPolicyV1} [policy]
 * @property {{pr3Status?: string, scopeDecision?: string}} [scopeContext]
 */
/**
 * @typedef {Object} PreviewSuggestResultV1
 * @property {PreviewSuggestionV1[]} suggestions
 * @property {{scope:{hasScopeContext:boolean, scopeDecision:any, scopeWouldBlock:boolean}, counts:any}} meta
 */
/**
 * @typedef {Object} FrontmatterPatchPlanV1
 * @property {string} path
 * @property {string[]} beforeLinked
 * @property {string[]} afterLinked
 * @property {string[]} added
 * @property {string[]} removed
 * @property {{path:string, reason:string}[]} skipped
 * @property {boolean} changed
 * @property {any} meta
 */
/**
 * @typedef {Object} UnifiedDiffProposalV1
 * @property {string} path
 * @property {string} diff
 * @property {boolean} changed
 * @property {any} meta
 */
/**
 * @typedef {Object} ProposeLinkedDiffInputV1
 * @property {NoteSnapshotV1} target target.content is required for unified diff line-range computation
 * @property {string[]} [existingLinked]
 * @property {{path:string, score:number, reasonCode?:string, confidence?:number, reasons?:string[]}[]} suggestions
 * @property {{maxLinked?: number, topN?: number, minScore?: number}} [policy]
 * @property {{pr3Status?: string, scopeDecision?: string}} [scopeContext]
 */
/**
 * @typedef {Object} ProposeLinkedDiffResultV1
 * @property {FrontmatterPatchPlanV1} plan
 * @property {UnifiedDiffProposalV1} proposal
 * @property {{scope:{hasScopeContext:boolean, scopeDecision:any, scopeWouldBlock:boolean}}} meta
 */
const BrainLinkQualityEngineV1 = (() => {
  function normalizeVaultPath(p) {
    if (typeof p !== "string") {
      return "";
    }
    let normalized = p.trim();
    normalized = normalized.replace(/\\/g, "/");
    normalized = normalized.replace(/\/+/g, "/");
    normalized = normalized.replace(/\/+$/, "");
    return normalized;
  }
  function uniqStable(arr) {
    if (!Array.isArray(arr)) {
      return [];
    }
    const seen = /* @__PURE__ */ new Set();
    const out = [];
    for (const item of arr) {
      if (typeof item !== "string") {
        continue;
      }
      const normalized = normalizeVaultPath(item);
      if (!normalized || seen.has(normalized)) {
        continue;
      }
      seen.add(normalized);
      out.push(normalized);
    }
    return out;
  }
  function computeHubAttenuationFactor(deg, avg, std, k = 1.2, t = 1) {
    if (!Number.isFinite(std) || std <= 0) {
      return 1;
    }
    const safeDeg = Number.isFinite(deg) ? deg : 0;
    const safeAvg = Number.isFinite(avg) ? avg : 0;
    const safeK = Number.isFinite(k) ? k : 1.2;
    const safeT = Number.isFinite(t) ? t : 1;
    const z = (safeDeg - safeAvg) / std;
    const haf = 1 / (1 + Math.exp(safeK * (z - safeT)));
    if (!Number.isFinite(haf)) {
      return 1;
    }
    return Math.max(0.05, Math.min(1, haf));
  }
  function normalizeNonNegativeInt(value, fallback) {
    const n = Number.isFinite(value) ? Math.floor(value) : fallback;
    return Math.max(0, n);
  }
  function clampUnit(value) {
    if (!Number.isFinite(value)) {
      return 0;
    }
    return Math.max(0, Math.min(1, value));
  }
  /**
   * @param {CandidateCollectionInputV1} input
   * @returns {CandidateCollectionResultV1}
   */
  function collectLinkCandidatesV1(input) {
    const payload = input && typeof input === "object" ? input : {};
    const target = payload && payload.target && typeof payload.target === "object" ? payload.target : {};
    const indexes = payload && payload.indexes && typeof payload.indexes === "object" ? payload.indexes : {};
    const policy = payload && payload.policy && typeof payload.policy === "object" ? payload.policy : {};
    const maxCandidates = normalizeNonNegativeInt(policy.maxCandidates, 100);
    const maxFolderNotes = normalizeNonNegativeInt(policy.maxFolderNotes, 50);
    const maxRecent = normalizeNonNegativeInt(policy.maxRecent, 30);
    const maxTagMatches = normalizeNonNegativeInt(policy.maxTagMatches, 20);
    const targetPath = normalizeVaultPath(target.path);
    const targetFolderRaw = typeof target.folderPath === "string" ? target.folderPath : "";
    const targetFolder = normalizeVaultPath(targetFolderRaw);
    const counts = {
      directLinks: 0,
      sameFolder: 0,
      recent: 0,
      tagMatches: 0,
      totalBeforeCap: 0,
      totalReturned: 0
    };
    const seen = /* @__PURE__ */ new Set();
    const ordered = [];
    const addCandidate = (rawPath, sourceKey) => {
      const normalized = normalizeVaultPath(rawPath);
      if (!normalized || normalized === targetPath || seen.has(normalized)) {
        return;
      }
      seen.add(normalized);
      ordered.push(normalized);
      counts[sourceKey] += 1;
    };
    const outboundLinks = Array.isArray(target.outboundLinks) ? target.outboundLinks : [];
    const inboundLinks = Array.isArray(target.inboundLinks) ? target.inboundLinks : [];
    for (const path of uniqStable([...outboundLinks, ...inboundLinks])) {
      addCandidate(path, "directLinks");
    }
    const folderIndex = indexes && typeof indexes.folderIndex === "object" ? indexes.folderIndex : {};
    const folderBucketRaw = Array.isArray(folderIndex[targetFolderRaw]) ? folderIndex[targetFolderRaw] : [];
    const folderBucketNormalized = targetFolderRaw !== targetFolder && Array.isArray(folderIndex[targetFolder]) ? folderIndex[targetFolder] : [];
    for (const path of uniqStable(folderBucketRaw.length > 0 ? folderBucketRaw : folderBucketNormalized).slice(0, maxFolderNotes)) {
      addCandidate(path, "sameFolder");
    }
    const recentIndex = Array.isArray(indexes.recentIndex) ? indexes.recentIndex : [];
    for (const path of uniqStable(recentIndex).slice(0, maxRecent)) {
      addCandidate(path, "recent");
    }
    const tagIndex = indexes && typeof indexes.tagIndex === "object" ? indexes.tagIndex : {};
    const targetTags = Array.isArray(target.tags) ? target.tags.filter((tag) => typeof tag === "string").map((tag) => tag.trim()).filter(Boolean) : [];
    const seenTags = /* @__PURE__ */ new Set();
    let tagAddedCount = 0;
    outer:
      for (const tag of targetTags) {
        if (seenTags.has(tag)) {
          continue;
        }
        seenTags.add(tag);
        const tagMatches = Array.isArray(tagIndex[tag]) ? tagIndex[tag] : [];
        for (const path of uniqStable(tagMatches)) {
          if (tagAddedCount >= maxTagMatches) {
            break outer;
          }
          const before = ordered.length;
          addCandidate(path, "tagMatches");
          if (ordered.length > before) {
            tagAddedCount += 1;
          }
        }
      }
    counts.totalBeforeCap = ordered.length;
    let capped = false;
    let candidates = ordered;
    if (candidates.length > maxCandidates) {
      candidates = candidates.slice(0, maxCandidates);
      capped = true;
    }
    counts.totalReturned = candidates.length;
    return {
      candidates,
      meta: {
        counts,
        capped
      }
    };
  }
  /**
   * @param {NoteIndexSourceV1} source
   * @returns {{folderIndex: Object.<string, string[]>, tagIndex: Object.<string, string[]>, noteByPath: Object.<string, NoteSnapshotV1>, recentIndex: string[]}}
   */
  function buildIndexesFromNotesV1(source) {
    const payload = source && typeof source === "object" ? source : {};
    const notes = Array.isArray(payload.notes) ? payload.notes : [];
    const folderIndex = {};
    const tagIndex = {};
    const noteByPath = {};
    for (const entry of notes) {
      if (!entry || typeof entry !== "object") {
        continue;
      }
      const normalizedPath = normalizeVaultPath(entry.path);
      if (!normalizedPath) {
        continue;
      }
      if (typeof noteByPath[normalizedPath] === "undefined") {
        noteByPath[normalizedPath] = entry;
      }
      const normalizedFolder = normalizeVaultPath(typeof entry.folderPath === "string" ? entry.folderPath : "");
      if (normalizedFolder) {
        const folderBucket = Array.isArray(folderIndex[normalizedFolder]) ? folderIndex[normalizedFolder] : [];
        if (folderBucket.length === 0 || folderBucket[folderBucket.length - 1] !== normalizedPath && folderBucket.includes(normalizedPath) === false) {
          folderBucket.push(normalizedPath);
        }
        folderIndex[normalizedFolder] = folderBucket;
      }
      const rawTags = Array.isArray(entry.tags) ? entry.tags : [];
      const seenTags = /* @__PURE__ */ new Set();
      for (const rawTag of rawTags) {
        if (typeof rawTag !== "string") {
          continue;
        }
        const tag = rawTag.trim();
        if (!tag || seenTags.has(tag)) {
          continue;
        }
        seenTags.add(tag);
        const tagBucket = Array.isArray(tagIndex[tag]) ? tagIndex[tag] : [];
        if (tagBucket.length === 0 || tagBucket[tagBucket.length - 1] !== normalizedPath && tagBucket.includes(normalizedPath) === false) {
          tagBucket.push(normalizedPath);
        }
        tagIndex[tag] = tagBucket;
      }
    }
    const recentIndex = uniqStable(Array.isArray(payload.recentPaths) ? payload.recentPaths : []);
    return {
      folderIndex,
      tagIndex,
      noteByPath,
      recentIndex
    };
  }
  /**
   * @param {PreviewSuggestInputV1} input
   * @returns {PreviewSuggestResultV1}
   */
  function suggestLinksPreviewV1(input) {
    const payload = input && typeof input === "object" ? input : {};
    const target = payload && payload.target && typeof payload.target === "object" ? payload.target : {};
    const source = payload && payload.source && typeof payload.source === "object" ? payload.source : {};
    const policy = payload && payload.policy && typeof payload.policy === "object" ? payload.policy : {};
    const scopeContext = payload && payload.scopeContext && typeof payload.scopeContext === "object" ? payload.scopeContext : null;
    const indexes = buildIndexesFromNotesV1(source);
    const maxCandidates = normalizeNonNegativeInt(policy.maxCandidates, 150);
    const topN = normalizeNonNegativeInt(policy.topN, 10);
    const minScore = Number.isFinite(policy.minScore) ? policy.minScore : 0.25;
    const tauDays = Number.isFinite(policy.tauDays) && policy.tauDays > 0 ? policy.tauDays : 90;
    const candidateCollection = collectLinkCandidatesV1({
      target,
      indexes,
      policy: {
        maxCandidates
      }
    });
    const candidatePaths = Array.isArray(candidateCollection.candidates) ? candidateCollection.candidates : [];
    const targetPath = normalizeVaultPath(target.path);
    const targetOutbound = uniqStable(Array.isArray(target.outboundLinks) ? target.outboundLinks : []);
    const targetInbound = uniqStable(Array.isArray(target.inboundLinks) ? target.inboundLinks : []);
    const targetDirectSet = /* @__PURE__ */ new Set([...targetOutbound, ...targetInbound]);
    const targetOutboundSet = /* @__PURE__ */ new Set(targetOutbound);
    const recentIndexMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < indexes.recentIndex.length; i += 1) {
      const path = normalizeVaultPath(indexes.recentIndex[i]);
      if (!path || recentIndexMap.has(path)) {
        continue;
      }
      recentIndexMap.set(path, i);
    }
    const ranked = [];
    const counts = {
      candidatesSeen: candidatePaths.length,
      candidatesScored: 0,
      missingSnapshots: 0,
      filteredBelowMinScore: 0,
      returned: 0,
      candidateCollection: {
        counts: candidateCollection && candidateCollection.meta && candidateCollection.meta.counts ? candidateCollection.meta.counts : {},
        capped: candidateCollection && candidateCollection.meta && candidateCollection.meta.capped === true
      }
    };
    const hubPolicy = policy && policy.hub && typeof policy.hub === "object" ? policy.hub : null;
    for (let i = 0; i < candidatePaths.length; i += 1) {
      const candidatePath = normalizeVaultPath(candidatePaths[i]);
      const candidate = candidatePath ? indexes.noteByPath[candidatePath] : null;
      if (!candidate || typeof candidate !== "object") {
        counts.missingSnapshots += 1;
        continue;
      }
      const candidateOutbound = uniqStable(Array.isArray(candidate.outboundLinks) ? candidate.outboundLinks : []);
      const candidateInbound = uniqStable(Array.isArray(candidate.inboundLinks) ? candidate.inboundLinks : []);
      const candidateOutboundSet = /* @__PURE__ */ new Set(candidateOutbound);
      const candidateInboundSet = /* @__PURE__ */ new Set(candidateInbound);
      const hasDirectLink = targetDirectSet.has(candidatePath);
      const hasMutualLink = !!targetPath && (candidateOutboundSet.has(targetPath) || candidateInboundSet.has(targetPath));
      let sharedOutCount = 0;
      for (const outbound of targetOutboundSet) {
        if (candidateOutboundSet.has(outbound)) {
          sharedOutCount += 1;
        }
      }
      const semantic = 0;
      const tagOverlap = computeTagOverlapScore(target.tags, candidate.tags);
      const context = computeContextScore(target.folderPath, candidate.folderPath);
      let recency = 0;
      if (recentIndexMap.has(candidatePath)) {
        const deltaDays = Number(recentIndexMap.get(candidatePath));
        recency = computeRecencyScore(deltaDays, tauDays);
      }
      const structureRaw = computeStructureRawScore({
        hasDirectLink,
        hasMutualLink,
        sharedOutCount
      });
      let hubFactor = 1;
      if (hubPolicy) {
        const degree = candidateOutbound.length + candidateInbound.length;
        hubFactor = computeHubAttenuationFactor(degree, hubPolicy.avg, hubPolicy.std, hubPolicy.k, hubPolicy.t);
      }
      const totalResult = computeTotalLinkScoreV1({
        semantic,
        tagOverlap,
        context,
        recency,
        structureRaw,
        hubFactor
      });
      const structureAdjusted = totalResult.structureAdjusted;
      const confidence = computeConfidenceV1({
        semantic,
        tagOverlap,
        structureAdjusted
      });
      const reasons = [];
      if (hasDirectLink) {
        reasons.push("DIRECT_LINK");
      }
      if (context >= 0.4) {
        reasons.push("SAME_FOLDER");
      } else if (context >= 0.2) {
        reasons.push("SIBLING_FOLDER");
      }
      if (tagOverlap > 0) {
        reasons.push("TAG_OVERLAP");
      }
      if (recency > 0) {
        reasons.push("RECENT");
      }
      if (hasMutualLink) {
        reasons.push("MUTUAL_LINK");
      }
      ranked.push({
        path: candidatePath,
        score: totalResult.total,
        confidence,
        features: {
          semantic,
          tagOverlap,
          context,
          recency,
          structureRaw,
          hubFactor,
          structureAdjusted
        },
        reasons,
        _index: i
      });
      counts.candidatesScored += 1;
    }
    const eligible = [];
    for (const entry of ranked) {
      if (entry.score < minScore) {
        counts.filteredBelowMinScore += 1;
        continue;
      }
      eligible.push(entry);
    }
    eligible.sort((a, b) => {
      const scoreDelta = b.score - a.score;
      if (scoreDelta !== 0) {
        return scoreDelta;
      }
      const confidenceDelta = b.confidence - a.confidence;
      if (confidenceDelta !== 0) {
        return confidenceDelta;
      }
      return a._index - b._index;
    });
    const suggestions = eligible.slice(0, topN).map((entry) => {
      const { _index, ...rest } = entry;
      return rest;
    });
    counts.returned = suggestions.length;
    const hasScopeContext = scopeContext !== null;
    const scopeDecision = hasScopeContext ? scopeContext.scopeDecision : void 0;
    const scopeWouldBlock = hasScopeContext && scopeDecision !== "allow";
    return {
      suggestions,
      meta: {
        scope: {
          hasScopeContext,
          scopeDecision,
          scopeWouldBlock
        },
        counts
      }
    };
  }
  function computeTagOverlapScore(aTags, bTags) {
    const aSet = /* @__PURE__ */ new Set(Array.isArray(aTags) ? aTags.filter((tag) => typeof tag === "string").map((tag) => tag.trim()).filter(Boolean) : []);
    const bSet = /* @__PURE__ */ new Set(Array.isArray(bTags) ? bTags.filter((tag) => typeof tag === "string").map((tag) => tag.trim()).filter(Boolean) : []);
    if (aSet.size === 0 && bSet.size === 0) {
      return 0;
    }
    let intersection = 0;
    for (const tag of aSet) {
      if (bSet.has(tag)) {
        intersection += 1;
      }
    }
    const union = aSet.size + bSet.size - intersection;
    if (union <= 0) {
      return 0;
    }
    return clampUnit(intersection / union);
  }
  function computeContextScore(aFolder, bFolder) {
    const folderA = normalizeVaultPath(typeof aFolder === "string" ? aFolder : "");
    const folderB = normalizeVaultPath(typeof bFolder === "string" ? bFolder : "");
    if (!folderA || !folderB) {
      return 0;
    }
    if (folderA === folderB) {
      return 0.4;
    }
    const parentA = folderA.includes("/") ? folderA.slice(0, folderA.lastIndexOf("/")) : "";
    const parentB = folderB.includes("/") ? folderB.slice(0, folderB.lastIndexOf("/")) : "";
    if (parentA === parentB) {
      return 0.2;
    }
    return 0;
  }
  function computeRecencyScore(deltaDays, tau = 90) {
    if (!Number.isFinite(deltaDays) || deltaDays < 0) {
      return 0;
    }
    const safeTau = Number.isFinite(tau) && tau > 0 ? tau : 90;
    return clampUnit(Math.exp(-deltaDays / safeTau));
  }
  function computeStructureRawScore(flags) {
    const safeFlags = flags && typeof flags === "object" ? flags : {};
    let base = 0;
    if (safeFlags.hasDirectLink === true) {
      base += 0.5;
    }
    if (safeFlags.hasMutualLink === true) {
      base += 0.7;
    }
    if (Number.isFinite(safeFlags.sharedOutCount) && safeFlags.sharedOutCount > 0) {
      base += 0.2;
    }
    return clampUnit(base);
  }
  function computeTotalLinkScoreV1(features) {
    const safeFeatures = features && typeof features === "object" ? features : {};
    const semantic = clampUnit(Number(safeFeatures.semantic));
    const tagOverlap = clampUnit(Number(safeFeatures.tagOverlap));
    const context = clampUnit(Number(safeFeatures.context));
    const recency = clampUnit(Number(safeFeatures.recency));
    const structureRaw = clampUnit(Number(safeFeatures.structureRaw));
    const hubFactor = Number.isFinite(safeFeatures.hubFactor) ? safeFeatures.hubFactor : 1;
    const structureAdjusted = clampUnit(structureRaw * hubFactor);
    const total = clampUnit(
      0.4 * semantic + 0.2 * tagOverlap + 0.2 * context + 0.1 * recency + 0.1 * structureAdjusted
    );
    return { total, structureAdjusted };
  }
  function sigmoid(x) {
    if (x === Infinity) {
      return 1;
    }
    if (x === -Infinity) {
      return 0;
    }
    if (!Number.isFinite(x)) {
      return 0.5;
    }
    return clampUnit(1 / (1 + Math.exp(-x)));
  }
  function computeConfidenceV1(features) {
    const safeFeatures = features && typeof features === "object" ? features : {};
    const semantic = clampUnit(Number(safeFeatures.semantic));
    const tagOverlap = clampUnit(Number(safeFeatures.tagOverlap));
    const structureAdjusted = clampUnit(Number(safeFeatures.structureAdjusted));
    return clampUnit(sigmoid(2 * semantic + 1.2 * tagOverlap + 0.8 * structureAdjusted));
  }
  /**
   * @param {MergeLinkedInputV1} input
   * @returns {MergeLinkedResultV1}
   */
  function mergeLinkedFrontmatterV1(input) {
    const payload = input && typeof input === "object" ? input : {};
    const existingLinked = Array.isArray(payload.existingLinked) ? payload.existingLinked : [];
    const suggestions = Array.isArray(payload.suggestions) ? payload.suggestions : [];
    const policy = payload && payload.policy && typeof payload.policy === "object" ? payload.policy : {};
    const scopeContext = payload && payload.scopeContext && typeof payload.scopeContext === "object" ? payload.scopeContext : null;
    const maxLinked = normalizeNonNegativeInt(policy.maxLinked, 10);
    const topN = normalizeNonNegativeInt(policy.topN, 5);
    const minScore = Number.isFinite(policy.minScore) ? policy.minScore : 0.25;
    const existing = [];
    for (const item of existingLinked) {
      if (typeof item !== "string") {
        continue;
      }
      const normalized = normalizeVaultPath(item);
      if (!normalized) {
        continue;
      }
      existing.push(normalized);
    }
    const existingSet = /* @__PURE__ */ new Set(existing);
    const ranked = suggestions.map((item, index) => ({
      item: item && typeof item === "object" ? item : {},
      index
    })).sort((a, b) => {
      const aScore = Number.isFinite(a.item.score) ? a.item.score : -Infinity;
      const bScore = Number.isFinite(b.item.score) ? b.item.score : -Infinity;
      if (bScore !== aScore) {
        return bScore - aScore;
      }
      return a.index - b.index;
    }).slice(0, topN);
    const hasScopeContext = scopeContext !== null;
    const scopeDecision = hasScopeContext ? scopeContext.scopeDecision : void 0;
    const scopeWouldBlock = hasScopeContext && scopeDecision !== "allow";
    const appended = [];
    const appendedSet = /* @__PURE__ */ new Set();
    const skipped = [];
    for (const entry of ranked) {
      const rawPath = typeof entry.item.path === "string" ? entry.item.path : "";
      const normalizedPath = normalizeVaultPath(rawPath);
      if (!normalizedPath) {
        skipped.push({ path: typeof rawPath === "string" ? rawPath.trim() : "", reason: "INVALID_PATH" });
        continue;
      }
      const score = Number.isFinite(entry.item.score) ? entry.item.score : -Infinity;
      if (score < minScore) {
        skipped.push({ path: normalizedPath, reason: "BELOW_THRESHOLD" });
        continue;
      }
      if (existingSet.has(normalizedPath) || appendedSet.has(normalizedPath)) {
        skipped.push({ path: normalizedPath, reason: "DUPLICATE" });
        continue;
      }
      appended.push(normalizedPath);
      appendedSet.add(normalizedPath);
    }
    const remainingSlots = Math.max(0, maxLinked - existing.length);
    const added = appended.slice(0, remainingSlots);
    if (appended.length > remainingSlots) {
      for (const path of appended.slice(remainingSlots)) {
        skipped.push({ path, reason: "OVERFLOW_MAX" });
      }
    }
    const mergedLinked = [...existing, ...added];
    let changed = mergedLinked.length !== existing.length;
    if (!changed) {
      for (let i = 0; i < existing.length; i += 1) {
        if (existing[i] !== mergedLinked[i]) {
          changed = true;
          break;
        }
      }
    }
    return {
      mergedLinked,
      added,
      skipped,
      changed,
      meta: {
        hasScopeContext,
        scopeDecision,
        scopeWouldBlock
      }
    };
  }
  function escapeYamlScalarV1(s) {
    const raw = typeof s === "string" ? s : "";
    const needsQuote = raw.includes(":") || raw.includes("#") || raw.includes("\n") || raw.includes("\"") || raw.trim() !== raw;
    if (!needsQuote) {
      return raw;
    }
    const escaped = raw.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    return `"${escaped}"`;
  }
  function buildLinkedYamlBlockV1(linkedArr) {
    const safeLinked = Array.isArray(linkedArr) ? linkedArr : [];
    if (safeLinked.length === 0) {
      return "linked: []\n";
    }
    let block = "linked:\n";
    for (const item of safeLinked) {
      const value = escapeYamlScalarV1(typeof item === "string" ? item : "");
      block += `  - ${value}\n`;
    }
    return block;
  }
  function parseLinkedFrontmatterRangeV1(content) {
    const source = typeof content === "string" ? content : "";
    // Accept optional UTF-8 BOM so frontmatter detection is stable for vault text variants.
    const normalizedSource = source.charCodeAt(0) === 65279 ? source.slice(1) : source;
    let sourceForParsing = normalizedSource;
    // Parsing-only normalization: if file ends with delimiter at EOF, keep delimiter discoverable.
    if (/(?:^|\r?\n)---[ \t]*$/.test(sourceForParsing) && !/\r?\n$/.test(sourceForParsing)) {
      sourceForParsing += "\n";
    }
    // Frontmatter delimiter lines allow trailing spaces/tabs.
    const isDelimiterLine = (line) => /^---[ \t]*$/.test(line);
    const isTopLevelLinkedKeyLine = (line) => /^linked\s*:/.test(line);
    const isTopLevelKeyLine = (line) => /^[A-Za-z0-9_-]+\s*:/.test(line);
    if (!/^---[ \t]*\r?\n/.test(sourceForParsing)) {
      return null;
    }
    const lines = sourceForParsing.split(/\r?\n/);
    if (lines.length === 0 || !isDelimiterLine(lines[0])) {
      return null;
    }
    let frontmatterEnd = -1;
    // Includes EOF line, so a closing delimiter at the last line is recognized.
    for (let i = 1; i < lines.length; i += 1) {
      if (isDelimiterLine(lines[i])) {
        frontmatterEnd = i;
        break;
      }
    }
    if (frontmatterEnd < 0) {
      return null;
    }
    let linkedStart = -1;
    for (let i = 1; i < frontmatterEnd; i += 1) {
      if (isTopLevelLinkedKeyLine(lines[i])) {
        linkedStart = i;
        break;
      }
    }
    if (linkedStart < 0) {
      return {
        linkedStart: -1,
        linkedEnd: -1,
        lines
      };
    }
    const linkedLine = lines[linkedStart];
    let linkedEnd = frontmatterEnd;
    if (/^linked\s*:\s*\[\s*\]\s*(?:#.*)?$/.test(linkedLine)) {
      linkedEnd = linkedStart + 1;
    } else {
      linkedEnd = linkedStart + 1;
      while (linkedEnd < frontmatterEnd) {
        if (isTopLevelKeyLine(lines[linkedEnd])) {
          break;
        }
        linkedEnd += 1;
      }
    }
    return {
      linkedStart,
      linkedEnd,
      lines
    };
  }
  function splitYamlBlockLinesV1(block) {
    const source = typeof block === "string" ? block : "";
    if (!source) {
      return [];
    }
    const withoutTrailingNewline = source.endsWith("\n") ? source.slice(0, -1) : source;
    if (withoutTrailingNewline === "") {
      return [];
    }
    return withoutTrailingNewline.split("\n");
  }
  /**
   * @param {{ path:string, existingLinked:string[], suggestions:any[], policy:any, scopeContext:any }} input
   * @returns {FrontmatterPatchPlanV1}
   */
  function computeFrontmatterLinkedPatchPlanV1(input) {
    const payload = input && typeof input === "object" ? input : {};
    const path = normalizeVaultPath(payload.path);
    const beforeLinked = Array.isArray(payload.existingLinked) ? payload.existingLinked.filter((item) => typeof item === "string").map((item) => normalizeVaultPath(item)).filter(Boolean) : [];
    const suggestions = Array.isArray(payload.suggestions) ? payload.suggestions : [];
    const mergeResult = mergeLinkedFrontmatterV1({
      existingLinked: beforeLinked,
      suggestions,
      policy: payload.policy,
      scopeContext: payload.scopeContext
    });
    const afterLinked = Array.isArray(mergeResult.mergedLinked) ? mergeResult.mergedLinked : [];
    const afterSet = /* @__PURE__ */ new Set(afterLinked);
    const removed = [];
    for (const existingPath of beforeLinked) {
      if (!afterSet.has(existingPath)) {
        removed.push(existingPath);
      }
    }
    return {
      path,
      beforeLinked,
      afterLinked,
      added: Array.isArray(mergeResult.added) ? mergeResult.added : [],
      removed,
      skipped: Array.isArray(mergeResult.skipped) ? mergeResult.skipped : [],
      changed: mergeResult.changed === true,
      meta: mergeResult.meta
    };
  }
  /**
   * @param {FrontmatterPatchPlanV1} plan
   * @returns {UnifiedDiffProposalV1}
   */
  function proposeUnifiedDiffForLinkedFrontmatterV1(plan, targetContent) {
    const safePlan = plan && typeof plan === "object" ? plan : {
      path: "",
      beforeLinked: [],
      afterLinked: [],
      changed: false,
      meta: null
    };
    const path = normalizeVaultPath(safePlan.path);
    const changed = safePlan.changed === true;
    if (!changed) {
      return {
        path,
        diff: "",
        changed: false,
        meta: safePlan.meta
      };
    }
    // Line-range math must come from the provided NoteSnapshotV1.content snapshot.
    const parsed = parseLinkedFrontmatterRangeV1(targetContent);
    if (!parsed || parsed.linkedStart < 0 || parsed.linkedEnd < parsed.linkedStart) {
      return {
        path,
        diff: "",
        changed: false,
        meta: safePlan.meta
      };
    }
    const oldLines = parsed.lines.slice(parsed.linkedStart, parsed.linkedEnd);
    const afterBlock = buildLinkedYamlBlockV1(Array.isArray(safePlan.afterLinked) ? safePlan.afterLinked : []);
    const afterLines = splitYamlBlockLinesV1(afterBlock);
    if (oldLines.length === afterLines.length && oldLines.every((line, index) => line === afterLines[index])) {
      return {
        path,
        diff: "",
        changed: false,
        meta: safePlan.meta
      };
    }
    const oldStart = parsed.linkedStart + 1;
    const oldCount = oldLines.length;
    const newStart = oldStart;
    const newCount = afterLines.length;
    const hunkHeader = `@@ -${oldStart},${oldCount} +${newStart},${newCount} @@`;
    // Non-throwing regression guard: keep standard unified-diff hunk header shape.
    if (!/^@@ -\d+,\d+ \+\d+,\d+ @@$/.test(hunkHeader)) {
      if (typeof console !== "undefined" && typeof console.warn === "function") {
        console.warn("[Omni-Forge] linked unified diff guard tripped", hunkHeader);
      }
      return {
        path,
        diff: "",
        changed: false,
        meta: safePlan.meta
      };
    }
    const diffLines = [
      `diff --git a/${path} b/${path}`,
      `--- a/${path}`,
      `+++ b/${path}`,
      hunkHeader
    ];
    for (const line of oldLines) {
      diffLines.push(`-${line}`);
    }
    for (const line of afterLines) {
      diffLines.push(`+${line}`);
    }
    const diff = `${diffLines.join("\n")}\n`;
    return {
      path,
      diff,
      changed: true,
      meta: safePlan.meta
    };
  }
  /**
   * @param {ProposeLinkedDiffInputV1} input
   * @returns {ProposeLinkedDiffResultV1}
   */
  function proposeLinkedFrontmatterUnifiedDiffV1(input) {
    const payload = input && typeof input === "object" ? input : {};
    const target = payload && payload.target && typeof payload.target === "object" ? payload.target : {};
    const targetPath = normalizeVaultPath(target.path);
    const existingLinkedRaw = Array.isArray(payload.existingLinked) ? payload.existingLinked : [];
    const existingLinked = [];
    for (const item of existingLinkedRaw) {
      if (typeof item !== "string") {
        continue;
      }
      const normalized = normalizeVaultPath(item);
      if (!normalized) {
        continue;
      }
      existingLinked.push(normalized);
    }
    const suggestionsRaw = Array.isArray(payload.suggestions) ? payload.suggestions : [];
    const suggestions = [];
    for (const entry of suggestionsRaw) {
      if (!entry || typeof entry !== "object") {
        continue;
      }
      const normalizedPath = normalizeVaultPath(entry.path);
      if (!normalizedPath) {
        continue;
      }
      const normalizedSuggestion = {
        path: normalizedPath,
        score: entry.score
      };
      if (typeof entry.reasonCode === "string") {
        normalizedSuggestion.reasonCode = entry.reasonCode;
      }
      if (Number.isFinite(entry.confidence)) {
        normalizedSuggestion.confidence = entry.confidence;
      }
      if (Array.isArray(entry.reasons)) {
        normalizedSuggestion.reasons = entry.reasons.filter((reason) => typeof reason === "string");
      }
      suggestions.push(normalizedSuggestion);
    }
    const scopeContext = payload && payload.scopeContext && typeof payload.scopeContext === "object" ? payload.scopeContext : null;
    const plan = computeFrontmatterLinkedPatchPlanV1({
      path: targetPath,
      existingLinked,
      suggestions,
      policy: payload.policy,
      scopeContext
    });
    const proposal = proposeUnifiedDiffForLinkedFrontmatterV1(plan, target.content);
    const hasScopeContext = scopeContext !== null;
    const scopeDecision = hasScopeContext ? scopeContext.scopeDecision : void 0;
    const scopeWouldBlock = hasScopeContext && scopeDecision !== "allow";
    return {
      plan,
      proposal,
      meta: {
        scope: {
          hasScopeContext,
          scopeDecision,
          scopeWouldBlock
        }
      }
    };
  }
  return {
    normalizeVaultPath,
    uniqStable,
    computeHubAttenuationFactor,
    normalizeNonNegativeInt,
    clampUnit,
    collectLinkCandidatesV1,
    buildIndexesFromNotesV1,
    suggestLinksPreviewV1,
    computeTagOverlapScore,
    computeContextScore,
    computeRecencyScore,
    computeStructureRawScore,
    computeTotalLinkScoreV1,
    sigmoid,
    computeConfidenceV1,
    mergeLinkedFrontmatterV1,
    proposeLinkedFrontmatterUnifiedDiffV1
  };
})();
// DEBUG/diagnostic fingerprint only; never treat as audit proof, policy input, or enforcement key.
// For ambiguous/invalid/empty scope states, the fingerprint must not be interpreted as safe or allowed scope.
function computePR3ScopeFingerprint(scope) {
  const status = scope && (scope.status === "ok" || scope.status === "empty" || scope.status === "ambiguous" || scope.status === "invalid") ? scope.status : "invalid";
  const pathSemantics = scope && scope.pathSemantics === "VAULT_RELATIVE_STRICT" ? scope.pathSemantics : "VAULT_RELATIVE_STRICT";
  const roots = Array.isArray(scope == null ? void 0 : scope.roots) ? scope.roots.filter((root) => typeof root === "string") : [];
  const stableRoots = [...roots].sort((a, b) => a.localeCompare(b));
  const serialized = `v1|${status}|${pathSemantics}|${stableRoots.join(";")}`;
  let hash = 2166136261;
  for (let i = 0; i < serialized.length; i += 1) {
    hash ^= serialized.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }
  return (hash >>> 0).toString(16).padStart(8, "0");
}
/*
 * PR3 Step 2 policy guardrails (documentation-only):
 * - Step 2 is warn-only and MUST NOT enforce or expand scope automatically.
 * - Default-deny remains the rule; empty/invalid/ambiguous states never grant access.
 * - "ambiguous" means policy is not deterministically resolved; it is non-decisive, not an error.
 */
/**
 * Pure PR3 Step 2 scaffold constructor from settings (NOT wired).
 * Reads explicit control fields and display-only scope roots from settings.
 * @param {any} settings
 * @returns {PR3Step2FolderReclassScope}
 */
function createPR3Step2ScopeFromSettings(settings) {
  const base = createPR3Step2DefaultScope();
  const mode = settings && settings.pr3ScopeMode === "enforce" ? "enforce" : "warn-only";
  const enforceAck = settings && settings.pr3ScopeEnforceAck === true;
  const resolved = resolveAllowedRootsFromSettings(settings);
  return {
    ...base,
    mode,
    enforceAck,
    roots: resolved.roots,
    status: resolved.status,
    message: resolved.message
  };
}
/**
 * PR3 Step 3 Path Semantics (Decision)
 *
 * - Scope roots are vault-relative folder paths only; absolute paths are out of policy.
 * - Normalization rule: "\" -> "/", collapse repeated "//", trim trailing "/".
 * - Invalid input candidates: "", ".", "/", and any path with ".." segments.
 * - Encoded/variant traversal forms are also intended to be treated as invalid in enforcement steps.
 * - Deny-all is represented only by roots: [] (empty roots); no special sentinel strings.
 * - Symlink handling is string-path only; no realpath resolution.
 * - Case handling does not force lowercasing; compare using Obsidian-provided path strings.
 * - Inclusion rule: root === path OR path.startsWith(root + "/").
 * - Roots represent folders by policy, not files.
 */
/**
 * PR3 Step 4 Validator Scaffold - NOT wired. Enforcement phase will integrate.
 * Pure string inspection only.
 * No normalization and no input mutation.
 * No filesystem or vault API access.
 * Integration deferred until enforcement phase.
 * @param {string} root
 * @returns {{ ok: boolean, reason?: string }}
 */
function validatePR3Step3RootCandidate(root) {
  if (typeof root !== "string") {
    return { ok: false, reason: "Root must be a string." };
  }
  if (root.length === 0) {
    return { ok: false, reason: "Root must not be empty." };
  }
  if (root === "." || root === "/") {
    return { ok: false, reason: "Root token is not allowed." };
  }
  if (root.startsWith("/")) {
    return { ok: false, reason: "Absolute path is not allowed." };
  }
  if (root.includes("\\")) {
    return { ok: false, reason: "Backslash path separator is not allowed." };
  }
  const segments = root.split("/");
  for (const segment of segments) {
    if (segment === "..") {
      return { ok: false, reason: "Traversal segment is not allowed." };
    }
  }
  return { ok: true };
}
/**
 * PR3 Step 6A Warn-only wrapper (NOT wired).
 * Produces additional PR3 validation warnings for scope roots candidates.
 * Does not filter/normalize/modify roots; does not call vault APIs.
 * @param {unknown} roots
 * @returns {string[]}
 */
function collectPR3Step3RootWarnings(roots) {
  const warnings = [];
  const candidates = Array.isArray(roots) ? roots : [];
  for (const root of candidates) {
    if (typeof root !== "string") {
      continue;
    }
    const result = validatePR3Step3RootCandidate(root);
    if (!result.ok) {
      const reason = typeof result.reason === "string" && result.reason ? result.reason : "Invalid root.";
      warnings.push(`PR3 root candidate rejected: ${reason}`);
    }
  }
  return warnings;
}
/**
 * PR3 Step 8C-1 mode decision helper (NOT wired).
 * Pure decision from raw config-like inputs; fail-closed on activation.
 * @param {unknown} modeRaw
 * @param {unknown} ackRaw
 * @returns {"warn-only" | "enforce"}
 */
function decidePR3ScopeEnforcementMode(modeRaw, ackRaw) {
  if (modeRaw !== "enforce") {
    return "warn-only";
  }
  return ackRaw === true ? "enforce" : "warn-only";
}
/**
 * Internal shadow gate; not wired into existing call paths.
 * placeholder until settings wiring is defined.
 * @param {any} settings
 * @returns {{modeRaw: any, ackRaw: any}}
 */
function getPR3ScopeEnforcementControlsFromSettings(settings) {
  void settings;
  return { modeRaw: void 0, ackRaw: void 0 };
}
let __pr3ShadowLastScopeEnforcement = void 0;
let __pr3ShadowLastScopeEnforcementMode = void 0;
/**
 * Internal shadow execution helper (compute-only, no effect).
 * @param {any} normalizedRoots
 * @param {any} settings
 * @returns {void}
 */
function shadowComputePR3ScopeEnforcementFromSettings(normalizedRoots, settings) {
  try {
    const { modeRaw, ackRaw } = getPR3ScopeEnforcementControlsFromSettings(settings);
    if (modeRaw === undefined && ackRaw === undefined) {
      return;
    }
    const mode = decidePR3ScopeEnforcementMode(modeRaw, ackRaw);
    const enforcement = computePR3ScopeEnforcementResult(normalizedRoots, mode);
    __pr3ShadowLastScopeEnforcementMode = mode;
    __pr3ShadowLastScopeEnforcement = enforcement;
  } catch (error) {
    void error;
  }
}
/**
 * PR3 Step 8C-2 enforcement result computation helper (NOT wired).
 * Pure computation from normalizedRoots only.
 * @param {string[]} normalizedRoots
 * @param {"warn-only" | "enforce"} mode
 * @returns {{
 *   mode: "warn-only" | "enforce",
 *   enforced: boolean,
 *   effectiveRoots: string[],
 *   rejectedRoots: string[],
 *   reasonCodes: string[]
 * }}
 */
function computePR3ScopeEnforcementResult(normalizedRoots, mode) {
  const safeMode = mode === "enforce" ? "enforce" : "warn-only";
  const safeRoots = Array.isArray(normalizedRoots) ? normalizedRoots.filter((root) => typeof root === "string") : [];
  if (safeMode !== "enforce") {
    return {
      mode: safeMode,
      enforced: false,
      effectiveRoots: [...safeRoots],
      rejectedRoots: [],
      reasonCodes: []
    };
  }
  const rejectedRoots = [];
  for (const root of safeRoots) {
    const result = validatePR3Step3RootCandidate(root);
    if (!result.ok) {
      rejectedRoots.push(root);
    }
  }
  if (rejectedRoots.length > 0) {
    return {
      mode: safeMode,
      enforced: true,
      effectiveRoots: [],
      rejectedRoots,
      reasonCodes: ["INVALID_ROOT_PRESENT"]
    };
  }
  return {
    mode: safeMode,
    enforced: false,
    effectiveRoots: [...safeRoots],
    rejectedRoots: [],
    reasonCodes: []
  };
}
/**
 * PR3 Step 8D-1 wrapper (NOT wired): returns enforcement-enhanced result shape.
 * Pure composition only; does not change existing normalize behavior.
 * @param {unknown} roots
 * @param {"warn-only" | "enforce"} mode
 * @returns {{
 *   roots: string[],
 *   warnings: string[],
 *   enforcement: {
 *     mode: "warn-only" | "enforce",
 *     enforced: boolean,
 *     effectiveRoots: string[],
 *     rejectedRoots: string[],
 *     reasonCodes: string[]
 *   }
 * }}
 */
function normalizeScopeRootsInternalWithEnforcement(roots, mode) {
  const { roots: normalizedRoots, warnings } = normalizeScopeRootsInternal(roots);
  const enforcement = computePR3ScopeEnforcementResult(normalizedRoots, mode);
  return { roots: normalizedRoots, warnings, enforcement };
}
/**
 * PR3 Step 7B Enforcement Result Scaffold (documentation only, NOT wired).
 * Future optional extension only; runtime returns remain exactly { roots, warnings } in this step.
 * enforcement?: {
 *   mode: "warn-only" | "enforce";
 *   enforced: boolean;
 *   effectiveRoots: string[];
 *   rejectedRoots: string[];
 *   reasonCodes: string[];
 * }
 */
function normalizeScopeRootsInternal(roots) {
  const normalizedRoots = [];
  const warnings = [];
  const seen = /* @__PURE__ */ new Set();
  if (!Array.isArray(roots)) {
    if (roots != null) {
      warnings.push("Scope roots must be an array; using empty roots.");
    }
    const pr3Warnings = collectPR3Step3RootWarnings(normalizedRoots);
    warnings.push(...pr3Warnings);
    return { roots: normalizedRoots, warnings };
  }
  for (const item of roots) {
    if (typeof item !== "string") {
      warnings.push("Dropped non-string scope root.");
      continue;
    }
    const original = item;
    let normalized = item.trim();
    if (!normalized) {
      warnings.push("Dropped empty scope root.");
      continue;
    }
    normalized = normalized.replace(/\\/g, "/");
    normalized = normalized.replace(/\/+/g, "/");
    normalized = normalized.replace(/^(\.\/)+/, "");
    if (/^[A-Za-z]:\//.test(normalized) || normalized.startsWith("/")) {
      warnings.push(`Scope root appears absolute (semantics undecided): ${original}`);
    }
    if (normalized === "." || normalized === ".." || normalized.startsWith("../") || normalized.includes("/../") || normalized.endsWith("/..")) {
      warnings.push(`Scope root contains traversal segments (semantics undecided): ${original}`);
    }
    normalized = normalized.replace(/\/+$/, "");
    if (!normalized) {
      warnings.push("Dropped empty scope root after normalization.");
      continue;
    }
    if (seen.has(normalized)) {
      warnings.push(`Dropped duplicate scope root: ${normalized}`);
      continue;
    }
    seen.add(normalized);
    normalizedRoots.push(normalized);
    if (normalizedRoots.length >= PR3_FOLDER_RECLASS_MAX_SCOPE_ROOTS) {
      if (roots.length > normalizedRoots.length) {
        warnings.push(`Scope root cap reached (${PR3_FOLDER_RECLASS_MAX_SCOPE_ROOTS}). Extra roots were dropped.`);
      }
      break;
    }
  }
  const pr3Warnings = collectPR3Step3RootWarnings(normalizedRoots);
  warnings.push(...pr3Warnings);
  return { roots: normalizedRoots, warnings };
}
function normalizeScopeRootsWithMode(roots, modeRaw, ackRaw) {
  const mode = decidePR3ScopeEnforcementMode(modeRaw, ackRaw);
  return normalizeScopeRootsInternalWithEnforcement(roots, mode);
}
function normalizeScopeRoots(roots) {
  return normalizeScopeRootsInternal(roots).roots;
}
/**
 * @param {unknown} candidate
 * @returns {ScopeValidationResult}
 */
function validateFolderReclassScope(candidate) {
  const fallbackScope = { mode: "default-deny", roots: [] };
  const warnings = [];
  if (!candidate || typeof candidate !== "object") {
    warnings.push("Invalid scope candidate; using default-deny empty roots.");
    return { ok: false, scope: fallbackScope, warnings };
  }
  if (candidate.mode !== "default-deny") {
    warnings.push("Unsupported scope mode; using default-deny empty roots.");
    return { ok: false, scope: fallbackScope, warnings };
  }
  if (!PR3_FOLDER_RECLASS_DEFAULT_DENY) {
    warnings.push("Default-deny policy is required for PR3 scope handling.");
    return { ok: false, scope: fallbackScope, warnings };
  }
  const normalized = normalizeScopeRootsInternal(candidate.roots);
  warnings.push(...normalized.warnings);
  // DECISION: whether empty roots is ok in default-deny; leaving ok:false for now since not wired.
  if (normalized.roots.length === 0) {
    warnings.push("No valid scope roots; using default-deny empty roots.");
    return { ok: false, scope: fallbackScope, warnings };
  }
  return {
    ok: true,
    scope: {
      mode: "default-deny",
      roots: normalized.roots
    },
    warnings
  };
}
/*
Future wiring (PR3 Step 2+):
- Scope roots must come from explicit UI selection or explicit configuration.
- Vault-wide scan is forbidden; default-deny remains the baseline policy.
- Path semantics for scope roots (vault-relative vs absolute; traversal handling) are DECISION REQUIRED before wiring.
- Apply remains preview-only NO-OP until a later step.
- Evidence cap remains centralized in normalizeFolderReclassEvidenceLines.
*/
function deriveFolderReclassCurrentFolder(filePath) {
  const normalized = typeof filePath === "string" ? filePath.trim() : "";
  if (!normalized) {
    return "(none)";
  }
  const lastSlash = normalized.lastIndexOf("/");
  if (lastSlash < 0) {
    return "(root)";
  }
  const folder = normalized.slice(0, lastSlash).trim();
  return folder || "(root)";
}
function normalizeFolderReclassConfidence(value, needsReview) {
  const review = needsReview === true;
  if (value === "high" || value === "medium" || value === "low") {
    return value;
  }
  return review ? "low" : "high";
}
function normalizeFolderReclassReasonSummary(value, evidence) {
  if (typeof value === "string" && value.trim()) {
    return value.trim();
  }
  if (Array.isArray(evidence)) {
    for (const line of evidence) {
      if (typeof line === "string" && line.trim()) {
        return line.trim();
      }
    }
  }
  return "Rule-based folder recommendation.";
}
function normalizeFolderReclassApplyMode(value) {
  if (value === "metadata_only" || value === "move_only" || value === "metadata_and_move") {
    return value;
  }
  return DEFAULT_SETTINGS.applyMode;
}
function normalizeFolderReclassMoveConflictPolicy(value) {
  if (value === "suffix" || value === "skip") {
    return value;
  }
  return DEFAULT_SETTINGS.moveConflictPolicy;
}
function normalizeFolderReclassSuggestedFolder(value) {
  if (typeof value !== "string") {
    return "Inbox";
  }
  const normalized = value.trim();
  return normalized || "Inbox";
}
function normalizeFolderReclassCurrentFolder(value, filePath) {
  if (typeof value === "string") {
    const normalized = value.trim();
    if (normalized) {
      return normalized;
    }
  }
  return deriveFolderReclassCurrentFolder(filePath);
}
function normalizeFolderReclassEvidenceLines(value, maxLines) {
  const DEFAULT_EVIDENCE_MAX_LINES = 3;
  if (!Array.isArray(value)) {
    return [];
  }
  // Single source of truth for evidence cap (<=3); call sites must not cap evidence.
  // maxLines is treated as a request and normalized to safe integer range [0..3].
  const requestedLimit = typeof maxLines === "number" ? maxLines : DEFAULT_EVIDENCE_MAX_LINES;
  const finiteRequestedLimit = Number.isFinite(requestedLimit) ? requestedLimit : DEFAULT_EVIDENCE_MAX_LINES;
  const clampedLimit = Math.max(0, Math.min(DEFAULT_EVIDENCE_MAX_LINES, Math.floor(finiteRequestedLimit)));
  if (clampedLimit <= 0) {
    return [];
  }
  const lines = [];
  for (const line of value) {
    if (typeof line !== "string") {
      continue;
    }
    const normalized = line.trim();
    if (!normalized) {
      continue;
    }
    lines.push(normalized);
    if (lines.length >= clampedLimit) {
      break;
    }
  }
  return lines;
}
function normalizeFolderReclassCandidate(candidate) {
  if (!candidate || typeof candidate.filePath !== "string") {
    return null;
  }
  const filePath = candidate.filePath.trim();
  if (!filePath) {
    return null;
  }
  const name = typeof candidate.name === "string" ? candidate.name.trim() : "";
  return { filePath, name };
}
function computeFolderReclassSignal(candidate) {
  const filePath = candidate && typeof candidate.filePath === "string" ? candidate.filePath : "";
  const name = candidate && typeof candidate.name === "string" ? candidate.name : "";
  return `${filePath.toLowerCase()} ${name.toLowerCase()}`.trim();
}
function matchFolderReclassRule(signal) {
  if (/(meeting|agenda|minutes)/.test(signal)) {
    return "meetings";
  }
  if (/(draft|wip|tmp|scratch)/.test(signal)) {
    return "drafts";
  }
  if (/(project|roadmap|plan)/.test(signal)) {
    return "projects";
  }
  return "inbox";
}
function buildFolderReclassEvidence(rule) {
  if (rule === "meetings") {
    return [
      'Keyword match: "meeting/agenda/minutes".',
      'Rule confidence is high for "Meetings".'
    ];
  }
  if (rule === "drafts") {
    return [
      'Keyword match: "draft/wip/tmp/scratch".',
      'Draft-like notes often need manual confirmation.'
    ];
  }
  if (rule === "projects") {
    return [
      'Keyword match: "project/roadmap/plan".',
      'Rule confidence is moderate-to-high for "Projects".'
    ];
  }
  return [
    'No strong keyword matched; fallback to "Inbox".',
    "Confidence is limited without additional context.",
    "Manual review recommended before apply."
  ];
}
function buildFolderReclassReasonSummary(rule) {
  if (rule === "meetings") {
    return 'Matched meeting intent keywords and preferred "Meetings".';
  }
  if (rule === "drafts") {
    return 'Matched draft/work-in-progress keywords and routed to "Drafts".';
  }
  if (rule === "projects") {
    return 'Matched project planning keywords and routed to "Projects".';
  }
  return 'No dominant keyword matched; fallback recommendation is "Inbox".';
}
function buildFolderReclassSuggestion(candidate, rule) {
  let suggestedFolder = "Inbox";
  let score = 55;
  let needsReview = true;
  let confidence = "low";
  if (rule === "meetings") {
    suggestedFolder = "Meetings";
    score = 92;
    needsReview = false;
    confidence = "high";
  } else if (rule === "drafts") {
    suggestedFolder = "Drafts";
    score = 76;
    needsReview = true;
    confidence = "medium";
  } else if (rule === "projects") {
    suggestedFolder = "Projects";
    score = 86;
    needsReview = false;
    confidence = "high";
  }
  const evidence = normalizeFolderReclassEvidenceLines(buildFolderReclassEvidence(rule));
  return {
    filePath: candidate.filePath,
    currentFolder: normalizeFolderReclassCurrentFolder(void 0, candidate.filePath),
    suggestedFolder: normalizeFolderReclassSuggestedFolder(suggestedFolder),
    score,
    needsReview,
    reasonSummary: normalizeFolderReclassReasonSummary(
      buildFolderReclassReasonSummary(rule),
      evidence
    ),
    confidence: normalizeFolderReclassConfidence(confidence, needsReview),
    evidence
  };
}
function recommendFolderReclass(candidates, ctx) {
  void ctx;
  const safeCandidates = Array.isArray(candidates) ? candidates : [];
  const suggestions = [];
  for (const item of safeCandidates) {
    const candidate = normalizeFolderReclassCandidate(item);
    if (!candidate) {
      continue;
    }
    const signal = computeFolderReclassSignal(candidate);
    const rule = matchFolderReclassRule(signal);
    suggestions.push(buildFolderReclassSuggestion(candidate, rule));
  }
  return suggestions;
}
function compareFolderReclassRows(a, b) {
  if (a.needsReview !== b.needsReview) {
    return a.needsReview ? 1 : -1;
  }
  if (a.score !== b.score) {
    return b.score - a.score;
  }
  return a.filePath.localeCompare(b.filePath);
}
function isBetterFolderReclassSuggestion(candidate, current) {
  if (candidate.needsReview !== current.needsReview) {
    return current.needsReview;
  }
  if (candidate.score !== current.score) {
    return candidate.score > current.score;
  }
  const suggestedFolderCmp = candidate.suggestedFolder.localeCompare(current.suggestedFolder);
  if (suggestedFolderCmp !== 0) {
    return suggestedFolderCmp < 0;
  }
  return candidate.filePath.localeCompare(current.filePath) < 0;
}
function createFolderReclassModel(suggestions) {
  const byFile = /* @__PURE__ */ new Map();
  const safeSuggestions = Array.isArray(suggestions) ? suggestions : [];
  for (const item of safeSuggestions) {
    if (!item || typeof item.filePath !== "string") {
      continue;
    }
    const filePath = item.filePath.trim();
    if (!filePath) {
      continue;
    }
    const needsReview = item.needsReview === true || item.reviewNeeded === true || item.verifyRequired === true;
    const evidenceRaw = Array.isArray(item.evidence) ? item.evidence : Array.isArray(item.reasonEvidence) ? item.reasonEvidence : Array.isArray(item.evidenceLines) ? item.evidenceLines : [];
    const row = {
      filePath,
      currentFolder: normalizeFolderReclassCurrentFolder(item.currentFolder, filePath),
      suggestedFolder: normalizeFolderReclassSuggestedFolder(
        typeof item.suggestedFolder === "string" && item.suggestedFolder.trim() ? item.suggestedFolder : item.targetFolder
      ),
      score: Number.isFinite(item.score) ? Math.max(0, Math.min(100, Math.round(Number(item.score)))) : 0,
      needsReview,
      reasonSummary: normalizeFolderReclassReasonSummary(
        typeof item.reasonSummary === "string" && item.reasonSummary.trim() ? item.reasonSummary : typeof item.reason === "string" && item.reason.trim() ? item.reason : item.recommendationReason,
        evidenceRaw
      ),
      confidence: normalizeFolderReclassConfidence(
        typeof item.confidence === "string" && item.confidence.trim() ? item.confidence : typeof item.confidenceLabel === "string" && item.confidenceLabel.trim() ? item.confidenceLabel : item.confidenceLevel,
        needsReview
      ),
      evidence: normalizeFolderReclassEvidenceLines(evidenceRaw)
    };
    const current = byFile.get(filePath);
    if (!current || isBetterFolderReclassSuggestion(row, current)) {
      byFile.set(filePath, row);
    }
  }
  const rows = [...byFile.values()];
  rows.sort((a, b) => compareFolderReclassRows(a, b));
  return { byFile, rows };
}
var PatchPreviewModal = class _PatchPreviewModal extends import_obsidian4.Modal {
  constructor(app, model, onResolve) {
    super(app);
    this.resolved = false;
    this.searchValue = "";
    this.selectedHunkId = "__all__";
    this.model = model;
    this.onResolve = onResolve;
    this.handleKeydown = (event) => {
      if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === "f") {
        event.preventDefault();
        this.focusSearchInput();
        return;
      }
      if (event.key === "Escape") {
        event.preventDefault();
        this.resolve({ decision: "cancel" });
        return;
      }
      if (event.key === "Enter" && !event.shiftKey && !event.altKey && !event.ctrlKey && !event.metaKey) {
        event.preventDefault();
        this.requestApply();
      }
    };
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.addClass("omni-forge-patch-preview-modal");
    const root = contentEl.createDiv({ cls: "omni-forge-patch-preview-root" });
    const header = root.createDiv({ cls: "omni-forge-patch-preview-header" });
    const titleRow = header.createDiv({ cls: "omni-forge-patch-preview-title-row" });
    titleRow.createEl("h2", { text: this.model.title });
    const toolRow = titleRow.createDiv({ cls: "omni-forge-patch-preview-tools" });
    this.searchInputEl = toolRow.createEl("input", {
      type: "text",
      placeholder: "Hunk 검색..."
    });
    this.searchInputEl.addClass("omni-forge-patch-preview-search");
    this.searchInputEl.oninput = () => {
      this.searchValue = this.searchInputEl.value.trim().toLowerCase();
      this.renderHunkList();
      this.renderDiffViewer();
    };
    const scopeEl = header.createDiv({
      cls: "omni-forge-patch-preview-meta",
      text: this.model.scopeText
    });
    scopeEl.setAttr("title", this.model.scopeText);
    header.createDiv({
      cls: "omni-forge-patch-preview-meta",
      text: this.model.strategyText
    });
    const summary = header.createDiv({ cls: "omni-forge-patch-preview-summary-bar" });
    this.appendSummaryChip(summary, "+", String(this.model.summary.added), "plus");
    this.appendSummaryChip(summary, "-", String(this.model.summary.removed), "minus");
    this.appendSummaryChip(summary, "hunks", String(this.model.summary.hunks), "hunks");
    this.appendSummaryChip(summary, "risk", this.model.riskLevel.toUpperCase(), `risk-${this.model.riskLevel}`);
    for (const badge of this.model.summary.badges) {
      const badgeEl = summary.createDiv({
        cls: "omni-forge-patch-preview-chip is-badge",
        text: badge
      });
      if (/fuzzy/i.test(badge)) {
        badgeEl.addClass("is-warning");
      }
      if (/failed/i.test(badge)) {
        badgeEl.addClass("is-danger");
      }
    }
    const dryRunSummary = this.model.dryRunSummary && typeof this.model.dryRunSummary === "object" ? this.model.dryRunSummary : null;
    const guardResult = this.model.guardResult && typeof this.model.guardResult === "object" ? this.model.guardResult : null;
    if (dryRunSummary || guardResult) {
      const checks = header.createDiv({ cls: "omni-forge-patch-preview-checks" });
      if (dryRunSummary) {
        const dryRunLine = checks.createDiv({
          cls: `omni-forge-patch-preview-check ${dryRunSummary.ok ? "is-pass" : "is-fail"}`
        });
        const dryRunMode = dryRunSummary.mode || "none";
        const dryRunChanged = Number.isFinite(dryRunSummary.changedLines) ? dryRunSummary.changedLines : 0;
        dryRunLine.setText(`Dry-run: ${dryRunSummary.ok ? "PASS" : "FAIL"} | mode=${dryRunMode} | changed=${dryRunChanged}`);
        if (!dryRunSummary.ok && dryRunSummary.error) {
          dryRunLine.setAttr("title", dryRunSummary.error);
        }
      }
      if (guardResult) {
        const guardLine = checks.createDiv({
          cls: `omni-forge-patch-preview-check ${guardResult.ok ? "is-pass" : "is-fail"}`
        });
        guardLine.setText(`FrontmatterGuard: ${guardResult.ok ? "PASS" : "FAIL"}`);
        if (!guardResult.ok && guardResult.error) {
          guardLine.setAttr("title", guardResult.error);
        }
      }
    }
    if (!this.model.canApply && this.model.blockReason) {
      const blocked = header.createDiv({
        cls: "omni-forge-patch-preview-warning is-blocked"
      });
      blocked.createEl("strong", { text: "PR-0 적용 차단" });
      blocked.createEl("div", { text: this.model.blockReason });
    }
    if (this.model.riskLevel !== "low") {
      const warning = header.createDiv({
        cls: "omni-forge-patch-preview-warning"
      });
      warning.createEl("strong", {
        text: this.model.warningTitle
      });
      warning.createEl("div", {
        text: this.model.warningDetail
      });
      if (this.model.requireExtraConfirm) {
        this.confirmRowEl = warning.createDiv({
          cls: "omni-forge-patch-preview-confirm-row"
        });
        this.confirmCheckboxEl = this.confirmRowEl.createEl("input", { type: "checkbox" });
        this.confirmCheckboxEl.onchange = () => {
          this.updateApplyButtonState();
        };
        this.confirmRowEl.createEl("span", {
          text: "위험도를 이해했고 그대로 적용합니다."
        });
      }
    }
    const layout = root.createDiv({ cls: "omni-forge-patch-preview-layout" });
    this.hunkListEl = layout.createDiv({ cls: "omni-forge-patch-preview-hunk-list" });
    this.diffViewerEl = layout.createDiv({ cls: "omni-forge-patch-preview-diff-viewer" });
    const footer = root.createDiv({ cls: "omni-forge-patch-preview-footer" });
    const cancelButton = footer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => this.resolve({ decision: "cancel" });
    this.applyButtonEl = footer.createEl("button", {
      text: "Apply / 적용",
      cls: "mod-cta"
    });
    this.applyButtonEl.onclick = () => this.requestApply();
    this.renderHunkList();
    this.renderDiffViewer();
    this.updateApplyButtonState();
    this.modalEl.addEventListener("keydown", this.handleKeydown);
    this.focusSearchInput();
  }
  appendSummaryChip(parent, label, value, variant = "") {
    const chip = parent.createDiv({
      cls: "omni-forge-patch-preview-chip"
    });
    if (variant) {
      chip.addClass(`is-${variant}`);
    }
    chip.createSpan({
      cls: "omni-forge-patch-preview-chip-label",
      text: label
    });
    chip.createSpan({
      cls: "omni-forge-patch-preview-chip-value",
      text: value
    });
  }
  getFilteredHunks() {
    const query = this.searchValue;
    if (!query) {
      return this.model.hunks;
    }
    return this.model.hunks.filter((hunk) => {
      return hunk.searchText.includes(query);
    });
  }
  renderHunkList() {
    this.hunkListEl.empty();
    const listHeader = this.hunkListEl.createDiv({
      cls: "omni-forge-patch-preview-list-head",
      text: "Hunks"
    });
    listHeader.setAttr("title", "Ctrl/Cmd+F: 검색");
    const filtered = this.getFilteredHunks();
    const allButton = this.hunkListEl.createEl("button", {
      text: `All hunks (${filtered.length})`,
      cls: "omni-forge-patch-preview-hunk-item"
    });
    if (this.selectedHunkId === "__all__") {
      allButton.addClass("is-active");
    }
    allButton.onclick = () => {
      this.selectedHunkId = "__all__";
      this.renderHunkList();
      this.renderDiffViewer();
    };
    if (filtered.length === 0) {
      this.hunkListEl.createDiv({
        cls: "omni-forge-patch-preview-empty",
        text: "검색 결과 없음"
      });
      return;
    }
    for (const hunk of filtered) {
      const button = this.hunkListEl.createEl("button", {
        cls: "omni-forge-patch-preview-hunk-item"
      });
      if (this.selectedHunkId === hunk.id) {
        button.addClass("is-active");
      }
      button.createDiv({
        cls: "omni-forge-patch-preview-hunk-label",
        text: hunk.label
      });
      button.createDiv({
        cls: "omni-forge-patch-preview-hunk-stats",
        text: `+${hunk.added} / -${hunk.removed} / ctx ${hunk.context}`
      });
      button.onclick = () => {
        this.selectedHunkId = hunk.id;
        this.renderHunkList();
        this.renderDiffViewer();
      };
    }
  }
  renderDiffViewer() {
    this.diffViewerEl.empty();
    const filtered = this.getFilteredHunks();
    let target = [];
    if (this.selectedHunkId === "__all__") {
      target = filtered;
    } else {
      const found = this.model.hunks.find((hunk) => hunk.id === this.selectedHunkId);
      target = found ? [found] : filtered;
    }
    if (target.length === 0) {
      this.diffViewerEl.createDiv({
        cls: "omni-forge-patch-preview-empty",
        text: "표시할 diff가 없습니다."
      });
      return;
    }
    for (const hunk of target) {
      const block = this.diffViewerEl.createDiv({ cls: "omni-forge-patch-preview-hunk-block" });
      block.createDiv({
        cls: "omni-forge-patch-preview-hunk-header",
        text: hunk.header
      });
      const pre = block.createEl("pre", { cls: "omni-forge-patch-preview-pre" });
      const code = pre.createEl("code", { cls: "omni-forge-patch-preview-code" });
      for (let lineIndex = 0; lineIndex < hunk.lines.length; lineIndex += 1) {
        const line = hunk.lines[lineIndex];
        const lineEl = code.createSpan({
          cls: "omni-forge-patch-preview-code-line",
          text: `${line.prefix}${line.text.length > 0 ? line.text : " "}`
        });
        if (line.prefix === "+") {
          lineEl.addClass("is-add");
        } else if (line.prefix === "-") {
          lineEl.addClass("is-del");
        } else {
          lineEl.addClass("is-ctx");
        }
        if (lineIndex < hunk.lines.length - 1) {
          code.appendChild(document.createTextNode("\n"));
        }
      }
    }
  }
  requestApply() {
    if (!this.model.canApply) {
      new import_obsidian4.Notice(this.model.blockReason || "PR-0 보안 가드에 의해 적용이 차단되었습니다.", 4e3);
      return;
    }
    if (this.model.requireExtraConfirm && (!this.confirmCheckboxEl || !this.confirmCheckboxEl.checked)) {
      new import_obsidian4.Notice("위험 변경은 확인 체크 후 적용할 수 있습니다.", 3500);
      return;
    }
    this.resolve({ decision: "apply" });
  }
  updateApplyButtonState() {
    if (!this.applyButtonEl) {
      return;
    }
    if (!this.model.canApply) {
      this.applyButtonEl.disabled = true;
      return;
    }
    if (!this.model.requireExtraConfirm) {
      this.applyButtonEl.disabled = false;
      return;
    }
    this.applyButtonEl.disabled = !(this.confirmCheckboxEl && this.confirmCheckboxEl.checked);
  }
  focusSearchInput() {
    if (!this.searchInputEl) {
      return;
    }
    this.searchInputEl.focus();
    this.searchInputEl.setSelectionRange(0, this.searchInputEl.value.length);
  }
  resolve(decision) {
    if (this.resolved) {
      return;
    }
    this.resolved = true;
    this.onResolve(decision);
    this.close();
  }
  onClose() {
    this.modalEl.removeEventListener("keydown", this.handleKeydown);
    this.modalEl.removeClass("omni-forge-patch-preview-modal");
    if (!this.resolved) {
      this.resolved = true;
      this.onResolve({ decision: "cancel" });
    }
    this.contentEl.empty();
  }
  static ask(app, model) {
    return new Promise((resolve2) => {
      new _PatchPreviewModal(app, model, resolve2).open();
    });
  }
};
var VaultTextInputModal = class extends import_obsidian4.Modal {
  constructor(app, titleText, placeholder, initialValue, submitText, onSubmitValue) {
    super(app);
    this.titleText = titleText;
    this.placeholder = placeholder;
    this.initialValue = initialValue;
    this.submitText = submitText;
    this.onSubmitValue = onSubmitValue;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h3", { text: this.titleText });
    this.inputEl = contentEl.createEl("input", { type: "text" });
    this.inputEl.style.width = "100%";
    this.inputEl.placeholder = this.placeholder;
    this.inputEl.value = this.initialValue;
    this.inputEl.focus();
    this.inputEl.setSelectionRange(0, this.inputEl.value.length);
    const footer = contentEl.createDiv();
    footer.style.display = "flex";
    footer.style.justifyContent = "flex-end";
    footer.style.gap = "8px";
    footer.style.marginTop = "10px";
    const cancelButton = footer.createEl("button", { text: "Cancel / \uCDE8\uC18C" });
    cancelButton.onclick = () => this.close();
    this.submitButton = footer.createEl("button", {
      text: this.submitText,
      cls: "mod-cta"
    });
    this.submitButton.onclick = async () => {
      await this.commit();
    };
    this.inputEl.addEventListener("keydown", async (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        await this.commit();
      }
      if (event.key === "Escape") {
        event.preventDefault();
        this.close();
      }
    });
  }
  async commit() {
    const value = this.inputEl.value.trim();
    if (!value) {
      new import_obsidian4.Notice("\uAC12\uC774 \uBE44\uC5B4 \uC788\uC2B5\uB2C8\uB2E4. / Value is empty.", 4e3);
      return;
    }
    this.submitButton.disabled = true;
    try {
      await this.onSubmitValue(value);
      this.close();
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown input error";
      new import_obsidian4.Notice(message, 7e3);
      this.submitButton.disabled = false;
      this.inputEl.focus();
    }
  }
};
var HwpIngestChoiceModal = class extends import_obsidian4.Modal {
  constructor(app, fileName, remainingCount, resolveChoice) {
    super(app);
    this.fileName = fileName;
    this.remainingCount = remainingCount;
    this.resolveChoice = resolveChoice;
    this.applyAll = false;
    this.resolved = false;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText("HWP 업로드 처리 방식 선택");
    contentEl.empty();
    contentEl.createEl("p", {
      text: `HWP는 soffice 감지 시 자동 변환(PoC)을 시도하며 실패 시 가이드로 폴백합니다. HWPX는 XML 1차 추출을 우선 시도합니다: ${this.fileName}`
    });
    contentEl.createEl("p", {
      text: "원하는 진행 방식을 선택하세요."
    });
    if (this.remainingCount > 0) {
      new import_obsidian4.Setting(contentEl).setName(`남은 HWP ${this.remainingCount}개에도 동일 적용`).addToggle((toggle) => {
        toggle.setValue(false).onChange((value) => {
          this.applyAll = value;
        });
      });
    }
    new import_obsidian4.Setting(contentEl).addButton((button) => button.setButtonText("A. PDF까지만 변환(권장)").setCta().onClick(() => {
      this.finish("pdf_only");
    }));
    new import_obsidian4.Setting(contentEl).addButton((button) => button.setButtonText("B. PDF 변환 후 MD까지 진행").onClick(() => {
      this.finish("pdf_to_md");
    }));
    new import_obsidian4.Setting(contentEl).addButton((button) => button.setButtonText("C. 취소").onClick(() => {
      this.finish("cancel");
    }));
  }
  onClose() {
    if (!this.resolved) {
      this.finish("cancel");
    }
  }
  finish(choice) {
    if (this.resolved) {
      return;
    }
    this.resolved = true;
    this.resolveChoice({ choice, applyAll: this.applyAll });
    this.close();
  }
  static open(app, fileName, remainingCount = 0) {
    return new Promise((resolve2) => {
      new HwpIngestChoiceModal(app, fileName, remainingCount, resolve2).open();
    });
  }
};
var LocalQAWorkspaceView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.headerTitleEl = null;
    this.roleSelect = null;
    this.pipelineSelect = null;
    this.conversationModeSelect = null;
    this.chatModelFamilySelect = null;
    this.chatModelProfileSelect = null;
    this.pendingAttachments = [];
    this.qaContextButton = null;
    this.running = false;
    this.stopRequested = false;
    this.activeRequestController = null;
    this.messages = [];
    this.threadPath = null;
    this.threadId = "";
    this.threadCreatedAt = "";
    this.syncStatus = "Not synced yet";
    this.syncTimer = null;
    this.syncInFlight = false;
    this.syncQueued = false;
    this.queuedTurns = [];
    this.pendingPreemptTurn = null;
    this.queueDrainInProgress = false;
    this.renderVersion = 0;
    this.streamRenderTimer = null;
    this.fileOpenEventBound = false;
    this.lastKnownOpenMarkdownPath = null;
    this.commandAvailabilityCache = /* @__PURE__ */ new Map();
    this.parserStatusPanelEl = null;
    this.hwpChoiceApplyAll = null;
    this.hwpChoiceApplyAllEnabled = false;
    this.plugin = plugin;
  }
  getViewType() {
    return LOCAL_QA_VIEW_TYPE;
  }
  getDisplayText() {
    return "Omni Forge Local Chat / \uB85C\uCEEC \uCC44\uD305";
  }
  getIcon() {
    return "message-square";
  }
  async onOpen() {
    this.resetThreadState();
    this.render();
    if (!this.fileOpenEventBound) {
      this.registerEvent(
        this.app.workspace.on("file-open", (file) => {
          if (file instanceof import_obsidian4.TFile && file.extension === "md") {
            this.lastKnownOpenMarkdownPath = file.path;
          } else {
            this.lastKnownOpenMarkdownPath = null;
          }
          void this.refreshActiveFileStatus();
          void this.refreshScopeLabel();
        })
      );
      this.registerEvent(
        this.app.workspace.on("active-leaf-change", () => {
          void this.refreshActiveFileStatus();
          void this.refreshScopeLabel();
        })
      );
      this.fileOpenEventBound = true;
    }
    const initialOpen = this.resolveVisibleMarkdownFile();
    if (initialOpen instanceof import_obsidian4.TFile) {
      this.lastKnownOpenMarkdownPath = initialOpen.path;
    }
    await this.refreshFromSettingsForQa();
    this.refreshThreadMeta();
  }
  async onClose() {
    this.requestImmediateStop();
    if (this.syncTimer !== null) {
      window.clearTimeout(this.syncTimer);
      this.syncTimer = null;
    }
    if (this.streamRenderTimer !== null) {
      window.clearTimeout(this.streamRenderTimer);
      this.streamRenderTimer = null;
    }
    if (this.plugin.isQaThreadAutoSyncEnabledForQa() || this.threadPath) {
      await this.flushThreadSync(true);
    }
  }
  resetThreadState() {
    const now = /* @__PURE__ */ new Date();
    this.threadId = `chat-${formatBackupStamp(now)}`;
    this.threadCreatedAt = now.toISOString();
    this.threadPath = null;
    this.syncStatus = this.plugin.isQaThreadAutoSyncEnabledForQa() ? "Auto-sync ready / \uC790\uB3D9 \uB3D9\uAE30\uD654 \uC900\uBE44" : "Manual save mode / \uC218\uB3D9 \uC800\uC7A5 \uBAA8\uB4DC";
    this.refreshThreadMeta();
  }
  requestImmediateStop(reason) {
    this.stopRequested = true;
    if (this.streamRenderTimer !== null) {
      window.clearTimeout(this.streamRenderTimer);
      this.streamRenderTimer = null;
    }
    if (this.stopButton) {
      this.stopButton.disabled = true;
    }
    this.refreshSendButtonState();
    if (!this.activeRequestController) {
      return;
    }
    const controller = this.activeRequestController;
    this.activeRequestController = null;
    try {
      controller.abort();
    } catch (e) {
    }
    if (reason && this.running) {
      this.pushMessage({
        role: "system",
        text: `\uC911\uC9C0 \uC694\uCCAD\uB428: ${reason}`,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
  }
  refreshThreadMeta() {
    if (!this.threadInfoEl || !this.syncInfoEl) {
      return;
    }
    const threadLabel = this.threadPath ? this.threadPath : `${this.threadId}.md (pending)`;
    this.threadInfoEl.setText(`Thread / \uC2A4\uB808\uB4DC: ${threadLabel}`);
    this.syncInfoEl.setText(`Sync / \uB3D9\uAE30\uD654: ${this.syncStatus}`);
  }
  setSyncStatus(next) {
    this.syncStatus = next;
    this.refreshThreadMeta();
  }
  createHeaderIconButton(parent, icon, tooltip, onClick, cta = false) {
    const button = parent.createEl("button");
    button.addClass("omni-forge-chat-btn");
    button.addClass("omni-forge-chat-icon-btn");
    if (cta) {
      button.addClass("mod-cta");
    }
    button.setAttr("aria-label", tooltip);
    button.setAttr("title", tooltip);
    (0, import_obsidian4.setIcon)(button, icon);
    button.onclick = () => {
      void onClick();
    };
    return button;
  }
  getChatUiLanguageMode() {
    const mode = this.plugin.settings.settingsUiLanguage;
    return mode === "en" || mode === "bilingual" ? mode : "ko";
  }
  localizeChatLabel(en, ko) {
    const mode = this.getChatUiLanguageMode();
    if (mode === "en") {
      return en;
    }
    if (mode === "bilingual") {
      return `${en} / ${ko}`;
    }
    return ko;
  }
  buildLocalizedChatProfileLabel(profile) {
    switch (profile) {
      case "local-pro":
        return this.localizeChatLabel("Local Pro", "로컬 Pro");
      case "codex":
        return this.plugin.settings.openAIModel.trim() ? `Codex (${this.plugin.settings.openAIModel.trim()})` : "Codex";
      case "claude":
        return this.plugin.settings.anthropicModel.trim() ? `Claude (${this.plugin.settings.anthropicModel.trim()})` : "Claude";
      case "gemini":
        return this.plugin.settings.geminiModel.trim() ? `Gemini (${this.plugin.settings.geminiModel.trim()})` : "Gemini";
      case "local-flash":
      default:
        if (profile && profile !== "local-flash") {
          return profile;
        }
        return this.localizeChatLabel("Local Flash", "로컬 Flash");
    }
  }
  refreshParserStatusPanel() {
    if (!this.parserStatusPanelEl) {
      return;
    }
    const last = this.plugin.getParserInboxLastEventForQa();
    const status = this.plugin.getParserInboxStatusForQa();
    const watchOn = this.plugin.settings.qaParserInboxWatchEnabled ? "ON" : "OFF";
    const parserProfile = this.plugin.getParserModeProfileForQa();
    const total = Math.max(0, status.total || 0);
    const processed = Math.max(0, status.processed || 0);
    const progressPct = total > 0 ? Math.min(100, Math.round(processed / total * 100)) : 0;
    const elapsedLabel = this.plugin.formatParserEtaMsForQa(status.elapsedMs || 0);
    const etaLabel = this.plugin.formatParserEtaMsForQa(status.etaMs || 0);
    const stageMap = {
      idle: "대기중",
      scanning: "스캔중",
      queueing: "대기열 등록 중",
      converting: "변환중",
      writing: "결과 저장 중",
      skip: "스킵",
      processing: "처리중",
      done: "완료"
    };
    const stageLabel = stageMap[status.stage] || status.stage || "대기중";
    const messageText = typeof last.message === "string" ? last.message : "";
    const diagMatch = /^\[([^\]]+)\]/.exec(messageText);
    this.parserStatusPanelEl.empty();
    this.parserStatusPanelEl.createDiv({
      cls: "omni-forge-parser-status-title",
      text: `Parser inbox · watch ${watchOn}`
    });
    const modeRow = this.parserStatusPanelEl.createDiv({ cls: "omni-forge-parser-mode-row" });
    const modePill = modeRow.createSpan({
      cls: `omni-forge-status-pill omni-forge-status-pill-parser ${parserProfile.mode === "detailed" ? "is-detailed" : "is-fast"}`,
      text: parserProfile.mode === "detailed" ? "Detailed · OCR" : "Fast · Speed"
    });
    modePill.setAttr(
      "title",
      this.localizeChatLabel(
        parserProfile.summary,
        parserProfile.mode === "detailed" ? `Detailed 모드: OCR 품질 우선(최대 ${LOCAL_QA_PDF_OCR_MAX_PAGES_DETAILED}p)` : `Fast 모드: 속도 우선(최대 ${LOCAL_QA_PDF_OCR_MAX_PAGES_FAST}p)`
      )
    );
    modeRow.createSpan({
      cls: "omni-forge-parser-status-hint",
      text: this.localizeChatLabel(
        parserProfile.recommendation,
        parserProfile.mode === "detailed" ? "손글씨/깨진 텍스트, 출처 정확도 우선 작업에 권장" : "일상 사용 기본값 권장, 품질 저하 시 OCR 재파싱/상세 모드 전환"
      )
    });
    this.parserStatusPanelEl.createDiv({ text: `진행률: ${processed}/${total} (${progressPct}%)` });
    this.parserStatusPanelEl.createDiv({ text: `소요시간: ${elapsedLabel}` });
    this.parserStatusPanelEl.createDiv({ text: `ETA: ${etaLabel}` });
    this.parserStatusPanelEl.createDiv({ text: `큐 길이: ${Math.max(0, status.queueLength || 0)}` });
    this.parserStatusPanelEl.createDiv({ text: `현재 단계: ${stageLabel}` });
    this.parserStatusPanelEl.createDiv({ text: `최근 파일: ${last.fileName}` });
    this.parserStatusPanelEl.createDiv({ text: `처리 결과: ${last.result} (success:${status.success || 0} / skip:${status.skip || 0} / error:${status.error || 0})` });
    if (diagMatch && diagMatch[1]) {
      this.parserStatusPanelEl.createDiv({ cls: "omni-forge-parser-status-hint", text: `진단: ${diagMatch[1]}` });
    }
    this.parserStatusPanelEl.createDiv({ text: `메시지: ${messageText}` });
    if (this.hwpChoiceApplyAllEnabled && this.hwpChoiceApplyAll) {
      const hwpPolicyLabel = this.hwpChoiceApplyAll === "pdf_only" ? "PDF만" : this.hwpChoiceApplyAll === "pdf_to_md" ? "PDF→MD" : "취소";
      this.parserStatusPanelEl.createDiv({ text: `HWP 일괄 정책: ${hwpPolicyLabel}` });
    }
  }
  render() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("omni-forge-chat-view");
    const root = contentEl.createDiv({ cls: "omni-forge-chat-root" });
    root.style.setProperty("--omni-forge-chat-font-size", `${this.plugin.settings.qaChatFontSize}px`);
    const t = (en, ko) => this.localizeChatLabel(en, ko);
    const headerTitle = this.plugin.getQaChatModelFamilyForQa() === "cloud" ? t("Cloud Chat", "클라우드 채팅") : t("Local Ollama", "로컬 Ollama");
    const header = root.createDiv({ cls: "omni-forge-chat-header" });
    this.headerTitleEl = header.createEl("h3", {
      text: headerTitle
    });
    this.scopeEl = header.createDiv({ cls: "omni-forge-chat-scope" });
    const actionRow = root.createDiv({ cls: "omni-forge-chat-actions" });
    this.createHeaderIconButton(
      actionRow,
      "plus-square",
      t("New thread", "새 스레드"),
      async () => {
        await this.startNewThread();
      }
    );
    this.createHeaderIconButton(
      actionRow,
      "files",
      t("Select notes", "노트 선택"),
      async () => {
        await this.plugin.openSelectionForQa();
        await this.refreshScopeLabel();
      }
    );
    this.createHeaderIconButton(
      actionRow,
      "play",
      t("Analyze selected notes", "선택 노트 즉시 분석"),
      async () => {
        await this.plugin.runAnalysis();
        await this.refreshScopeLabel();
      }
    );
    this.createHeaderIconButton(
      actionRow,
      "rotate-ccw",
      t("Reset selection", "선택 초기화"),
      async () => {
        await this.plugin.clearSelectionForQa(true);
        await this.refreshScopeLabel();
        this.pushMessage({
          role: "system",
          text: "\uC120\uD0DD\uB41C \uD30C\uC77C/\uD3F4\uB354 \uBC94\uC704\uB97C \uCD08\uAE30\uD654\uD588\uC2B5\uB2C8\uB2E4.",
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
    );
    this.createHeaderIconButton(
      actionRow,
      "refresh-cw",
      t("Refresh local models", "로컬 모델 새로고침"),
      async () => {
        await this.plugin.refreshOllamaDetection({ notify: false, autoApply: false });
        this.refreshModelOptions();
        await this.refreshScopeLabel();
      }
    );
    this.createHeaderIconButton(
      actionRow,
      "file-text",
      t("Open chat note", "채팅 노트 열기"),
      async () => {
        await this.openThreadNote();
      }
    );
    const familyToggleButton = this.createHeaderIconButton(
      actionRow,
      this.plugin.getQaChatModelFamilyForQa() === "cloud" ? "cloud" : "cpu",
      t("Toggle Local/Cloud", "로컬/클라우드 토글"),
      async () => {
        const currentFamily = this.plugin.getQaChatModelFamilyForQa();
        const nextFamily = currentFamily === "cloud" ? "local" : "cloud";
        const summary = await this.plugin.setQaChatModelFamilyForQa(nextFamily);
        new import_obsidian4.Notice(summary, 6e3);
        (0, import_obsidian4.setIcon)(familyToggleButton, nextFamily === "cloud" ? "cloud" : "cpu");
        familyToggleButton.setAttr(
          "title",
          nextFamily === "cloud" ? t("Now Cloud mode", "현재 클라우드 모드") : t("Now Local mode", "현재 로컬 모드")
        );
        this.refreshRoleOptions();
        this.refreshPipelineOptions();
        this.refreshConversationModeOptions();
        this.refreshModelOptions();
        await this.refreshScopeLabel();
      }
    );
    familyToggleButton.setAttr(
      "title",
      this.plugin.getQaChatModelFamilyForQa() === "cloud" ? t("Now Cloud mode", "현재 클라우드 모드") : t("Now Local mode", "현재 로컬 모드")
    );
    this.createHeaderIconButton(
      actionRow,
      "copy-plus",
      t("Open new chat pane (max 3)", "새 채팅창 열기(최대 3)"),
      async () => {
        await this.plugin.openLocalQaWorkspaceView(true);
      }
    );
    const parserDropButton = this.createHeaderIconButton(
      actionRow,
      "file-input",
      t("Parser ingest (.md convert)", "파서 인게스트(.md 변환)"),
      async () => {
        await this.openParserIngestPicker();
      }
    );
    parserDropButton.addEventListener("dragover", (event) => {
      event.preventDefault();
      parserDropButton.addClass("omni-forge-chat-drop-target-active");
    });
    parserDropButton.addEventListener("dragleave", () => {
      parserDropButton.removeClass("omni-forge-chat-drop-target-active");
    });
    parserDropButton.addEventListener("drop", (event) => {
      void this.handleParserDrop(event, parserDropButton);
    });
    const parserQuickWrap = root.createDiv({ cls: "omni-forge-parser-quick-wrap" });
    const parserQuickHeader = parserQuickWrap.createDiv({ cls: "omni-forge-parser-quick-header" });
    parserQuickHeader.createDiv({
      cls: "omni-forge-parser-quick-title",
      text: t("Parser inbox controls", "파서 inbox 제어")
    });
    const parserQuickToggleButton = parserQuickHeader.createEl("button", { text: "" });
    parserQuickToggleButton.addClass("omni-forge-chat-btn");
    parserQuickToggleButton.addClass("omni-forge-chat-btn-mini");
    let parserQuickCollapsed = this.plugin.settings.qaParserInboxCollapsedDefault !== false;
    const applyParserQuickCollapsed = (collapsed, persist = false) => {
      parserQuickCollapsed = collapsed;
      parserQuickToggleButton.textContent = collapsed ? t("Expand", "펼치기") : t("Collapse", "접기");
      parserQuickToggleButton.setAttr("aria-expanded", collapsed ? "false" : "true");
      const children = Array.from(parserQuickWrap.children);
      for (const child of children) {
        if (child === parserQuickHeader) {
          continue;
        }
        child.style.display = collapsed ? "none" : "";
      }
      if (persist) {
        this.plugin.settings.qaParserInboxCollapsedDefault = collapsed;
        void this.plugin.saveSettings();
      }
    };
    parserQuickToggleButton.onclick = async () => {
      applyParserQuickCollapsed(!parserQuickCollapsed, true);
    };
    parserQuickWrap.createDiv({
      cls: "omni-forge-parser-status-hint omni-forge-parser-quick-subtitle",
      text: t(
        "Keep Fast mode for speed. Use OCR re-parse when handwritten/garbled Korean text is suspected.",
        "속도는 Fast 모드 유지, 손글씨/깨진 한글이 의심되면 OCR 재파싱을 사용하세요."
      )
    });
    const parserProfileQuick = this.plugin.getParserModeProfileForQa();
    const parserSignalRow = parserQuickWrap.createDiv({ cls: "omni-forge-parser-mode-row" });
    const parserQuickPill = parserSignalRow.createSpan({
      cls: `omni-forge-status-pill omni-forge-status-pill-parser ${parserProfileQuick.mode === "detailed" ? "is-detailed" : "is-fast"}`,
      text: parserProfileQuick.mode === "detailed" ? t("Detailed mode", "상세 모드") : t("Fast mode", "빠른 모드")
    });
    parserQuickPill.setAttr(
      "title",
      t(
        parserProfileQuick.summary,
        parserProfileQuick.mode === "detailed" ? `Detailed 모드: OCR 품질 우선(최대 ${LOCAL_QA_PDF_OCR_MAX_PAGES_DETAILED}p)` : `Fast 모드: 속도 우선(최대 ${LOCAL_QA_PDF_OCR_MAX_PAGES_FAST}p)`
      )
    );
    parserSignalRow.createSpan({
      cls: "omni-forge-parser-status-hint",
      text: t(
        parserProfileQuick.recommendation,
        parserProfileQuick.mode === "detailed" ? "출처 정확도 우선/손글씨 인식 작업에 권장" : "일상 기본값 권장, 필요 시 OCR 재파싱/상세 모드 전환"
      )
    });
    const parserQuickRow = parserQuickWrap.createDiv({ cls: "omni-forge-chat-actions omni-forge-chat-actions-compact" });
    const openInboxButton = parserQuickRow.createEl("button", { text: t("Open inbox", "inbox 열기") });
    openInboxButton.addClass("omni-forge-chat-btn");
    openInboxButton.onclick = async () => {
      await this.plugin.openParserInboxFolderForQa();
      this.refreshParserStatusPanel();
    };
    const scanNowButton = parserQuickRow.createEl("button", { text: t("Scan now", "즉시 스캔") });
    scanNowButton.addClass("omni-forge-chat-btn");
    scanNowButton.onclick = async () => {
      await this.plugin.scanParserInboxNowForQa();
      this.refreshParserStatusPanel();
    };
    const reparseOcrButton = parserQuickRow.createEl("button", { text: t("OCR re-parse", "OCR 재파싱") });
    reparseOcrButton.addClass("omni-forge-chat-btn");
    reparseOcrButton.onclick = async () => {
      await this.plugin.scanParserInboxNowForQa({ forceOcr: true });
      this.refreshParserStatusPanel();
    };
    const formatsButton = parserQuickRow.createEl("button", { text: t("Formats", "지원 포맷") });
    formatsButton.addClass("omni-forge-chat-btn");
    formatsButton.onclick = () => {
      new import_obsidian4.Notice(`Parser formats: ${this.plugin.getParserSupportedFormatsForQa().join(", ")}`, 7e3);
    };
    const toggleWatchButton = parserQuickRow.createEl("button");
    toggleWatchButton.addClass("omni-forge-chat-btn");
    const updateWatchButtonLabel = () => {
      const text = this.plugin.settings.qaParserInboxWatchEnabled ? t("Watch ON", "watch ON") : t("Watch OFF", "watch OFF");
      toggleWatchButton.textContent = text;
    };
    updateWatchButtonLabel();
    toggleWatchButton.onclick = async () => {
      const next = !this.plugin.settings.qaParserInboxWatchEnabled;
      await this.plugin.setParserInboxWatchEnabledForQa(next);
      new import_obsidian4.Notice(`Parser inbox watch: ${next ? "ON" : "OFF"}`, 5e3);
      updateWatchButtonLabel();
      this.refreshParserStatusPanel();
    };
    this.parserStatusPanelEl = parserQuickWrap.createDiv({ cls: "omni-forge-parser-status-panel" });
    this.refreshParserStatusPanel();
    const graphQuickRow = parserQuickWrap.createDiv({ cls: "omni-forge-chat-actions omni-forge-chat-actions-compact" });
    const graphAnalyzeButton = graphQuickRow.createEl("button", { text: t("Graph analyze", "그래프 분석") });
    graphAnalyzeButton.addClass("omni-forge-chat-btn");
    graphAnalyzeButton.onclick = async () => {
      await this.plugin.runAnalysis();
      await this.refreshScopeLabel();
    };
    const graphApplyButton = graphQuickRow.createEl("button", { text: t("Graph apply", "그래프 반영") });
    graphApplyButton.addClass("omni-forge-chat-btn");
    graphApplyButton.onclick = async () => {
      await this.plugin.applyLinkedEdgesForGraphView();
      await this.refreshScopeLabel();
    };
    const graphHelpButton = graphQuickRow.createEl("button", { text: t("Mode guide", "모드 안내") });
    graphHelpButton.addClass("omni-forge-chat-btn");
    graphHelpButton.onclick = () => {
      new import_obsidian4.Notice(
        t(
          "Mode guide: Conversation mode controls agent routing (Ask/Plan/Agent/Orchestration). Parser mode controls attachment extraction (Fast vs Detailed OCR). Recommended default: Ask + Fast. For multi-step planning: Orchestration + Detailed.",
          "모드 안내: 대화 모드는 에이전트 라우팅(Ask/Plan/Agent/Orchestration)을, 파서 모드는 첨부 추출(Fast vs Detailed OCR)을 제어합니다. 기본 추천은 Ask + Fast, 다단계 작업은 Orchestration + Detailed 입니다."
        ),
        9e3
      );
    };
    const hwpGuideRow = parserQuickWrap.createDiv({ cls: "omni-forge-chat-actions omni-forge-chat-actions-compact omni-forge-parser-hwp-row" });
    const hwpGuide = hwpGuideRow.createDiv({
      cls: "omni-forge-parser-status-hint",
      text: "HWP는 soffice 자동변환(PoC) 가능 시 PDF parser chain을 시도하고, 실패 시 기존 가이드로 폴백합니다(HWPX는 XML 1차 추출 우선)."
    });
    const hwpHelpButton = hwpGuideRow.createEl("button", { text: t("HWP guide", "HWP 안내") });
    hwpHelpButton.addClass("omni-forge-chat-btn");
    hwpHelpButton.onclick = () => {
      new import_obsidian4.Notice("HWP는 soffice 자동변환(PoC)을 먼저 시도하고, 미탐지/실패 시 PDF/DOCX 수동 변환 안내로 폴백합니다.", 7e3);
    };
    void hwpGuide;
    applyParserQuickCollapsed(parserQuickCollapsed, false);
    const newThreadButton = actionRow.createEl("button", { text: t("New thread", "새 스레드") });
    newThreadButton.addClass("omni-forge-chat-btn");
    newThreadButton.addClass("omni-forge-chat-hidden-action");
    newThreadButton.onclick = async () => {
      await this.startNewThread();
    };
    const selectButton = actionRow.createEl("button", { text: t("Select notes", "노트 선택") });
    selectButton.addClass("omni-forge-chat-btn");
    selectButton.addClass("omni-forge-chat-hidden-action");
    selectButton.onclick = async () => {
      await this.plugin.openSelectionForQa();
      await this.refreshScopeLabel();
    };
    const analyzeSelectionButton = actionRow.createEl("button", {
      text: t("Analyze selected notes", "선택 노트 즉시 분석")
    });
    analyzeSelectionButton.addClass("omni-forge-chat-btn");
    analyzeSelectionButton.addClass("omni-forge-chat-hidden-action");
    analyzeSelectionButton.onclick = async () => {
      await this.plugin.runAnalysis();
      await this.refreshScopeLabel();
    };
    const resetSelectionButton = actionRow.createEl("button", {
      text: t("Reset selection", "선택 초기화")
    });
    resetSelectionButton.addClass("omni-forge-chat-btn");
    resetSelectionButton.addClass("omni-forge-chat-hidden-action");
    resetSelectionButton.onclick = async () => {
      await this.plugin.clearSelectionForQa(true);
      await this.refreshScopeLabel();
      this.pushMessage({
        role: "system",
        text: "\uC120\uD0DD\uB41C \uD30C\uC77C/\uD3F4\uB354 \uBC94\uC704\uB97C \uCD08\uAE30\uD654\uD588\uC2B5\uB2C8\uB2E4.",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    };
    const refreshModelsButton = actionRow.createEl("button", { text: t("Refresh models", "모델 감지") });
    refreshModelsButton.addClass("omni-forge-chat-btn");
    refreshModelsButton.addClass("omni-forge-chat-hidden-action");
    refreshModelsButton.setAttr(
      "title",
      "\uB85C\uCEEC \uBAA8\uB378 \uAC10\uC9C0\uB97C \uB2E4\uC2DC \uC77D\uACE0, \uCC44\uD305\uC758 \uBAA8\uB378 \uC120\uD0DD \uBAA9\uB85D\uC744 \uAC31\uC2E0\uD569\uB2C8\uB2E4."
    );
    refreshModelsButton.onclick = async () => {
      await this.plugin.refreshOllamaDetection({ notify: false, autoApply: false });
      this.refreshModelOptions();
      await this.refreshScopeLabel();
    };
    const openThreadButton = actionRow.createEl("button", { text: t("Open chat note", "채팅 노트 열기") });
    openThreadButton.addClass("omni-forge-chat-btn");
    openThreadButton.addClass("omni-forge-chat-hidden-action");
    openThreadButton.onclick = async () => {
      await this.openThreadNote();
    };
    const optionsDetails = root.createEl("details", { cls: "omni-forge-chat-collapsible omni-forge-chat-options-group" });
    optionsDetails.open = false;
    optionsDetails.createEl("summary", { text: t("Workspace options", "작업 옵션") });
    const optionsBody = optionsDetails.createDiv({ cls: "omni-forge-chat-options-group-body" });
    const utilityDetails = optionsBody.createEl("details", { cls: "omni-forge-chat-collapsible" });
    utilityDetails.open = true;
    utilityDetails.createEl("summary", { text: t("Maintenance tools", "유지보수 도구") });
    utilityDetails.createEl("small", {
      text: t(
        "Cleanup Keys edits frontmatter keys only, so it is usually faster than full Analyze/Apply.",
        "Cleanup Keys는 frontmatter 키만 정리하므로 전체 Analyze/Apply보다 보통 더 빠릅니다."
      )
    });
    const utilityRow = utilityDetails.createDiv({ cls: "omni-forge-chat-actions omni-forge-chat-actions-compact" });
    const cleanupPickerButton = utilityRow.createEl("button", { text: t("Cleanup keys", "정리 키") });
    cleanupPickerButton.addClass("omni-forge-chat-btn");
    cleanupPickerButton.onclick = async () => {
      await this.plugin.openCleanupKeyPickerForQa();
      await this.refreshScopeLabel();
    };
    const cleanupApplyButton = utilityRow.createEl("button", { text: t("Run cleanup", "정리 실행") });
    cleanupApplyButton.addClass("omni-forge-chat-btn");
    cleanupApplyButton.onclick = async () => {
      await this.plugin.runCleanupForQa(false);
      await this.refreshScopeLabel();
    };
    const cleanupDryRunButton = utilityRow.createEl("button", { text: t("Cleanup dry-run", "정리 미리보기") });
    cleanupDryRunButton.addClass("omni-forge-chat-btn");
    cleanupDryRunButton.onclick = async () => {
      await this.plugin.runCleanupForQa(true);
      await this.refreshScopeLabel();
    };
    const folderButton = utilityRow.createEl("button", { text: t("Chat folder", "채팅 폴더") });
    folderButton.addClass("omni-forge-chat-btn");
    folderButton.setAttr("title", t("Change chat transcript folder.", "채팅 기록 저장 폴더를 변경합니다."));
    folderButton.onclick = () => {
      const current = this.plugin.getChatTranscriptRootPathForQa() || "Omni Forge Chats";
      new VaultTextInputModal(
        this.app,
        t("Chat transcript folder", "채팅 저장 폴더"),
        "Omni Forge Chats",
        current,
        t("Save", "저장"),
        async (value) => {
          await this.plugin.setChatTranscriptRootPathForQa(value);
          new import_obsidian4.Notice(
            `${t("Chat folder set", "채팅 폴더 설정")}: ${this.plugin.getChatTranscriptRootPathForQa()}`,
            5e3
          );
          await this.refreshScopeLabel();
        }
      ).open();
    };
    const modelDetails = optionsBody.createEl("details", { cls: "omni-forge-chat-collapsible" });
    modelDetails.open = true;
    modelDetails.createEl("summary", { text: t("Model options", "모델 옵션") });
    this.modelPresetHintEl = modelDetails.createEl("small", {
      cls: "omni-forge-chat-model-hint"
    });
    this.modelLayoutSummaryEl = modelDetails.createDiv({
      cls: "omni-forge-chat-model-layout-summary"
    });
    const profileControlRow = modelDetails.createDiv({ cls: "omni-forge-chat-controls" });
    const familyWrap = profileControlRow.createDiv({ cls: "omni-forge-chat-control" });
    familyWrap.createEl("label", { text: t("Model source", "모델 소스") });
    this.chatModelFamilySelect = familyWrap.createEl("select", {
      cls: "omni-forge-chat-model-select"
    });
    const profileWrap = profileControlRow.createDiv({ cls: "omni-forge-chat-control" });
    profileWrap.createEl("label", { text: t("Chat model", "채팅 모델") });
    this.chatModelProfileSelect = profileWrap.createEl("select", {
      cls: "omni-forge-chat-model-select"
    });
    const refreshChatFamilyOptions = () => {
      if (!this.chatModelFamilySelect) {
        return;
      }
      const options = this.plugin.getQaChatModelFamilyOptionsForQa();
      const current = this.plugin.getQaChatModelFamilyForQa();
      this.chatModelFamilySelect.empty();
      for (const option of options) {
        const label = option.value === "local" ? t("Local", "로컬") : option.value === "cloud" ? t("Cloud", "클라우드") : option.label;
        this.chatModelFamilySelect.createEl("option", {
          value: option.value,
          text: label
        });
      }
      this.chatModelFamilySelect.value = options.some((option) => option.value === current) ? current : "local";
    };
    const refreshChatProfileOptions = () => {
      if (!this.chatModelProfileSelect) {
        return;
      }
      const family = this.chatModelFamilySelect && this.chatModelFamilySelect.value === "cloud" ? "cloud" : "local";
      const options = this.plugin.getQaChatModelProfileOptionsForQa(family);
      this.chatModelProfileSelect.empty();
      for (const option of options) {
        this.chatModelProfileSelect.createEl("option", {
          value: option.value,
          text: option.label || this.buildLocalizedChatProfileLabel(option.value)
        });
      }
      const current = this.plugin.getQaChatModelProfileForQa();
      const fallback = options.length > 0 ? options[0].value : "";
      this.chatModelProfileSelect.value = options.some((option) => option.value === current) ? current : fallback;
    };
    refreshChatFamilyOptions();
    refreshChatProfileOptions();
    this.chatModelFamilySelect.onchange = async () => {
      const family = this.chatModelFamilySelect && this.chatModelFamilySelect.value === "cloud" ? "cloud" : "local";
      const summary = await this.plugin.setQaChatModelFamilyForQa(family);
      new import_obsidian4.Notice(summary, 6500);
      refreshChatFamilyOptions();
      refreshChatProfileOptions();
      this.refreshRoleOptions();
      this.refreshPipelineOptions();
      this.refreshConversationModeOptions();
      this.refreshModelOptions();
      await this.refreshScopeLabel();
    };
    this.chatModelProfileSelect.onchange = async () => {
      const family = this.chatModelFamilySelect && this.chatModelFamilySelect.value === "cloud" ? "cloud" : "local";
      const summary = await this.plugin.applyQaChatModelProfileForQa(this.chatModelProfileSelect.value, family);
      new import_obsidian4.Notice(summary, 6500);
      this.refreshRoleOptions();
      this.refreshPipelineOptions();
      this.refreshConversationModeOptions();
      this.refreshModelOptions();
      await this.refreshScopeLabel();
    };
    const controlRow = modelDetails.createDiv({ cls: "omni-forge-chat-controls" });
    const topKWrap = controlRow.createDiv({ cls: "omni-forge-chat-control" });
    topKWrap.createEl("label", { text: t("Top sources", "상위 소스 수") });
    this.topKInput = topKWrap.createEl("input", {
      type: "number",
      cls: "omni-forge-chat-topk-input"
    });
    this.topKInput.min = "1";
    this.topKInput.max = "15";
    this.topKInput.value = String(this.plugin.settings.qaTopK);
    this.topKInput.onchange = async () => {
      const parsed = Number.parseInt(this.topKInput.value, 10);
      if (!Number.isFinite(parsed) || parsed < 1) {
        this.topKInput.value = String(this.plugin.settings.qaTopK);
        return;
      }
      this.plugin.settings.qaTopK = Math.min(15, parsed);
      await this.plugin.saveSettings();
    };
    const runtimePanel = optionsBody.createEl("details", { cls: "omni-forge-chat-runtime-panel" });
    runtimePanel.open = true;
    runtimePanel.createEl("summary", {
      cls: "omni-forge-chat-runtime-head",
      text: t("Current status", "현재 상태")
    });
    const runtimeBody = runtimePanel.createDiv({ cls: "omni-forge-chat-runtime-body" });
    const runtimeMetaRow = runtimeBody.createDiv({ cls: "omni-forge-chat-meta" });
    this.threadInfoEl = runtimeMetaRow.createDiv({ cls: "omni-forge-chat-thread-info" });
    this.syncInfoEl = runtimeMetaRow.createDiv({ cls: "omni-forge-chat-sync-info" });
    this.runtimeSummaryEl = runtimeBody.createDiv({ cls: "omni-forge-chat-runtime-summary" });
    this.threadEl = root.createDiv({ cls: "omni-forge-chat-thread" });
    this.threadEl.createDiv({
      cls: "omni-forge-chat-empty",
      text: t("Ask a question to start.", "질문을 입력해 대화를 시작하세요.")
    });
    const composer = root.createDiv({ cls: "omni-forge-chat-composer" });
    composer.addEventListener("dragover", (event) => {
      event.preventDefault();
      composer.addClass("omni-forge-chat-drop-active");
    });
    composer.addEventListener("dragleave", () => {
      composer.removeClass("omni-forge-chat-drop-active");
    });
    composer.addEventListener("drop", (event) => {
      void this.handleChatDrop(event, composer);
    });
    this.activeFileStatusEl = composer.createDiv({ cls: "omni-forge-chat-active-file-status" });
    void this.refreshActiveFileStatus();
    this.attachmentStatusEl = composer.createDiv({
      cls: "omni-forge-chat-attachment-status"
    });
    this.refreshAttachmentStatus();
    this.inputEl = composer.createEl("textarea", { cls: "omni-forge-chat-input" });
    this.inputEl.placeholder = t(
      "You can chat without selected notes. Attachments and selected-note questions are both supported.",
      "선택 문서가 없어도 대화할 수 있습니다. 첨부/선택 문서 기반 질문도 가능합니다."
    );
    const footer = composer.createDiv({ cls: "omni-forge-chat-footer" });
    const footerLeft = footer.createDiv({ cls: "omni-forge-chat-footer-left" });
    const attachButton = footerLeft.createEl("button", { text: `+ ${t("Add", "첨부")}` });
    attachButton.addClass("omni-forge-chat-btn");
    attachButton.onclick = async () => {
      await this.openAttachmentPicker();
    };
    const conversationModeSelect = footerLeft.createEl("select", {
      cls: "omni-forge-chat-mode-select"
    });
    this.conversationModeSelect = conversationModeSelect;
    conversationModeSelect.setAttr("aria-label", t("Conversation mode", "대화 모드"));
    conversationModeSelect.setAttr("title", t("Conversation mode", "대화 모드"));
    conversationModeSelect.onchange = async () => {
      const mode = conversationModeSelect.value;
      await this.plugin.setQaConversationModeForQa(mode);
      this.refreshConversationModeOptions();
      this.refreshRoleOptions();
      this.refreshPipelineOptions();
      this.refreshModelOptions();
      await this.refreshScopeLabel();
      this.pushMessage({
        role: "system",
        text: `\uB300\uD654 \uBAA8\uB4DC\uB97C ${this.plugin.getQaConversationModeLabelForQa()}\uB85C \uBCC0\uACBD\uD588\uC2B5\uB2C8\uB2E4.`,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    };
    this.qaContextButton = footerLeft.createEl("button", { text: "QA ON" });
    this.qaContextButton.addClass("omni-forge-chat-btn");
    this.qaContextButton.onclick = async () => {
      const next = !this.plugin.isQaContextEnabledForQa();
      await this.plugin.setQaContextEnabledForQa(next);
      this.refreshQaContextButton();
      await this.refreshScopeLabel();
      this.pushMessage({
        role: "system",
        text: next ? "QA \uCEE8\uD14D\uC2A4\uD2B8 ON: \uC120\uD0DD \uB178\uD2B8/\uC5F4\uB9B0 \uBB38\uC11C \uAE30\uBC18 \uB9AC\uD2B8\uB9AC\uBC8C\uC744 \uC0AC\uC6A9\uD569\uB2C8\uB2E4." : "QA \uCEE8\uD14D\uC2A4\uD2B8 OFF: \uC77C\uBC18 \uCC44\uD305 \uBAA8\uB4DC(\uC120\uD0DD \uB178\uD2B8 \uB9AC\uD2B8\uB9AC\uBC8C \uC5C6\uC74C)\uB85C \uC804\uD658\uD588\uC2B5\uB2C8\uB2E4.",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    };
    this.refreshQaContextButton();
    this.sendButton = footer.createEl("button", { text: t("Send", "전송"), cls: "mod-cta" });
    this.sendButton.addClass("omni-forge-chat-send");
    this.sendButton.onclick = async () => {
      await this.submitQuestion();
    };
    this.stopButton = footer.createEl("button", { text: t("Stop", "중지") });
    this.stopButton.addClass("omni-forge-chat-stop");
    this.stopButton.disabled = true;
    this.stopButton.onclick = () => {
      if (!this.running) {
        return;
      }
      this.stopButton.disabled = true;
      this.requestImmediateStop("\uC0AC\uC6A9\uC790\uAC00 \uC911\uC9C0 \uBC84\uD2BC\uC744 \uB20C\uB800\uC2B5\uB2C8\uB2E4.");
    };
    this.inputEl.addEventListener(
      "keydown",
      (event) => {
        handleChatTextareaEnterKey(event, this.inputEl, async () => this.submitQuestion());
      },
      { capture: true }
    );
    this.inputEl.addEventListener(
      "keyup",
      (event) => {
        if (!isEnterLikeKey(event)) {
          return;
        }
        if (event.shiftKey || event.ctrlKey || event.metaKey || event.altKey) {
          event.preventDefault();
          event.stopPropagation();
          event.stopImmediatePropagation();
        }
      },
      { capture: true }
    );
    this.registerDomEvent(
      window,
      "keydown",
      (event) => {
        if (document.activeElement !== this.inputEl) {
          return;
        }
        handleChatTextareaEnterKey(event, this.inputEl, async () => this.submitQuestion());
      },
      { capture: true }
    );
    this.inputEl.addEventListener("paste", (event) => {
      void this.handleChatPaste(event);
    });
    this.refreshSendButtonState();
    this.refreshConversationModeOptions();
    this.refreshRoleOptions();
    this.refreshPipelineOptions();
    this.refreshThreadMeta();
  }
  async refreshFromSettingsForQa() {
    if (!this.contentEl.isConnected) {
      return;
    }
    const root = this.contentEl.querySelector(".omni-forge-chat-root");
    if (root instanceof HTMLElement) {
      root.style.setProperty("--omni-forge-chat-font-size", `${this.plugin.settings.qaChatFontSize}px`);
    }
    this.refreshRoleOptions();
    this.refreshPipelineOptions();
    this.refreshModelOptions();
    this.refreshConversationModeOptions();
    this.refreshQaContextButton();
    if (this.threadEl) {
      this.renderMessages();
    }
    if (this.topKInput) {
      this.topKInput.value = String(this.plugin.settings.qaTopK);
    }
    await this.refreshScopeLabel();
    await this.refreshActiveFileStatus();
    this.refreshThreadMeta();
    this.refreshParserStatusPanel();
  }
  refreshRoleOptions() {
    if (!this.roleSelect) {
      return;
    }
    const options = this.plugin.getQaRolePresetOptionsForQa();
    const current = this.plugin.getQaRolePresetForQa();
    this.roleSelect.empty();
    for (const option of options) {
      this.roleSelect.createEl("option", { text: option.label, value: option.value });
    }
    this.roleSelect.value = current;
  }
  refreshPipelineOptions() {
    if (!this.pipelineSelect) {
      return;
    }
    const options = this.plugin.getQaPipelinePresetOptionsForQa();
    const current = this.plugin.getQaPipelinePresetForQa();
    this.pipelineSelect.empty();
    for (const option of options) {
      this.pipelineSelect.createEl("option", {
        text: option.label,
        value: option.value
      });
    }
    const fallback = options.length > 0 ? options[0].value : current;
    this.pipelineSelect.value = options.some((option) => option.value === current) ? current : fallback;
  }
  refreshConversationModeOptions() {
    if (!this.conversationModeSelect) {
      return;
    }
    const modeLabelMap = {
      ask: ["Ask", "질문"],
      plan: ["Plan", "계획"],
      agent: ["Agent", "에이전트"],
      orchestration: ["Orchestration", "오케스트레이션"]
    };
    const options = this.plugin.getQaConversationModeOptionsForQa();
    const current = this.plugin.getQaConversationModeForQa();
    this.conversationModeSelect.empty();
    for (const option of options) {
      const labelPair = modeLabelMap[option.value];
      this.conversationModeSelect.createEl("option", {
        text: labelPair ? this.localizeChatLabel(labelPair[0], labelPair[1]) : option.label,
        value: option.value
      });
    }
    this.conversationModeSelect.value = current;
    this.conversationModeSelect.setAttr(
      "title",
      `${this.localizeChatLabel("Mode", "모드")}=${this.plugin.getQaConversationModeLabelForQa()}`
    );
  }
  refreshQaContextButton() {
    if (!this.qaContextButton) {
      return;
    }
    const enabled = this.plugin.isQaContextEnabledForQa();
    this.qaContextButton.setText(enabled ? "QA ON" : "QA OFF");
    this.qaContextButton.setAttr(
      "title",
      enabled ? "\uC120\uD0DD \uB178\uD2B8/\uC5F4\uB9B0 \uBB38\uC11C \uAE30\uBC18 QA \uCEE8\uD14D\uC2A4\uD2B8\uB97C \uC0AC\uC6A9\uD569\uB2C8\uB2E4." : "\uC120\uD0DD \uB178\uD2B8 \uB9AC\uD2B8\uB9AC\uBC8C \uC5C6\uC774 \uC77C\uBC18 \uCC44\uD305\uC73C\uB85C \uB3D9\uC791\uD569\uB2C8\uB2E4."
    );
    this.qaContextButton.toggleClass("mod-cta", enabled);
  }
  refreshModelOptions() {
    const presetLabel = this.plugin.getQaPresetProfileLabelForQa();
    const modelFamily = this.plugin.getQaChatModelFamilyForQa();
    const profile = this.plugin.getQaChatModelProfileForQa();
    const parserProfile = this.plugin.getParserModeProfileForQa();
    const modelHealth = this.plugin.getQaLocalModelValidationForQa(this.plugin.getQaRolePresetForQa());
    if (this.headerTitleEl) {
      this.headerTitleEl.setText(
        modelFamily === "cloud" ? this.localizeChatLabel("Cloud Chat", "클라우드 채팅") : this.localizeChatLabel("Local Ollama", "로컬 Ollama")
      );
    }
    if (this.chatModelFamilySelect) {
      this.chatModelFamilySelect.value = modelFamily;
    }
    if (this.chatModelProfileSelect) {
      const options = this.plugin.getQaChatModelProfileOptionsForQa(modelFamily);
      const fallback = options.length > 0 ? options[0].value : modelFamily === "cloud" ? "codex" : "local-flash";
      const target = options.some((option) => option.value === profile) ? profile : fallback;
      this.chatModelProfileSelect.value = target;
    }
    if (this.modelPresetHintEl) {
      this.modelPresetHintEl.setText(
        `${this.localizeChatLabel("Source", "소스")}=${modelFamily === "cloud" ? this.localizeChatLabel("Cloud", "클라우드") : this.localizeChatLabel("Local", "로컬")} | ${this.localizeChatLabel("Profile", "프로필")}=${this.buildLocalizedChatProfileLabel(profile)} | Preset=${presetLabel} | convo=${this.plugin.getQaConversationModeLabelForQa()} | parser=${parserProfile.mode}(${parserProfile.focus}) | pipeline=${getQaPipelinePresetLabel(this.plugin.getQaPipelinePresetForQa())}`
      );
    }
    if (this.modelLayoutSummaryEl) {
      const lines = [
        `model-check: ${modelHealth.summary}`,
        `ask(text): ${this.plugin.getQaModelLabelForQa("ask")}`,
        `ask(vision): ${this.plugin.getQaModelLabelForQa("ask_vision")}`,
        `image: ${this.plugin.getQaModelLabelForQa("image_generator")}`,
        `code: ${this.plugin.getQaModelLabelForQa("coder")}`,
        `debug: ${this.plugin.getQaModelLabelForQa("debugger")}`,
        `architect: ${this.plugin.getQaModelLabelForQa("architect")}`,
        `orchestrator: ${this.plugin.getQaModelLabelForQa("orchestrator")}`,
        `safeguard: ${this.plugin.getQaModelLabelForQa("safeguard")}`
      ];
      this.modelLayoutSummaryEl.setText(lines.join(" | "));
      this.modelLayoutSummaryEl.setAttr("title", lines.join("\n"));
    }
  }
  refreshSendButtonState() {
    if (!this.sendButton) {
      return;
    }
    if (this.running) {
      const queueCount = this.queuedTurns.length;
      const preemptPending = this.pendingPreemptTurn !== null;
      this.sendButton.setText(
        preemptPending ? queueCount > 0 ? `Steer \uB300\uAE30\uC911 +${queueCount}` : "Steer \uC804\uD658 \uB300\uAE30\uC911" : queueCount > 0 ? `Steer +1 (\uB300\uAE30 ${queueCount + 1})` : "Steer / \uC911\uAC04 \uC9C0\uC2DC"
      );
      this.sendButton.setAttr(
        "title",
        preemptPending ? "\uD604\uC7AC \uD134 \uC911\uC9C0 \uD6C4 steer \uC9C8\uBB38\uC744 \uC6B0\uC120 \uC2E4\uD589\uD569\uB2C8\uB2E4." : "\uC2E4\uD589 \uC911\uC5D0\uB294 \uC804\uC1A1 \uB300\uC2E0 steer \uAE30\uB2A5\uC73C\uB85C \uC989\uC2DC \uC804\uD658/\uB300\uAE30\uC5F4 \uCD94\uAC00\uAC00 \uB3D9\uC791\uD569\uB2C8\uB2E4."
      );
      this.sendButton.disabled = false;
      this.sendButton.removeClass("mod-cta");
      return;
    }
    this.sendButton.setText(this.localizeChatLabel("Send", "전송"));
    this.sendButton.setAttr("title", this.localizeChatLabel("Send current input now.", "현재 입력한 질문을 즉시 전송합니다."));
    this.sendButton.disabled = false;
    this.sendButton.addClass("mod-cta");
  }
  captureCurrentInputTurn() {
    const question = this.inputEl.value.trim();
    if (!question) {
      return null;
    }
    const attachments = this.consumePendingAttachments();
    const openFile = this.resolveVisibleMarkdownFile();
    const openFilePath = openFile instanceof import_obsidian4.TFile && openFile.extension === "md" ? openFile.path : void 0;
    const openSelection = this.captureOpenSelectionSnapshot(openFilePath);
    this.inputEl.value = "";
    return {
      question,
      attachments,
      openFilePath,
      openSelection
    };
  }
  queueCurrentInputTurn() {
    const captured = this.captureCurrentInputTurn();
    if (!captured) {
      return false;
    }
    this.queuedTurns.push({
      question: captured.question,
      attachments: captured.attachments,
      openFilePath: captured.openFilePath,
      openSelection: captured.openSelection
    });
    this.pushMessage({
      role: "system",
      text: `\uC2E4\uD589 \uC911\uC774\uB77C steer \uAE30\uB2A5\uC73C\uB85C \uB300\uAE30\uC5F4\uC5D0 \uCD94\uAC00\uD588\uC2B5\uB2C8\uB2E4. (\uD604\uC7AC \uB300\uAE30 ${this.queuedTurns.length}\uAC1C)`,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    this.refreshSendButtonState();
    void this.refreshScopeLabel();
    return true;
  }
  preemptRunningTurnWithCurrentInput() {
    const captured = this.captureCurrentInputTurn();
    if (!captured) {
      return false;
    }
    if (this.pendingPreemptTurn) {
      this.queuedTurns.push(captured);
      this.pushMessage({
        role: "system",
        text: `\uC911\uC9C0 \uC804\uD658 \uCC98\uB9AC \uC911\uC774\uB77C steer \uC9C8\uBB38\uC744 \uB300\uAE30\uC5F4\uB85C \uCD94\uAC00\uD588\uC2B5\uB2C8\uB2E4. (\uD604\uC7AC \uB300\uAE30 ${this.queuedTurns.length}\uAC1C)`,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      this.refreshSendButtonState();
      void this.refreshScopeLabel();
      return true;
    }
    this.pendingPreemptTurn = captured;
    this.pushMessage({
      role: "system",
      text: "steer \uC989\uC2DC \uC804\uD658: \uD604\uC7AC \uC751\uB2F5\uC744 \uC911\uB2E8\uD558\uACE0 \uC0C8 \uC9C8\uBB38\uC744 \uC6B0\uC120 \uC2E4\uD589\uD569\uB2C8\uB2E4.",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    this.requestImmediateStop("steer \uC989\uC2DC \uC804\uD658");
    this.refreshSendButtonState();
    void this.refreshScopeLabel();
    return true;
  }
  async drainQueuedTurns() {
    if (this.queueDrainInProgress || this.running) {
      return;
    }
    if (this.queuedTurns.length === 0) {
      this.refreshSendButtonState();
      return;
    }
    this.queueDrainInProgress = true;
    try {
      while (!this.running && this.queuedTurns.length > 0) {
        const next = this.queuedTurns.shift();
        if (!next) {
          break;
        }
        await this.submitQuestion(next);
      }
    } finally {
      this.queueDrainInProgress = false;
      this.refreshSendButtonState();
      await this.refreshScopeLabel();
    }
  }
  normalizeAttachmentLabel(raw, fallback) {
    const trimmed = raw.trim();
    const value = trimmed || fallback;
    return value.length > 96 ? `${value.slice(0, 93)}...` : value;
  }
  clampAttachmentText(text, maxChars = 12e3) {
    if (text.length <= maxChars) {
      return text;
    }
    return `${text.slice(0, maxChars)}
...(truncated ${text.length - maxChars} chars)`;
  }
  attachmentMimeFromExt(ext) {
    switch (ext.toLowerCase()) {
      case "png":
        return "image/png";
      case "jpg":
      case "jpeg":
        return "image/jpeg";
      case "gif":
        return "image/gif";
      case "webp":
        return "image/webp";
      case "bmp":
        return "image/bmp";
      case "svg":
      case "svgz":
        return "image/svg+xml";
      default:
        return "application/octet-stream";
    }
  }
  isImageExt(ext) {
    return ["png", "jpg", "jpeg", "gif", "webp", "bmp", "svg", "svgz"].includes(
      ext.toLowerCase()
    );
  }
  isPdfExt(ext) {
    return ext.toLowerCase() === "pdf";
  }
  isHwpExt(ext) {
    const lower = ext.toLowerCase();
    return lower === "hwp" || lower === "hwpx";
  }
  isHwpxExt(ext) {
    return ext.toLowerCase() === "hwpx";
  }
  async promptHwpIngestChoice(fileName, remainingCount = 0) {
    if (this.hwpChoiceApplyAllEnabled && this.hwpChoiceApplyAll) {
      return this.hwpChoiceApplyAll;
    }
    const decision = await HwpIngestChoiceModal.open(this.app, fileName, remainingCount);
    if (decision.applyAll) {
      this.hwpChoiceApplyAllEnabled = true;
      this.hwpChoiceApplyAll = decision.choice;
    }
    return decision.choice;
  }
  reportHwpChoiceToParserStatus(fileName, choice, options = {}) {
    const choiceLabel = choice === "pdf_only" ? "PDF만 변환" : choice === "pdf_to_md" ? "PDF→MD" : "취소";
    const fallbackResult = choice === "cancel" ? "skip" : "guided";
    const result = typeof options.result === "string" && options.result.trim() ? options.result.trim() : fallbackResult;
    const statusMeta = typeof options.statusMeta === "string" && options.statusMeta.trim() ? ` | ${options.statusMeta.trim()}` : "";
    const message = `HWP/HWPX 사용자 선택: ${choiceLabel} | 결과: ${result}${statusMeta}`;
    this.plugin.setParserInboxLastEvent({
      fileName,
      result,
      message
    });
    if (typeof console !== "undefined" && typeof console.info === "function") {
      console.info(`[Omni-Forge][parser][hwp-choice] ${fileName} -> ${choiceLabel} (${result}${statusMeta})`);
    }
  }
  normalizeHwpxExtractedText(raw) {
    const withoutTags = raw.replace(/<[^>]+>/g, " ").replace(/&nbsp;/gi, " ").replace(/&amp;/gi, "&").replace(/&lt;/gi, "<").replace(/&gt;/gi, ">");
    return withoutTags.replace(/\r/g, "").replace(/\n{3,}/g, "\n\n").replace(/[ \t]{2,}/g, " ").trim();
  }
  async tryExtractHwpxText(binary, originalFileName) {
    const tmpRoot = await nodeFs.promises.mkdtemp(nodePath.join(nodeOs.tmpdir(), "omni-forge-hwpx-"));
    const archivePath = nodePath.join(tmpRoot, this.sanitizeIngestFileName(originalFileName || "document.hwpx", "document", "hwpx"));
    try {
      await nodeFs.promises.writeFile(archivePath, Buffer.from(binary));
      const listResult = await execAsync(`unzip -Z1 ${this.shellQuoteArg(archivePath)}`, { timeout: 2e4, maxBuffer: 4 * 1024 * 1024 });
      const sectionFiles = String(listResult.stdout || "").split(/\r?\n/).map((line) => line.trim()).filter((line) => /^Contents\/section\d+\.xml$/i.test(line)).sort((a, b) => a.localeCompare(b, "en"));
      if (sectionFiles.length === 0) {
        return "";
      }
      const chunks = [];
      for (const section of sectionFiles.slice(0, 60)) {
        try {
          const xmlResult = await execAsync(`unzip -p ${this.shellQuoteArg(archivePath)} ${this.shellQuoteArg(section)}`, {
            timeout: 2e4,
            maxBuffer: 8 * 1024 * 1024
          });
          const normalized = this.normalizeHwpxExtractedText(String(xmlResult.stdout || ""));
          if (normalized) {
            chunks.push(normalized);
          }
        } catch (e) {
        }
      }
      return chunks.join("\n\n").trim();
    } catch (e) {
      return "";
    } finally {
      try {
        await nodeFs.promises.rm(tmpRoot, { recursive: true, force: true });
      } catch (e) {
      }
    }
  }
  async convertHwpWithUserChoice(file, remainingCount = 0) {
    const choice = await this.promptHwpIngestChoice(file.name, remainingCount);
    const ext = (file.name.toLowerCase().split(".").pop() || "").trim();
    if (choice === "cancel") {
      this.reportHwpChoiceToParserStatus(file.name, choice, {
        result: "skip",
        statusMeta: "auto=not_attempted"
      });
      new import_obsidian4.Notice(`HWP 처리 취소: ${file.name}`);
      return null;
    }
    let autoResult = null;
    if (choice === "pdf_to_md" && ext === "hwp") {
      let hwpBinary = null;
      try {
        hwpBinary = await file.arrayBuffer();
      } catch (e) {
      }
      autoResult = await runHwpToPdfParserPocWithSoffice({
        ext,
        fileName: file.name,
        binary: hwpBinary,
        parsePdf: async (pdfBinary, pdfAbsolutePath) => await this.extractPdfTextWithParserChain(pdfBinary, pdfAbsolutePath)
      });
      if (autoResult.ok && autoResult.parsed) {
        const safeBaseName = file.name.replace(/\.[^.]+$/, "") || "document";
        const mirroredPdfPath = await this.persistBinaryAttachmentToIngest(
          `${safeBaseName}.pdf`,
          "pdf",
          "pdf",
          autoResult.pdfBinary
        );
        const parsed = autoResult.parsed;
        const parsedNotes = Array.isArray(parsed.notes) ? parsed.notes : [];
        this.reportHwpChoiceToParserStatus(file.name, choice, {
          result: "converted",
          statusMeta: `auto=${describeHwpAutoConvertStatus(autoResult.status)}`
        });
        return {
          kind: "pdf",
          label: this.normalizeAttachmentLabel(`${file.name} (hwp->pdf)`, `hwp-pdf-${Date.now()}`),
          path: mirroredPdfPath || autoResult.pdfPath,
          content: [
            `HWP auto-convert: ${file.name}`,
            `Converter: ${autoResult.sofficeBin}`,
            `Parser: ${parsed.parser}`,
            ...parsedNotes.map((note) => `- ${note}`),
            "---",
            this.clampAttachmentText(parsed.content || "", 2e4)
          ].join("\n")
        };
      }
    }
    const autoStatus = autoResult ? describeHwpAutoConvertStatus(autoResult.status, autoResult.message) : "not_attempted";
    this.reportHwpChoiceToParserStatus(file.name, choice, {
      result: "guided",
      statusMeta: `auto=${autoStatus}`
    });
    const guideText = choice === "pdf_only" ? [
      `HWP guide: ${file.name}`,
      "선택: PDF까지만 변환(권장)",
      "상태: HWP 자동변환은 실행하지 않았습니다.",
      "다음 단계: 외부 도구에서 HWP→PDF 변환 후 PDF를 다시 업로드하세요."
    ].join("\n") : [
      `HWP guide: ${file.name}`,
      "선택: PDF 변환 후 MD까지 진행",
      `자동 변환 상태: ${autoStatus}`,
      "다음 단계: 외부 도구에서 HWP→PDF 변환 후 PDF 업로드 시 parser ingest(.md)로 이어서 처리하세요."
    ].join("\n");
    return {
      kind: "text",
      label: this.normalizeAttachmentLabel(`${file.name} (hwp-guide)`, `hwp-guide-${Date.now()}`),
      path: this.extractDesktopAbsolutePathFromFile(file),
      content: guideText
    };
  }
  isLikelyTextFile(file) {
    if (file.type.startsWith("text/")) {
      return true;
    }
    const lowerType = file.type.toLowerCase();
    if (lowerType.includes("json") || lowerType.includes("xml") || lowerType.includes("yaml") || lowerType.includes("csv")) {
      return true;
    }
    const name = file.name.toLowerCase();
    return /\.(md|txt|json|ya?ml|csv|ts|js|jsx|tsx|py|java|go|rs|c|cpp|h|hpp|html|css|sql)$/i.test(name);
  }
  arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    const chunkSize = 32768;
    let binary = "";
    for (let i = 0; i < bytes.length; i += chunkSize) {
      binary += String.fromCharCode(...bytes.subarray(i, i + chunkSize));
    }
    return btoa(binary);
  }
  attachmentKey(item) {
    var _a;
    const source = ((_a = item.path) == null ? void 0 : _a.trim()) || item.label.trim();
    return `${item.kind}:${source}`;
  }
  sanitizeIngestFileName(rawName, fallbackBase, extHint = "") {
    const base = rawName.trim() || fallbackBase;
    const normalized = base.normalize("NFKD").replace(/[^\x20-\x7E]/g, "");
    const collapsed = normalized.replace(/[^A-Za-z0-9._-]+/g, "-").replace(/-+/g, "-");
    const trimmed = collapsed.replace(/^-+|-+$/g, "") || fallbackBase;
    const ext = extHint.trim().replace(/^\.+/, "").toLowerCase();
    if (!ext) {
      return trimmed;
    }
    return trimmed.toLowerCase().endsWith(`.${ext}`) ? trimmed : `${trimmed}.${ext}`;
  }
  async ensureVaultFolderPathForIngest(folderPath) {
    const normalized = (0, import_obsidian4.normalizePath)(folderPath);
    if (!normalized) {
      return;
    }
    const parts = normalized.split("/");
    let cursor = "";
    for (const part of parts) {
      cursor = cursor ? `${cursor}/${part}` : part;
      const existing = this.app.vault.getAbstractFileByPath(cursor);
      if (existing instanceof import_obsidian4.TFolder || existing instanceof import_obsidian4.TFile) {
        continue;
      }
      await this.app.vault.createFolder(cursor);
    }
  }
  buildIngestVaultPath(fileName, extHint, kind) {
    const stamp = formatBackupStamp(/* @__PURE__ */ new Date());
    const day = stamp.slice(0, 10);
    const root = (0, import_obsidian4.normalizePath)(
      (this.plugin.settings.qaAttachmentIngestRootPath || "").trim() || DEFAULT_SETTINGS.qaAttachmentIngestRootPath
    );
    const safeName = this.sanitizeIngestFileName(fileName, `${kind}-attachment`, extHint);
    const suffix = Math.random().toString(36).slice(2, 8);
    return (0, import_obsidian4.normalizePath)(
      `${root}/${kind}/${day}/${stamp}-${suffix}-${safeName}`
    );
  }
  async persistBinaryAttachmentToIngest(fileName, extHint, kind, binary) {
    try {
      const targetPath = this.buildIngestVaultPath(fileName, extHint, kind);
      const folder = (0, import_obsidian4.normalizePath)(targetPath.split("/").slice(0, -1).join("/"));
      await this.ensureVaultFolderPathForIngest(folder);
      const adapter = this.app.vault.adapter;
      const vaultWithBinary = this.app.vault;
      if (typeof adapter.writeBinary === "function") {
        await adapter.writeBinary(targetPath, binary);
      } else if (typeof vaultWithBinary.createBinary === "function") {
        await vaultWithBinary.createBinary(targetPath, binary);
      } else {
        return void 0;
      }
      return targetPath;
    } catch (e) {
      return void 0;
    }
  }
  async persistTextAttachmentToIngest(fileName, extHint, kind, content) {
    try {
      const targetPath = this.buildIngestVaultPath(fileName, extHint, kind);
      const folder = (0, import_obsidian4.normalizePath)(targetPath.split("/").slice(0, -1).join("/"));
      await this.ensureVaultFolderPathForIngest(folder);
      await this.app.vault.adapter.write(targetPath, content);
      return targetPath;
    } catch (e) {
      return void 0;
    }
  }
  decodePdfLiteralString(raw) {
    let value = raw.replace(/\\\r?\n/g, "");
    value = value.replace(/\\([nrtbf()\\])/g, (_match, token) => {
      switch (token) {
        case "n":
          return "\n";
        case "r":
          return "\r";
        case "t":
          return "	";
        case "b":
          return "\b";
        case "f":
          return "\f";
        default:
          return token;
      }
    });
    value = value.replace(/\\([0-7]{1,3})/g, (_match, octal) => {
      const parsed = Number.parseInt(octal, 8);
      return Number.isFinite(parsed) ? String.fromCharCode(parsed) : "";
    });
    return value;
  }
  extractPdfFallbackText(binary) {
    const buffer = Buffer.from(binary);
    const latin = buffer.toString("latin1");
    const fragments = [];
    const literalRegex = /\(([^()]{2,})\)\s*T[Jj]/g;
    let match = literalRegex.exec(latin);
    while (match) {
      const decoded = this.decodePdfLiteralString(match[1]);
      if (decoded.trim().length >= 2) {
        fragments.push(decoded.trim());
      }
      match = literalRegex.exec(latin);
      if (fragments.length >= 500) {
        break;
      }
    }
    if (fragments.length > 0) {
      return fragments.join("\n");
    }
    const utf8 = buffer.toString("utf8");
    return utf8.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, " ").replace(/\s+/g, " ").trim();
  }
  shellQuoteArg(value) {
    return `'${value.replace(/'/g, `'"'"'`)}'`;
  }
  async canUseShellCommand(command) {
    var _a;
    const safe = command.trim();
    if (!/^[A-Za-z0-9._-]+$/.test(safe)) {
      return false;
    }
    if (this.commandAvailabilityCache.has(safe)) {
      return (_a = this.commandAvailabilityCache.get(safe)) != null ? _a : false;
    }
    try {
      await execAsync(`command -v ${safe}`);
      this.commandAvailabilityCache.set(safe, true);
      return true;
    } catch (e) {
      this.commandAvailabilityCache.set(safe, false);
      return false;
    }
  }
  async resolvePdf2TxtExecutable() {
    if (await this.canUseShellCommand("pdf2txt.py")) {
      return "pdf2txt.py";
    }
    if (await this.canUseShellCommand("pdf2txt")) {
      return "pdf2txt";
    }
    const absoluteCandidates = [
      "/opt/homebrew/bin/pdf2txt.py",
      "/usr/local/bin/pdf2txt.py",
      "/Library/Frameworks/Python.framework/Versions/3.14/bin/pdf2txt.py"
    ];
    const home = ((process.env.HOME || "") + "").trim();
    if (home) {
      const userPythonRoot = nodePath.join(home, "Library", "Python");
      try {
        const versionEntries = await nodeFs.promises.readdir(userPythonRoot, {
          withFileTypes: true
        });
        const versionDirs = versionEntries.filter((entry) => entry.isDirectory()).map((entry) => entry.name).sort((a, b) => b.localeCompare(a));
        for (const version of versionDirs) {
          absoluteCandidates.push(nodePath.join(userPythonRoot, version, "bin", "pdf2txt.py"));
        }
      } catch (e) {
      }
    }
    for (const candidate of absoluteCandidates) {
      try {
        await nodeFs.promises.access(candidate, nodeFs.constants.X_OK);
        return candidate;
      } catch (e) {
      }
    }
    return null;
  }
  async extractPdfTextViaPdftotext(pdfAbsolutePath) {
    var _a;
    const command = [
      "pdftotext",
      "-enc",
      "UTF-8",
      "-layout",
      "-nopgbrk",
      this.shellQuoteArg(pdfAbsolutePath),
      "-"
    ].join(" ");
    const result = await execAsync(command, { timeout: 25e3, maxBuffer: 12 * 1024 * 1024 });
    return ((_a = result.stdout) != null ? _a : "").trim();
  }
  async extractPdfTextViaPdfMiner(pdfAbsolutePath) {
    var _a;
    const pdf2txt = await this.resolvePdf2TxtExecutable();
    if (!pdf2txt) {
      return "";
    }
    const command = [
      this.shellQuoteArg(pdf2txt),
      "--output_type",
      "text",
      "--codec",
      "utf-8",
      this.shellQuoteArg(pdfAbsolutePath)
    ].join(" ");
    const result = await execAsync(command, { timeout: 45e3, maxBuffer: 16 * 1024 * 1024 });
    return ((_a = result.stdout) != null ? _a : "").trim();
  }
  async extractPdfTextViaOcr(pdfAbsolutePath, maxPages, options) {
    var _a;
    const requestedPsm = Number.parseInt(String((options == null ? void 0 : options.psm) != null ? options.psm : 6), 10);
    const psm = Number.isFinite(requestedPsm) ? Math.max(3, Math.min(13, requestedPsm)) : 6;
    const requestedOem = Number.parseInt(String((options == null ? void 0 : options.oem) != null ? options.oem : ""), 10);
    const oem = Number.isFinite(requestedOem) ? Math.max(0, Math.min(3, requestedOem)) : null;
    const preserveInterwordSpaces = Boolean(options == null ? void 0 : options.preserveInterwordSpaces);
    const tmpRoot = await nodeFs.promises.mkdtemp(
      nodePath.join(nodeOs.tmpdir(), "omni-forge-ocr-")
    );
    try {
      const prefix = nodePath.join(tmpRoot, "page");
      const renderCommand = [
        "pdftoppm",
        "-f",
        "1",
        "-l",
        String(Math.max(1, maxPages)),
        "-png",
        this.shellQuoteArg(pdfAbsolutePath),
        this.shellQuoteArg(prefix)
      ].join(" ");
      await execAsync(renderCommand, { timeout: 45e3, maxBuffer: 8 * 1024 * 1024 });
      const pageImages = (await nodeFs.promises.readdir(tmpRoot)).filter((name) => /^page-\d+\.png$/i.test(name)).map((name) => nodePath.join(tmpRoot, name)).sort((a, b) => a.localeCompare(b));
      const chunks = [];
      for (const imagePath of pageImages) {
        const ocrCommandParts = [
          "tesseract",
          this.shellQuoteArg(imagePath),
          "stdout",
          "-l",
          "kor+eng",
          "--psm",
          String(psm)
        ];
        if (oem !== null) {
          ocrCommandParts.push("--oem", String(oem));
        }
        if (preserveInterwordSpaces) {
          ocrCommandParts.push("-c", "preserve_interword_spaces=1");
        }
        const ocrCommand = ocrCommandParts.join(" ");
        try {
          const output = await execAsync(ocrCommand, {
            timeout: 45e3,
            maxBuffer: 12 * 1024 * 1024
          });
          const text = ((_a = output.stdout) != null ? _a : "").trim();
          if (text) {
            chunks.push(text);
          }
        } catch (e) {
        }
      }
      return chunks.join("\n").trim();
    } finally {
      await nodeFs.promises.rm(tmpRoot, { recursive: true, force: true }).catch(() => {
      });
    }
  }
  scoreAttachmentTextReadability(text) {
    const trimmed = text.trim();
    if (!trimmed) {
      return 0;
    }
    const compact = trimmed.replace(/\s+/g, "");
    if (!compact) {
      return 0;
    }
    const readableCount = ((compact.match(/[A-Za-z0-9가-힣]/g) || []).length);
    const replacementCount = ((compact.match(/�/g) || []).length);
    const controlCount = ((compact.match(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g) || []).length);
    const score = (readableCount - replacementCount * 4 - controlCount * 2) / compact.length;
    return Math.max(0, Math.min(1, score));
  }
  shouldJoinKoreanOcrLines(prevLine, nextLine) {
    if (!prevLine || !nextLine) {
      return false;
    }
    if (/^[-*•]\s/.test(nextLine) || /^\d+[.)]\s/.test(nextLine)) {
      return false;
    }
    if (/^#{1,6}\s/.test(nextLine) || /^`{3}/.test(prevLine) || /^`{3}/.test(nextLine)) {
      return false;
    }
    if (/[|]$/.test(prevLine) || /^[|]/.test(nextLine)) {
      return false;
    }
    if (/[.?!。！？:：]$/.test(prevLine)) {
      return false;
    }
    if (!/[A-Za-z0-9가-힣\)\]]$/.test(prevLine)) {
      return false;
    }
    if (!/^[A-Za-z0-9가-힣\(\[]/.test(nextLine)) {
      return false;
    }
    const prevCompact = prevLine.replace(/\s+/g, "");
    const nextCompact = nextLine.replace(/\s+/g, "");
    if (prevCompact.length < 2 || nextCompact.length < 2) {
      return false;
    }
    return true;
  }
  splitWhitespaceTableColumns(rawLine) {
    const line = typeof rawLine === "string" ? rawLine.trim() : "";
    if (!line || line.length < 6) {
      return [];
    }
    if (line.startsWith("|") && line.endsWith("|")) {
      return [];
    }
    if (/^[-*•]\s/.test(line) || /^\d+[.)]\s/.test(line) || /^#{1,6}\s/.test(line)) {
      return [];
    }
    if (!/\t|\s{2,}/.test(line)) {
      return [];
    }
    const columns = line.split(/\t+|\s{2,}/g).map((cell) => cell.trim()).filter((cell) => cell.length > 0);
    if (columns.length < 2 || columns.length > 8) {
      return [];
    }
    if (columns.some((cell) => cell.length > 90)) {
      return [];
    }
    const readableCells = columns.filter((cell) => /[A-Za-z0-9가-힣]/.test(cell)).length;
    if (readableCells < Math.max(1, columns.length - 1)) {
      return [];
    }
    return columns;
  }
  normalizeWhitespaceTableCell(cell) {
    return String(cell || "").replace(/\|/g, "¦").replace(/\s+/g, " ").trim();
  }
  chooseDominantTableColumnCount(rows) {
    const histogram = /* @__PURE__ */ new Map();
    for (const row of rows) {
      const key = row.length;
      histogram.set(key, (histogram.get(key) || 0) + 1);
    }
    const sorted = [...histogram.entries()].sort((a, b) => b[1] - a[1] || a[0] - b[0]);
    return sorted.length > 0 ? sorted[0][0] : 0;
  }
  convertWhitespaceTableRowsToMarkdown(rows, targetColumns) {
    if (rows.length < 3 || targetColumns < 2) {
      return [];
    }
    const normalizedRows = rows.map((row) => {
      const normalized = row.slice(0, targetColumns).map((cell) => this.normalizeWhitespaceTableCell(cell));
      while (normalized.length < targetColumns) {
        normalized.push("");
      }
      return normalized;
    }).filter((row) => row.some((cell) => cell.length > 0));
    if (normalizedRows.length < 3) {
      return [];
    }
    const header = normalizedRows[0];
    const body = normalizedRows.slice(1);
    const tableLines = [];
    tableLines.push(`| ${header.join(" | ")} |`);
    tableLines.push(`| ${new Array(targetColumns).fill("---").join(" | ")} |`);
    for (const row of body) {
      tableLines.push(`| ${row.join(" | ")} |`);
    }
    return tableLines;
  }
  rebuildWhitespaceTablesForParser(text) {
    const input = typeof text === "string" ? text.trim() : "";
    if (!input) {
      return "";
    }
    const sourceLines = input.split("\n");
    const rebuilt = [];
    let index = 0;
    while (index < sourceLines.length) {
      const firstColumns = this.splitWhitespaceTableColumns(sourceLines[index]);
      if (firstColumns.length < 2) {
        rebuilt.push(sourceLines[index]);
        index += 1;
        continue;
      }
      const start = index;
      const rows = [firstColumns];
      index += 1;
      while (index < sourceLines.length) {
        const columns = this.splitWhitespaceTableColumns(sourceLines[index]);
        if (columns.length < 2) {
          break;
        }
        const currentColumns = rows[rows.length - 1].length;
        if (Math.abs(columns.length - currentColumns) > 1) {
          break;
        }
        rows.push(columns);
        index += 1;
      }
      const dominantColumns = this.chooseDominantTableColumnCount(rows);
      const candidateRows = rows.filter((row) => Math.abs(row.length - dominantColumns) <= 1);
      const markdownTable = this.convertWhitespaceTableRowsToMarkdown(candidateRows, dominantColumns);
      if (markdownTable.length > 0) {
        if (rebuilt.length > 0 && rebuilt[rebuilt.length - 1].trim().length > 0) {
          rebuilt.push("");
        }
        rebuilt.push(...markdownTable);
        if (index < sourceLines.length && sourceLines[index].trim().length > 0) {
          rebuilt.push("");
        }
        continue;
      }
      for (let cursor = start; cursor < index; cursor += 1) {
        rebuilt.push(sourceLines[cursor]);
      }
    }
    return rebuilt.join("\n").replace(/\n{3,}/g, "\n\n").trim();
  }
  normalizeParserExtractedText(text, options) {
    const forOcr = Boolean(options == null ? void 0 : options.forOcr);
    const normalizeSpacing = options == null ? void 0 : options.normalizeSpacing;
    let normalized = typeof text === "string" ? text : "";
    if (!normalized) {
      return "";
    }
    normalized = normalized.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    if (typeof normalized.normalize === "function") {
      normalized = normalized.normalize("NFKC");
    }
    normalized = normalized.replace(/[\u200B-\u200D\uFEFF]/g, "");
    normalized = normalized.replace(/[ \t]+\n/g, "\n").replace(/\n{3,}/g, "\n\n");
    if (!forOcr) {
      let compact = normalized.trim();
      if (normalizeSpacing === false) {
        return this.rebuildWhitespaceTablesForParser(compact);
      }
      compact = compact.replace(/([가-힣])\s+([.,!?;:])/g, "$1$2");
      return this.rebuildWhitespaceTablesForParser(compact);
    }
    const lines = normalized.split("\n").map((line) => line.replace(/[ \t]+/g, " ").trimEnd());
    const merged = [];
    for (const rawLine of lines) {
      const line = rawLine.trim();
      if (!line) {
        if (merged.length === 0 || merged[merged.length - 1] === "") {
          continue;
        }
        merged.push("");
        continue;
      }
      if (merged.length === 0 || merged[merged.length - 1] === "") {
        merged.push(line);
        continue;
      }
      const prev = merged[merged.length - 1];
      if (this.shouldJoinKoreanOcrLines(prev, line)) {
        const joinWithoutSpace = /[-‐‑‒–—]$/.test(prev) && /^[A-Za-z가-힣]/.test(line);
        merged[merged.length - 1] = joinWithoutSpace ? `${prev.replace(/[-‐‑‒–—]$/, "")}${line}` : `${prev} ${line}`;
      } else {
        merged.push(line);
      }
    }
    let compact = merged.join("\n").replace(/[ ]{2,}/g, " ").replace(/\n{3,}/g, "\n\n").trim();
    if (normalizeSpacing === false) {
      return this.rebuildWhitespaceTablesForParser(compact);
    }
    compact = compact.replace(/([가-힣])\s+([.,!?;:])/g, "$1$2");
    return this.rebuildWhitespaceTablesForParser(compact);
  }
  assessAttachmentTextQuality(text) {
    const normalized = this.normalizeParserExtractedText(text || "", {
      forOcr: false,
      normalizeSpacing: false
    });
    const compact = normalized.replace(/\s+/g, "");
    if (!compact) {
      return {
        readabilityScore: 0,
        lowConfidence: true,
        likelyMojibake: false,
        koreanHandwritingRisk: false,
        readableRatio: 0,
        replacementRatio: 0,
        jamoRatio: 0,
        shortLineRatio: 0,
        charCount: 0
      };
    }
    const readableCount = (compact.match(/[A-Za-z0-9가-힣]/g) || []).length;
    const replacementCount = (compact.match(/�/g) || []).length;
    const jamoCount = (compact.match(/[ㄱ-ㅎㅏ-ㅣᄀ-ᇿ]/g) || []).length;
    const hangulCount = (compact.match(/[가-힣]/g) || []).length;
    const symbolCount = (compact.match(/[^A-Za-z0-9가-힣ㄱ-ㅎㅏ-ㅣ.,!?;:()\[\]{}'"`~_\-+=/*%&@#$^<>]/g) || []).length;
    const lines = normalized.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
    const shortLines = lines.filter((line) => line.replace(/\s+/g, "").length <= 2).length;
    const readableRatio = readableCount / compact.length;
    const replacementRatio = replacementCount / compact.length;
    const jamoRatio = jamoCount / compact.length;
    const symbolRatio = symbolCount / compact.length;
    const shortLineRatio = lines.length > 0 ? shortLines / lines.length : 0;
    const readabilityScore = this.scoreAttachmentTextReadability(normalized);
    const likelyMojibake = this.isLikelyMojibakeText(normalized);
    const lowConfidence = compact.length < 80 || readabilityScore < 0.4 || readableRatio < 0.36 || replacementRatio > 0.015 || shortLineRatio > 0.55 || symbolRatio > 0.35;
    const koreanHandwritingRisk = hangulCount >= 24 && (jamoRatio > 0.08 || shortLineRatio > 0.46 || readabilityScore < 0.5);
    return {
      readabilityScore,
      lowConfidence,
      likelyMojibake,
      koreanHandwritingRisk,
      readableRatio,
      replacementRatio,
      jamoRatio,
      shortLineRatio,
      charCount: compact.length
    };
  }
  isLikelyMojibakeText(text) {
    const compact = (text || "").replace(/\s+/g, "");
    if (!compact || compact.length < 120) {
      return false;
    }
    const replacementCount = (compact.match(/�/g) || []).length;
    const suspiciousCount = (compact.match(/[ƀ-ɏͰ-ϿҀ-ӿא-ת؀-ۿᄀ-ᇿ]/g) || []).length;
    const readableCount = (compact.match(/[A-Za-z0-9가-힣]/g) || []).length;
    const replacementRatio = replacementCount / compact.length;
    const suspiciousRatio = suspiciousCount / compact.length;
    const readableRatio = readableCount / compact.length;
    return replacementRatio > 0.02 || suspiciousRatio > 0.22 || readableRatio < 0.38;
  }
  resolveVaultAbsolutePath(vaultPath) {
    const base = this.getVaultBasePathForChatView();
    if (!base) {
      return void 0;
    }
    return nodePath.resolve(base, vaultPath);
  }
  async extractPdfTextWithParserChain(binary, sourceAbsolutePath, options) {
    const notes = [];
    let parser = "metadata-only";
    let extracted = "";
    let quality = this.assessAttachmentTextQuality("");
    let workingPath = sourceAbsolutePath;
    let tempDir;
    let strongOcrAttempted = false;
    const parserMode = this.plugin.settings.qaParserMode === "detailed" ? "detailed" : "fast";
    const preferDetailed = parserMode === "detailed";
    const forceOcrPreferred = Boolean(options == null ? void 0 : options.forceOcr);
    const modeProfile = preferDetailed ? "quality-first" : "speed-first";
    const pdftotextEnoughLength = preferDetailed ? 220 : 140;
    const pdfminerEnoughLength = preferDetailed ? 180 : 120;
    const ocrMaxPages = preferDetailed ? LOCAL_QA_PDF_OCR_MAX_PAGES_DETAILED : LOCAL_QA_PDF_OCR_MAX_PAGES_FAST;
    notes.push(`parser mode=${parserMode} (${modeProfile})`);
    notes.push(`ocr budget pages=${ocrMaxPages}`);
    if (forceOcrPreferred) {
      notes.push("manual override: force OCR re-parse");
    }
    try {
      if (!workingPath) {
        tempDir = await nodeFs.promises.mkdtemp(
          nodePath.join(nodeOs.tmpdir(), "omni-forge-pdf-")
        );
        workingPath = nodePath.join(tempDir, "input.pdf");
        await nodeFs.promises.writeFile(workingPath, Buffer.from(binary));
      }
      if (await this.canUseShellCommand("pdftotext")) {
        try {
          extracted = this.normalizeParserExtractedText(
            await this.extractPdfTextViaPdftotext(workingPath),
            { forOcr: false, normalizeSpacing: true }
          );
          quality = this.assessAttachmentTextQuality(extracted);
          if (quality.likelyMojibake) {
            notes.push("pdftotext produced likely mojibake text. Forcing OCR preference.");
          }
          if (quality.lowConfidence) {
            notes.push(`pdftotext low-confidence detected (score=${quality.readabilityScore.toFixed(2)}).`);
          }
          if (extracted.length > pdftotextEnoughLength && quality.readabilityScore >= 0.42 && !quality.likelyMojibake && !quality.lowConfidence) {
            parser = "pdftotext";
          } else {
            notes.push(`pdftotext quality low/short (score=${quality.readabilityScore.toFixed(2)}). Trying OCR/fallback.`);
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : "pdftotext failed";
          notes.push(`pdftotext failed: ${message}`);
        }
      } else {
        notes.push("pdftotext unavailable: trying pdfminer/OCR/fallback.");
      }
      const shouldTryPdfminer = extracted.length < pdftotextEnoughLength || quality.readabilityScore < 0.45 || parser !== "pdftotext" || quality.lowConfidence;
      if (shouldTryPdfminer) {
        try {
          const pdfminerText = this.normalizeParserExtractedText(
            await this.extractPdfTextViaPdfMiner(workingPath),
            { forOcr: false, normalizeSpacing: true }
          );
          if (pdfminerText.trim()) {
            const pdfminerQuality = this.assessAttachmentTextQuality(pdfminerText);
            const shouldPreferPdfminer = parser !== "pdftotext" || pdfminerQuality.readabilityScore > quality.readabilityScore + 0.03 || pdfminerText.length > extracted.length + 80 || pdfminerText.length >= pdfminerEnoughLength && quality.readabilityScore < 0.4 || quality.lowConfidence && !pdfminerQuality.lowConfidence;
            if (shouldPreferPdfminer) {
              extracted = pdfminerText;
              parser = "pdfminer";
              quality = pdfminerQuality;
            } else {
              notes.push(`pdfminer candidate kept secondary (score=${pdfminerQuality.readabilityScore.toFixed(2)}).`);
            }
          } else {
            notes.push("pdfminer unavailable or produced empty text.");
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : "pdfminer failed";
          notes.push(`pdfminer failed: ${message}`);
        }
      }
      const shouldTryOcr = forceOcrPreferred || preferDetailed || extracted.length < pdftotextEnoughLength || quality.readabilityScore < 0.42 || quality.likelyMojibake || quality.lowConfidence || quality.koreanHandwritingRisk;
      const ocrToolsReady = await this.canUseShellCommand("pdftoppm") && await this.canUseShellCommand("tesseract");
      if (shouldTryOcr && ocrToolsReady) {
        try {
          const ocrText = this.normalizeParserExtractedText(
            await this.extractPdfTextViaOcr(workingPath, ocrMaxPages, { psm: 6 }),
            { forOcr: true, normalizeSpacing: true }
          );
          const ocrQuality = this.assessAttachmentTextQuality(ocrText);
          const shouldPreferOcr = forceOcrPreferred || quality.likelyMojibake || quality.lowConfidence || ocrQuality.readabilityScore > quality.readabilityScore + 0.08 || (ocrText.length > extracted.length + 120 && !ocrQuality.likelyMojibake) || quality.koreanHandwritingRisk && !ocrQuality.lowConfidence;
          if (shouldPreferOcr) {
            extracted = ocrText;
            parser = "ocr";
            quality = ocrQuality;
          } else if (ocrText.trim()) {
            notes.push(`OCR kept as secondary candidate (score=${ocrQuality.readabilityScore.toFixed(2)}).`);
          }
          const shouldTryStrongOcr = preferDetailed ? forceOcrPreferred || quality.koreanHandwritingRisk || quality.lowConfidence || quality.likelyMojibake : forceOcrPreferred || quality.likelyMojibake || (quality.koreanHandwritingRisk && quality.lowConfidence);
          if (shouldTryStrongOcr) {
            strongOcrAttempted = true;
            const strongOcrPages = forceOcrPreferred ? Math.max(ocrMaxPages, LOCAL_QA_PDF_OCR_MAX_PAGES_DETAILED) : Math.min(24, Math.max(ocrMaxPages + 4, 8));
            const ocrStrongText = this.normalizeParserExtractedText(
              await this.extractPdfTextViaOcr(workingPath, strongOcrPages, {
                psm: 11,
                oem: 1,
                preserveInterwordSpaces: true
              }),
              { forOcr: true, normalizeSpacing: true }
            );
            const ocrStrongQuality = this.assessAttachmentTextQuality(ocrStrongText);
            const shouldPreferStrong = forceOcrPreferred || quality.lowConfidence && !ocrStrongQuality.lowConfidence || quality.koreanHandwritingRisk && !ocrStrongQuality.lowConfidence || ocrStrongQuality.readabilityScore > quality.readabilityScore + 0.04 || ocrStrongText.length > extracted.length + 80;
            if (shouldPreferStrong && ocrStrongText.trim()) {
              extracted = ocrStrongText;
              parser = "ocr-strong";
              quality = ocrStrongQuality;
            } else if (ocrStrongText.trim()) {
              notes.push(`OCR strong kept as secondary candidate (score=${ocrStrongQuality.readabilityScore.toFixed(2)}).`);
            }
          } else if (!preferDetailed && (quality.lowConfidence || quality.koreanHandwritingRisk)) {
            notes.push("fast mode kept strong OCR conservative; use Detailed mode or manual OCR re-parse for higher quality.");
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : "OCR failed";
          notes.push(`OCR failed: ${message}`);
        }
      } else if (shouldTryOcr && !ocrToolsReady) {
        notes.push("OCR tools missing: pdftoppm/tesseract unavailable.");
      }
    } finally {
      if (tempDir) {
        await nodeFs.promises.rm(tempDir, { recursive: true, force: true }).catch(() => {
        });
      }
    }
    if (!extracted.trim()) {
      extracted = this.normalizeParserExtractedText(this.extractPdfFallbackText(binary), {
        forOcr: false,
        normalizeSpacing: true
      });
      parser = "fallback";
      quality = this.assessAttachmentTextQuality(extracted);
      notes.push("fallback literal extraction applied.");
    }
    const clipped = this.clampAttachmentText(
      extracted.trim(),
      preferDetailed ? 32e3 : 2e4
    );
    if (!clipped) {
      return {
        parser,
        notes,
        diagnostics: {
          parserMode,
          modeProfile,
          ocrMaxPages,
          forceOcrPreferred,
          reasonCode: "empty_extraction",
          lowConfidence: true,
          likelyMojibake: quality.likelyMojibake,
          koreanHandwritingRisk: quality.koreanHandwritingRisk,
          readabilityScore: quality.readabilityScore,
          strongOcrAttempted
        },
        content: [
          "PDF attachment received.",
          "\uD30C\uC11C \uC2E4\uD328 \uC0AC\uC720: \uD14D\uC2A4\uD2B8 \uCD94\uCD9C \uC2E0\uB8B0\uB3C4\uAC00 \uB0AE\uAC70\uB098 \uBE44\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.",
          "\uC7AC\uC2DC\uB3C4 \uAC00\uC774\uB4DC: 1) Parser mode\uB97C Detailed\uB85C \uBCC0\uACBD 2) OCR \uC7AC\uD30C\uC2F1 \uC2E4\uD589 3) 300dpi \uC774\uC0C1 \uC6D0\uBCF8/\uD575\uC2EC \uD398\uC774\uC9C0 \uC774\uBBF8\uC9C0 \uCCA8\uBD80"
        ].join("\n")
      };
    }
    if (quality.lowConfidence) {
      notes.push(`final low-confidence text (score=${quality.readabilityScore.toFixed(2)}).`);
    }
    return {
      parser,
      notes,
      diagnostics: {
        parserMode,
        modeProfile,
        ocrMaxPages,
        forceOcrPreferred,
        reasonCode: quality.lowConfidence ? "low_confidence_text" : "ok",
        lowConfidence: quality.lowConfidence,
        likelyMojibake: quality.likelyMojibake,
        koreanHandwritingRisk: quality.koreanHandwritingRisk,
        readabilityScore: quality.readabilityScore,
        strongOcrAttempted
      },
      content: clipped
    };
  }
  async extractImageTextViaOcr(imageAbsolutePath, options) {
    var _a;
    const requestedPsm = Number.parseInt(String((options == null ? void 0 : options.psm) != null ? options.psm : 6), 10);
    const psm = Number.isFinite(requestedPsm) ? Math.max(3, Math.min(13, requestedPsm)) : 6;
    const requestedOem = Number.parseInt(String((options == null ? void 0 : options.oem) != null ? options.oem : ""), 10);
    const oem = Number.isFinite(requestedOem) ? Math.max(0, Math.min(3, requestedOem)) : null;
    const preserveInterwordSpaces = Boolean(options == null ? void 0 : options.preserveInterwordSpaces);
    const commandParts = [
      "tesseract",
      this.shellQuoteArg(imageAbsolutePath),
      "stdout",
      "-l",
      "kor+eng",
      "--psm",
      String(psm)
    ];
    if (oem !== null) {
      commandParts.push("--oem", String(oem));
    }
    if (preserveInterwordSpaces) {
      commandParts.push("-c", "preserve_interword_spaces=1");
    }
    const command = commandParts.join(" ");
    const result = await execAsync(command, { timeout: 45e3, maxBuffer: 10 * 1024 * 1024 });
    return ((_a = result.stdout) != null ? _a : "").trim();
  }
  async extractImageTextWithParserChain(binary, sourceAbsolutePath, fallbackExt = "png") {
    const notes = [];
    let parser = "metadata-only";
    let extracted = "";
    let quality = this.assessAttachmentTextQuality("");
    let workingPath = sourceAbsolutePath;
    let tempDir;
    let strongOcrAttempted = false;
    const parserMode = this.plugin.settings.qaParserMode === "detailed" ? "detailed" : "fast";
    const preferDetailed = parserMode === "detailed";
    const modeProfile = preferDetailed ? "quality-first" : "speed-first";
    notes.push(`parser mode=${parserMode} (${modeProfile})`);
    try {
      if (!workingPath) {
        tempDir = await nodeFs.promises.mkdtemp(
          nodePath.join(nodeOs.tmpdir(), "omni-forge-image-")
        );
        const ext = fallbackExt.replace(/[^A-Za-z0-9]/g, "").toLowerCase() || "png";
        workingPath = nodePath.join(tempDir, `input.${ext}`);
        await nodeFs.promises.writeFile(workingPath, Buffer.from(binary));
      }
      if (await this.canUseShellCommand("tesseract")) {
        try {
          extracted = this.normalizeParserExtractedText(
            await this.extractImageTextViaOcr(workingPath, { psm: 6 }),
            { forOcr: true, normalizeSpacing: true }
          );
          quality = this.assessAttachmentTextQuality(extracted);
          if (extracted.length > 30 && !quality.lowConfidence) {
            parser = "ocr";
          } else {
            notes.push(`OCR 결과 저신뢰/짧음 (score=${quality.readabilityScore.toFixed(2)}).`);
          }
          const shouldTryStrongOcr = preferDetailed ? quality.lowConfidence || quality.koreanHandwritingRisk || quality.likelyMojibake : quality.likelyMojibake || (quality.koreanHandwritingRisk && quality.lowConfidence);
          if (shouldTryStrongOcr) {
            strongOcrAttempted = true;
            const strongText = this.normalizeParserExtractedText(
              await this.extractImageTextViaOcr(workingPath, {
                psm: 11,
                oem: 1,
                preserveInterwordSpaces: true
              }),
              { forOcr: true, normalizeSpacing: true }
            );
            const strongQuality = this.assessAttachmentTextQuality(strongText);
            const shouldPreferStrong = strongText.length > extracted.length + 30 || strongQuality.readabilityScore > quality.readabilityScore + 0.05 || quality.lowConfidence && !strongQuality.lowConfidence || quality.koreanHandwritingRisk && !strongQuality.lowConfidence;
            if (shouldPreferStrong && strongText.trim()) {
              extracted = strongText;
              quality = strongQuality;
              parser = "ocr-strong";
            } else if (strongText.trim()) {
              notes.push(`OCR strong kept as secondary candidate (score=${strongQuality.readabilityScore.toFixed(2)}).`);
            }
          } else if (!preferDetailed && quality.lowConfidence) {
            notes.push("fast mode skipped strong OCR retry; switch to Detailed for handwriting/low-confidence image text.");
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : "image OCR failed";
          notes.push(`OCR \uC2E4\uD328: ${message}`);
        }
      } else {
        notes.push("tesseract \uBBF8\uC124\uCE58: OCR \uC5C6\uC774 \uC774\uBBF8\uC9C0 \uC790\uCCB4 \uCEE8\uD14D\uC2A4\uD2B8\uB9CC \uC0AC\uC6A9\uD569\uB2C8\uB2E4.");
      }
    } finally {
      if (tempDir) {
        await nodeFs.promises.rm(tempDir, { recursive: true, force: true }).catch(() => {
        });
      }
    }
    const clipped = this.clampAttachmentText(
      extracted.trim(),
      preferDetailed ? 18e3 : 1e4
    );
    return {
      parser,
      notes,
      diagnostics: {
        parserMode,
        modeProfile,
        reasonCode: clipped ? quality.lowConfidence ? "low_confidence_text" : "ok" : "empty_extraction",
        lowConfidence: quality.lowConfidence,
        likelyMojibake: quality.likelyMojibake,
        koreanHandwritingRisk: quality.koreanHandwritingRisk,
        readabilityScore: quality.readabilityScore,
        strongOcrAttempted
      },
      content: clipped
    };
  }
  async readVaultFileAsAttachment(file) {
    const ext = file.extension.toLowerCase();
    if (this.isImageExt(ext)) {
      const adapter = this.app.vault.adapter;
      if (typeof adapter.readBinary !== "function") {
        return null;
      }
      const binary = await adapter.readBinary(file.path);
      if (binary.byteLength > 4 * 1024 * 1024) {
        return null;
      }
      const absolutePath = this.resolveVaultAbsolutePath(file.path);
      const parsed = await this.extractImageTextWithParserChain(binary, absolutePath, ext);
      return {
        kind: "image",
        label: this.normalizeAttachmentLabel(file.name, file.path),
        path: file.path,
        imageBase64: this.arrayBufferToBase64(binary),
        mimeType: this.attachmentMimeFromExt(ext),
        content: parsed.content ? [
          `Image attachment: ${file.name}`,
          `Parser: ${parsed.parser}`,
          ...parsed.notes.map((note) => `- ${note}`),
          "---",
          parsed.content
        ].join("\n") : void 0
      };
    }
    if (this.isPdfExt(ext)) {
      if (!this.plugin.settings.qaPdfAttachmentEnabled) {
        return null;
      }
      const adapter = this.app.vault.adapter;
      if (typeof adapter.readBinary !== "function") {
        return {
          kind: "pdf",
          label: this.normalizeAttachmentLabel(file.name, file.path),
          path: file.path,
          content: [
            `PDF attachment: ${file.name}`,
            "PDF \uBCF8\uBB38 \uCD94\uCD9C \uC2E4\uD328: readBinary API unavailable."
          ].join("\n")
        };
      }
      const binary = await adapter.readBinary(file.path);
      const absolutePath = this.resolveVaultAbsolutePath(file.path);
      const parsed = await this.extractPdfTextWithParserChain(binary, absolutePath);
      return {
        kind: "pdf",
        label: this.normalizeAttachmentLabel(file.name, file.path),
        path: file.path,
        content: [
          `PDF attachment: ${file.name}`,
          `Parser: ${parsed.parser}`,
          ...parsed.notes.map((note) => `- ${note}`),
          "---",
          parsed.content
        ].join("\n")
      };
    }
    const text = await this.app.vault.cachedRead(file);
    const trimmed = this.clampAttachmentText(text.trim());
    if (!trimmed) {
      return null;
    }
    return {
      kind: "text",
      label: this.normalizeAttachmentLabel(file.name, file.path),
      path: file.path,
      content: trimmed
    };
  }
  extractDropTextCandidates(text) {
    const candidates = /* @__PURE__ */ new Set();
    const wikiRegex = /\[\[([^\]]+)\]\]/g;
    let match = wikiRegex.exec(text);
    while (match) {
      candidates.add(match[1]);
      match = wikiRegex.exec(text);
    }
    for (const line of text.split(/\r?\n/)) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.length > 240) {
        continue;
      }
      candidates.add(trimmed);
    }
    return [...candidates];
  }
  resolveDroppedVaultFile(candidate) {
    var _a, _b, _c, _d;
    let token = candidate.trim();
    if (!token) {
      return null;
    }
    if (token.startsWith("[[") && token.endsWith("]]")) {
      token = token.slice(2, -2);
    }
    token = (_c = (_b = (_a = token.split("|")[0]) == null ? void 0 : _a.split("#")[0]) == null ? void 0 : _b.trim()) != null ? _c : "";
    if (!token) {
      return null;
    }
    const linked = this.app.metadataCache.getFirstLinkpathDest(
      token,
      (_d = this.threadPath) != null ? _d : ""
    );
    if (linked instanceof import_obsidian4.TFile) {
      return linked;
    }
    const normalized = (0, import_obsidian4.normalizePath)(token);
    const direct = this.app.vault.getAbstractFileByPath(normalized);
    if (direct instanceof import_obsidian4.TFile) {
      return direct;
    }
    if (!normalized.toLowerCase().endsWith(".md")) {
      const withMd = this.app.vault.getAbstractFileByPath(`${normalized}.md`);
      if (withMd instanceof import_obsidian4.TFile) {
        return withMd;
      }
    }
    return null;
  }
  async readExternalFileAsAttachment(file, context = {}) {
    var _a;
    const absolutePath = this.extractDesktopAbsolutePathFromFile(file);
    const ext = (_a = file.name.toLowerCase().split(".").pop()) != null ? _a : "";
    if (this.isHwpExt(ext)) {
      if (this.isHwpxExt(ext)) {
        try {
          const binary = await file.arrayBuffer();
          const extracted = this.clampAttachmentText(await this.tryExtractHwpxText(binary, file.name), 24e3);
          if (extracted) {
            const mirroredPath2 = await this.persistBinaryAttachmentToIngest(file.name, "hwpx", "document", binary);
            const parserSummary = [
              `HWPX attachment: ${file.name}`,
              "Parser: hwpx-xml",
              "- route: direct HWPX(XML) extraction",
              "- fallback: HWP/PDF guide when extraction fails",
              "---",
              extracted
            ].join("\n");
            return {
              kind: "text",
              label: this.normalizeAttachmentLabel(`${file.name} (hwpx.md)`, `hwpx-${Date.now()}`),
              path: mirroredPath2 || absolutePath,
              content: parserSummary
            };
          }
        } catch (e) {
        }
      }
      const remainingCount = Math.max(0, Number(context.remainingHwpCount || 0));
      return await this.convertHwpWithUserChoice(file, remainingCount);
    }
    if (file.type.startsWith("image/") || this.isImageExt(ext)) {
      if (file.size > 4 * 1024 * 1024) {
        return null;
      }
      const binary = await file.arrayBuffer();
      const mirroredPath2 = await this.persistBinaryAttachmentToIngest(
        file.name,
        ext || "png",
        "image",
        binary
      );
      const mirroredAbsolutePath = mirroredPath2 ? this.resolveVaultAbsolutePath(mirroredPath2) : void 0;
      const parsed = await this.extractImageTextWithParserChain(
        binary,
        absolutePath || mirroredAbsolutePath,
        ext || "png"
      );
      return {
        kind: "image",
        label: this.normalizeAttachmentLabel(file.name, `image-${Date.now()}`),
        imageBase64: this.arrayBufferToBase64(binary),
        mimeType: file.type || this.attachmentMimeFromExt(ext),
        path: mirroredPath2 || absolutePath,
        content: parsed.content ? [
          `Image attachment: ${file.name}`,
          `Parser: ${parsed.parser}`,
          ...parsed.notes.map((note) => `- ${note}`),
          "---",
          parsed.content
        ].join("\n") : void 0
      };
    }
    if (file.type === "application/pdf" || this.isPdfExt(ext)) {
      if (!this.plugin.settings.qaPdfAttachmentEnabled) {
        return null;
      }
      if (file.size > 20 * 1024 * 1024) {
        return null;
      }
      const binary = await file.arrayBuffer();
      const mirroredPath2 = await this.persistBinaryAttachmentToIngest(
        file.name,
        ext || "pdf",
        "pdf",
        binary
      );
      const mirroredAbsolutePath = mirroredPath2 ? this.resolveVaultAbsolutePath(mirroredPath2) : void 0;
      const parsed = await this.extractPdfTextWithParserChain(
        binary,
        absolutePath || mirroredAbsolutePath
      );
      return {
        kind: "pdf",
        label: this.normalizeAttachmentLabel(file.name, `pdf-${Date.now()}`),
        path: mirroredPath2 || absolutePath,
        content: [
          `PDF attachment: ${file.name}`,
          `Parser: ${parsed.parser}`,
          ...parsed.notes.map((note) => `- ${note}`),
          "---",
          parsed.content
        ].join("\n")
      };
    }
    if (!this.isLikelyTextFile(file)) {
      return null;
    }
    if (file.size > 2 * 1024 * 1024) {
      return null;
    }
    const text = await file.text();
    const content = this.clampAttachmentText(text.trim());
    if (!content) {
      return null;
    }
    const mirroredPath = await this.persistTextAttachmentToIngest(
      file.name,
      ext || "txt",
      "text",
      content
    );
    return {
      kind: "text",
      label: this.normalizeAttachmentLabel(file.name, `document-${Date.now()}`),
      path: mirroredPath || absolutePath,
      content
    };
  }
  extractDesktopAbsolutePathFromFile(file) {
    var _a;
    const raw = ((_a = file.path) != null ? _a : "").trim();
    if (!raw) {
      return void 0;
    }
    if (nodePath.isAbsolute(raw) || /^[A-Za-z]:[\\/]/.test(raw)) {
      return nodePath.resolve(raw);
    }
    return void 0;
  }
  async collectAttachmentsFromDrop(dataTransfer) {
    var _a;
    const collected = [];
    const seen = /* @__PURE__ */ new Set();
    const pushItem = (item) => {
      if (!item) {
        return;
      }
      const key = this.attachmentKey(item);
      if (seen.has(key)) {
        return;
      }
      seen.add(key);
      collected.push(item);
    };
    const files = Array.from((_a = dataTransfer.files) != null ? _a : []);
    const hwpTotal = files.filter((file) => {
      var _a2;
      return this.isHwpExt((_a2 = file.name.toLowerCase().split(".").pop()) != null ? _a2 : "");
    }).length;
    let hwpSeen = 0;
    for (const file of files) {
      if (collected.length >= LOCAL_QA_MAX_ATTACHMENTS) {
        break;
      }
      try {
        const ext = file.name.toLowerCase().split(".").pop() || "";
        const remainingHwpCount = this.isHwpExt(ext) ? Math.max(0, hwpTotal - hwpSeen - 1) : 0;
        if (this.isHwpExt(ext)) {
          hwpSeen += 1;
        }
        pushItem(await this.readExternalFileAsAttachment(file, { remainingHwpCount }));
      } catch (e) {
      }
    }
    const textPayloads = [
      dataTransfer.getData("text/plain"),
      dataTransfer.getData("text/uri-list")
    ].map((value) => value.trim()).filter((value) => value.length > 0);
    for (const payload of textPayloads) {
      if (collected.length >= LOCAL_QA_MAX_ATTACHMENTS) {
        break;
      }
      for (const candidate of this.extractDropTextCandidates(payload)) {
        if (collected.length >= LOCAL_QA_MAX_ATTACHMENTS) {
          break;
        }
        const file = this.resolveDroppedVaultFile(candidate);
        if (!(file instanceof import_obsidian4.TFile)) {
          continue;
        }
        try {
          pushItem(await this.readVaultFileAsAttachment(file));
        } catch (e) {
        }
      }
    }
    return collected.slice(0, LOCAL_QA_MAX_ATTACHMENTS);
  }
  async collectAttachmentsFromClipboard(dataTransfer) {
    var _a, _b;
    const collected = [];
    const filesFromItems = [];
    const items = Array.from((_a = dataTransfer.items) != null ? _a : []);
    for (const item of items) {
      if (item.kind !== "file") {
        continue;
      }
      const file = item.getAsFile();
      if (file) {
        filesFromItems.push(file);
      }
    }
    const primaryFiles = filesFromItems.length > 0 ? filesFromItems : Array.from((_b = dataTransfer.files) != null ? _b : []);
    const hwpTotal = primaryFiles.filter((file) => this.isHwpExt(file.name.toLowerCase().split(".").pop() || "")).length;
    let hwpSeen = 0;
    for (const file of primaryFiles) {
      if (collected.length >= LOCAL_QA_MAX_ATTACHMENTS) {
        break;
      }
      try {
        const ext = file.name.toLowerCase().split(".").pop() || "";
        const remainingHwpCount = this.isHwpExt(ext) ? Math.max(0, hwpTotal - hwpSeen - 1) : 0;
        if (this.isHwpExt(ext)) {
          hwpSeen += 1;
        }
        const parsed = await this.readExternalFileAsAttachment(file, { remainingHwpCount });
        if (parsed) {
          collected.push(parsed);
        }
      } catch (e) {
      }
    }
    return collected.slice(0, LOCAL_QA_MAX_ATTACHMENTS);
  }
  mergePendingAttachments(incoming) {
    if (incoming.length === 0) {
      return;
    }
    const merged = [];
    const seen = /* @__PURE__ */ new Set();
    for (const item of [...this.pendingAttachments, ...incoming]) {
      const key = this.attachmentKey(item);
      if (seen.has(key)) {
        continue;
      }
      seen.add(key);
      merged.push(item);
      if (merged.length >= LOCAL_QA_MAX_ATTACHMENTS) {
        break;
      }
    }
    this.pendingAttachments = merged;
    this.refreshAttachmentStatus();
    void this.refreshScopeLabel();
  }
  consumePendingAttachments() {
    const out = [...this.pendingAttachments];
    this.pendingAttachments = [];
    this.refreshAttachmentStatus();
    void this.refreshScopeLabel();
    return out;
  }
  removePendingAttachmentAt(index) {
    if (index < 0 || index >= this.pendingAttachments.length) {
      return;
    }
    this.pendingAttachments = this.pendingAttachments.filter((_, itemIndex) => itemIndex !== index);
    this.refreshAttachmentStatus();
    void this.refreshScopeLabel();
  }
  refreshAttachmentStatus() {
    if (!this.attachmentStatusEl) {
      return;
    }
    this.attachmentStatusEl.empty();
    if (this.pendingAttachments.length === 0) {
      this.attachmentStatusEl.addClass("is-empty");
      this.attachmentStatusEl.createSpan({
        text: `\uCCA8\uBD80 \uC5C6\uC74C (\uCD5C\uB300 ${LOCAL_QA_MAX_ATTACHMENTS}\uAC1C): \uB4DC\uB798\uADF8/\uC5C5\uB85C\uB4DC/\uBD99\uC5EC\uB123\uAE30(Ctrl/Cmd+V) \uC0AC\uC6A9 \uAC00\uB2A5`
      });
      return;
    }
    this.attachmentStatusEl.removeClass("is-empty");
    const head = this.attachmentStatusEl.createDiv({
      cls: "omni-forge-chat-attachment-head"
    });
    head.createSpan({
      text: `\uCCA8\uBD80 ${this.pendingAttachments.length}/${LOCAL_QA_MAX_ATTACHMENTS} (\uB2E4\uC74C \uC804\uC1A1\uC5D0 \uD3EC\uD568)`
    });
    const clearButton = head.createEl("button", {
      text: "\uCCA8\uBD80 \uBE44\uC6B0\uAE30"
    });
    clearButton.addClass("omni-forge-chat-drop-clear");
    clearButton.onclick = () => {
      this.pendingAttachments = [];
      this.refreshAttachmentStatus();
      void this.refreshScopeLabel();
    };
    const list = this.attachmentStatusEl.createDiv({
      cls: "omni-forge-chat-attachment-list"
    });
    this.pendingAttachments.forEach((item, index) => {
      var _a;
      const card = list.createDiv({ cls: "omni-forge-chat-attachment-item" });
      if (item.kind === "image" && item.imageBase64) {
        const image = card.createEl("img", { cls: "omni-forge-chat-attachment-thumb" });
        image.src = `data:${item.mimeType || "image/png"};base64,${item.imageBase64}`;
        image.alt = item.label || `image-${index + 1}`;
      } else {
        card.createDiv({
          cls: "omni-forge-chat-attachment-file-badge",
          text: "FILE"
        });
      }
      const meta = card.createDiv({ cls: "omni-forge-chat-attachment-meta" });
      meta.createDiv({
        cls: "omni-forge-chat-attachment-title",
        text: item.label || item.path || `attachment-${index + 1}`
      });
      meta.createDiv({
        cls: "omni-forge-chat-attachment-sub",
        text: ((_a = item.path) == null ? void 0 : _a.trim()) || (item.kind === "image" ? "image attachment" : item.kind === "pdf" ? "pdf attachment" : "document attachment")
      });
      const removeButton = card.createEl("button", {
        text: "\uC81C\uAC70"
      });
      removeButton.addClass("omni-forge-chat-attachment-remove");
      removeButton.onclick = () => {
        this.removePendingAttachmentAt(index);
      };
    });
  }
  buildParserMarkdownFromAttachment(item) {
    const sourceLabel = (item.label || item.path || "attachment").trim();
    const safeLabel = sourceLabel.replace(/"/g, '\\"');
    const safePath = (item.path || "").trim().replace(/"/g, '\\"');
    const body = item.content && item.content.trim() ? item.content.trim() : item.kind === "image" ? "이미지 파일은 OCR/파서 결과가 없으면 텍스트 본문이 비어 있을 수 있습니다." : "텍스트 추출 결과가 비어 있습니다.";
    return [
      "---",
      "parser_ingest: true",
      `source_kind: ${item.kind}`,
      `source_label: "${safeLabel}"`,
      safePath ? `source_path: "${safePath}"` : 'source_path: "(none)"',
      `created_at: ${new Date().toISOString()}`,
      "---",
      "",
      `# Parsed: ${sourceLabel}`,
      "",
      body
    ].join("\n");
  }
  async convertAttachmentsToParserMarkdown(attachments, sourceLabel) {
    const created = [];
    const createdPaths = [];
    for (const item of attachments.slice(0, LOCAL_QA_MAX_ATTACHMENTS)) {
      const markdown = this.buildParserMarkdownFromAttachment(item);
      const rawName = item.label || item.path || `parser-${Date.now()}`;
      const safeName = this.sanitizeIngestFileName(rawName, "parser-document", "md");
      const targetPath = await this.persistTextAttachmentToIngest(
        safeName,
        "md",
        "parser",
        markdown
      );
      if (!targetPath) {
        continue;
      }
      createdPaths.push(targetPath);
      created.push({
        kind: "text",
        label: `${item.label || safeName} (parser.md)`,
        path: targetPath,
        content: this.clampAttachmentText(markdown)
      });
    }
    if (created.length === 0) {
      new import_obsidian4.Notice("파서 변환(.md) 결과를 만들지 못했습니다.");
      return [];
    }
    this.mergePendingAttachments(created);
    this.pushMessage({
      role: "system",
      text: `파서 인게스트(${sourceLabel}) 완료: ${created.length}개 .md 생성`,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    new import_obsidian4.Notice(`Parser ingest: ${created.length}개 .md 생성됨`);
    if (createdPaths.length > 0) {
      this.pushMessage({
        role: "system",
        text: `생성 경로 예시: ${createdPaths.slice(0, 3).join(", ")}${createdPaths.length > 3 ? " ..." : ""}`,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
    return created;
  }
  async openParserIngestPicker() {
    const input = document.createElement("input");
    input.type = "file";
    input.multiple = true;
    input.accept = ".md,.txt,.json,.yml,.yaml,.csv,.ts,.js,.py,.java,.go,.rs,.c,.cpp,.html,.css,.pdf,.hwp,.hwpx,image/*";
    input.style.display = "none";
    document.body.appendChild(input);
    input.onchange = async () => {
      var _a;
      try {
        const files = Array.from((_a = input.files) != null ? _a : []);
        this.hwpChoiceApplyAllEnabled = false;
        this.hwpChoiceApplyAll = null;
        const hwpTotal = files.filter((file) => this.isHwpExt(file.name.toLowerCase().split(".").pop() || "")).length;
        let hwpSeen = 0;
        const attachments = [];
        for (const file of files) {
          if (attachments.length >= LOCAL_QA_MAX_ATTACHMENTS) {
            break;
          }
          try {
            const ext = file.name.toLowerCase().split(".").pop() || "";
            const remainingHwpCount = this.isHwpExt(ext) ? Math.max(0, hwpTotal - hwpSeen - 1) : 0;
            if (this.isHwpExt(ext)) {
              hwpSeen += 1;
            }
            const parsed = await this.readExternalFileAsAttachment(file, { remainingHwpCount });
            if (parsed) {
              attachments.push(parsed);
            }
          } catch (e) {
          }
        }
        if (attachments.length === 0) {
          new import_obsidian4.Notice("파서 인게스트 가능한 파일을 찾지 못했습니다.");
          return;
        }
        await this.convertAttachmentsToParserMarkdown(attachments, "picker");
      } finally {
        input.remove();
      }
    };
    input.click();
  }
  async handleParserDrop(event, dropZone) {
    event.preventDefault();
    this.hwpChoiceApplyAllEnabled = false;
    this.hwpChoiceApplyAll = null;
    dropZone.removeClass("omni-forge-chat-drop-target-active");
    const dataTransfer = event.dataTransfer;
    if (!dataTransfer) {
      return;
    }
    const attachments = await this.collectAttachmentsFromDrop(dataTransfer);
    if (attachments.length === 0) {
      new import_obsidian4.Notice("드롭한 항목에서 파서 인게스트 가능한 파일을 찾지 못했습니다.");
      return;
    }
    await this.convertAttachmentsToParserMarkdown(attachments, "drop");
  }
  async openAttachmentPicker() {
    const input = document.createElement("input");
    input.type = "file";
    input.multiple = true;
    input.accept = ".md,.txt,.json,.yml,.yaml,.csv,.ts,.js,.py,.java,.go,.rs,.c,.cpp,.html,.css,.pdf,.hwp,.hwpx,image/*";
    input.style.display = "none";
    document.body.appendChild(input);
    input.onchange = async () => {
      var _a;
      try {
        const files = Array.from((_a = input.files) != null ? _a : []);
        this.hwpChoiceApplyAllEnabled = false;
        this.hwpChoiceApplyAll = null;
        const hwpTotal = files.filter((file) => this.isHwpExt(file.name.toLowerCase().split(".").pop() || "")).length;
        let hwpSeen = 0;
        const attachments = [];
        for (const file of files) {
          if (attachments.length + this.pendingAttachments.length >= LOCAL_QA_MAX_ATTACHMENTS) {
            break;
          }
          try {
            const ext = file.name.toLowerCase().split(".").pop() || "";
            const remainingHwpCount = this.isHwpExt(ext) ? Math.max(0, hwpTotal - hwpSeen - 1) : 0;
            if (this.isHwpExt(ext)) {
              hwpSeen += 1;
            }
            const parsed = await this.readExternalFileAsAttachment(file, { remainingHwpCount });
            if (parsed) {
              attachments.push(parsed);
            }
          } catch (e) {
          }
        }
        if (attachments.length === 0) {
          new import_obsidian4.Notice("\uCCA8\uBD80\uD560 \uC218 \uC788\uB294 \uD30C\uC77C(\uD14D\uC2A4\uD2B8/\uC774\uBBF8\uC9C0/PDF)\uC744 \uCC3E\uC9C0 \uBABB\uD588\uC2B5\uB2C8\uB2E4.");
        } else {
          this.mergePendingAttachments(attachments);
          this.pushMessage({
            role: "system",
            text: `\uCCA8\uBD80 \uCD94\uAC00\uB428: ${attachments.length}\uAC1C (\uD604\uC7AC ${this.pendingAttachments.length}/${LOCAL_QA_MAX_ATTACHMENTS})`,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
        }
      } finally {
        input.remove();
      }
    };
    input.click();
  }
  async handleChatDrop(event, dropZone) {
    event.preventDefault();
    this.hwpChoiceApplyAllEnabled = false;
    this.hwpChoiceApplyAll = null;
    dropZone.removeClass("omni-forge-chat-drop-active");
    const dataTransfer = event.dataTransfer;
    if (!dataTransfer) {
      return;
    }
    const attachments = await this.collectAttachmentsFromDrop(dataTransfer);
    if (attachments.length === 0) {
      new import_obsidian4.Notice("\uB4DC\uB798\uADF8\uD55C \uD56D\uBAA9\uC5D0\uC11C \uC77D\uC744 \uC218 \uC788\uB294 \uD14D\uC2A4\uD2B8/\uC774\uBBF8\uC9C0/PDF\uB97C \uCC3E\uC9C0 \uBABB\uD588\uC2B5\uB2C8\uB2E4.");
      return;
    }
    this.mergePendingAttachments(attachments);
    this.pushMessage({
      role: "system",
      text: `\uB4DC\uB798\uADF8 \uCCA8\uBD80 \uCD94\uAC00\uB428: ${attachments.length}\uAC1C (\uD604\uC7AC ${this.pendingAttachments.length}/${LOCAL_QA_MAX_ATTACHMENTS})`,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  async handleChatPaste(event) {
    var _a, _b, _c;
    this.hwpChoiceApplyAllEnabled = false;
    this.hwpChoiceApplyAll = null;
    const dataTransfer = event.clipboardData;
    if (!dataTransfer) {
      return;
    }
    const hasFilePayload = Array.from((_a = dataTransfer.items) != null ? _a : []).some((item) => item.kind === "file") || ((_c = (_b = dataTransfer.files) == null ? void 0 : _b.length) != null ? _c : 0) > 0;
    if (!hasFilePayload) {
      return;
    }
    event.preventDefault();
    const attachments = await this.collectAttachmentsFromClipboard(dataTransfer);
    if (attachments.length === 0) {
      new import_obsidian4.Notice("\uBD99\uC5EC\uB123\uC740 \uB370\uC774\uD130\uC5D0\uC11C \uCCA8\uBD80 \uAC00\uB2A5\uD55C \uD30C\uC77C/\uC774\uBBF8\uC9C0\uB97C \uCC3E\uC9C0 \uBABB\uD588\uC2B5\uB2C8\uB2E4.");
      return;
    }
    this.mergePendingAttachments(attachments);
    this.pushMessage({
      role: "system",
      text: `\uBD99\uC5EC\uB123\uAE30 \uCCA8\uBD80 \uCD94\uAC00\uB428: ${attachments.length}\uAC1C (\uD604\uC7AC ${this.pendingAttachments.length}/${LOCAL_QA_MAX_ATTACHMENTS})`,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  formatTime(iso) {
    const date = new Date(iso);
    const hh = String(date.getHours()).padStart(2, "0");
    const mm = String(date.getMinutes()).padStart(2, "0");
    const ss = String(date.getSeconds()).padStart(2, "0");
    return `${hh}:${mm}:${ss}`;
  }
  formatThinkingStage(stage) {
    switch (stage) {
      case "retrieval":
        return "RETRIEVE";
      case "generation":
        return "GENERATE";
      case "thinking":
        return "THINK";
      case "warning":
        return "WARN";
      case "error":
        return "ERROR";
      default:
        return "INFO";
    }
  }
  buildThinkingTranscriptText(timeline, modelThinking) {
    const lines = timeline.map(
      (event) => `- [${this.formatTime(event.timestamp)}] [${this.formatThinkingStage(event.stage)}] ${event.message}`
    );
    const trimmedThinking = modelThinking.trim();
    if (!trimmedThinking) {
      return lines.join("\n");
    }
    return [
      ...lines,
      "",
      "Model thinking (raw):",
      trimmedThinking
    ].join("\n");
  }
  scheduleStreamRender(delayMs = 80) {
    if (this.streamRenderTimer !== null) {
      return;
    }
    this.streamRenderTimer = window.setTimeout(() => {
      this.streamRenderTimer = null;
      this.renderMessages();
    }, delayMs);
  }
  getVaultBasePathForChatView() {
    const adapter = this.app.vault.adapter;
    if (typeof adapter.getBasePath !== "function") {
      return null;
    }
    const base = adapter.getBasePath();
    if (!base || typeof base !== "string") {
      return null;
    }
    return nodePath.resolve(base);
  }
  resolveVisibleMarkdownFile() {
    const active = this.app.workspace.getActiveFile();
    if (active instanceof import_obsidian4.TFile && active.extension === "md") {
      return active;
    }
    const activeLeaf = this.app.workspace.activeLeaf;
    if ((activeLeaf == null ? void 0 : activeLeaf.view) instanceof import_obsidian4.MarkdownView) {
      const file = activeLeaf.view.file;
      if (file instanceof import_obsidian4.TFile && file.extension === "md") {
        return file;
      }
    }
    if (this.lastKnownOpenMarkdownPath) {
      const cached = this.app.vault.getAbstractFileByPath(this.lastKnownOpenMarkdownPath);
      if (cached instanceof import_obsidian4.TFile && cached.extension === "md") {
        return cached;
      }
    }
    return null;
  }
  resolveOpenMarkdownViewByPath(filePath) {
    const normalized = (0, import_obsidian4.normalizePath)((filePath != null ? filePath : "").trim());
    if (!normalized) {
      return null;
    }
    const leaves = this.app.workspace.getLeavesOfType("markdown");
    for (const leaf of leaves) {
      const view = leaf.view;
      if (!(view instanceof import_obsidian4.MarkdownView)) {
        continue;
      }
      const file = view.file;
      if (!(file instanceof import_obsidian4.TFile) || file.extension !== "md") {
        continue;
      }
      if (file.path !== normalized) {
        continue;
      }
      return view;
    }
    return null;
  }
  captureOpenSelectionSnapshot(openFilePath) {
    const normalized = (0, import_obsidian4.normalizePath)((openFilePath != null ? openFilePath : "").trim());
    if (!normalized) {
      return null;
    }
    const view = this.resolveOpenMarkdownViewByPath(normalized);
    if (!(view instanceof import_obsidian4.MarkdownView) || !view.editor) {
      return null;
    }
    const editor = view.editor;
    if (!editor.somethingSelected()) {
      return null;
    }
    const from = editor.getCursor("from");
    const to = editor.getCursor("to");
    const fromOffset = editor.posToOffset(from);
    const toOffset = editor.posToOffset(to);
    if (!Number.isFinite(fromOffset) || !Number.isFinite(toOffset)) {
      return null;
    }
    if (toOffset <= fromOffset) {
      return null;
    }
    const selectedText = editor.getRange(from, to);
    if (!selectedText) {
      return null;
    }
    return {
      filePath: normalized,
      fromOffset: Math.floor(fromOffset),
      toOffset: Math.floor(toOffset),
      selectedText,
      capturedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  decodeChatLinkValue(raw) {
    const trimmed = (raw != null ? raw : "").trim();
    if (!trimmed) {
      return "";
    }
    try {
      return decodeURIComponent(trimmed);
    } catch (e) {
      return trimmed;
    }
  }
  resolveVaultFileFromChatLink(raw) {
    const decoded = this.decodeChatLinkValue(raw);
    if (!decoded || /^https?:\/\//i.test(decoded) || /^obsidian:\/\//i.test(decoded)) {
      return null;
    }
    let candidate = decoded;
    if (/^file:\/\//i.test(candidate)) {
      candidate = candidate.replace(/^file:\/\//i, "");
    }
    candidate = candidate.trim();
    if (!candidate) {
      return null;
    }
    const normalized = (0, import_obsidian4.normalizePath)(candidate);
    const direct = this.app.vault.getAbstractFileByPath(normalized);
    if (direct instanceof import_obsidian4.TFile) {
      return direct;
    }
    if (!normalized.toLowerCase().endsWith(".md")) {
      const withMd = this.app.vault.getAbstractFileByPath(`${normalized}.md`);
      if (withMd instanceof import_obsidian4.TFile) {
        return withMd;
      }
    }
    const vaultBase = this.getVaultBasePathForChatView();
    if (vaultBase && (nodePath.isAbsolute(candidate) || /^[A-Za-z]:[\\/]/.test(candidate))) {
      const absolute = nodePath.resolve(candidate);
      const relative2 = nodePath.relative(vaultBase, absolute);
      if (relative2 && !relative2.startsWith("..") && !nodePath.isAbsolute(relative2)) {
        const vaultPath = (0, import_obsidian4.normalizePath)(relative2);
        const fromAbsolute = this.app.vault.getAbstractFileByPath(vaultPath);
        if (fromAbsolute instanceof import_obsidian4.TFile) {
          return fromAbsolute;
        }
      }
    }
    return null;
  }
  buildFileUrlFromAbsolutePath(rawPath) {
    const absolute = nodePath.resolve(rawPath);
    if (!absolute) {
      return null;
    }
    const segments = absolute.split(nodePath.sep).map((segment) => encodeURIComponent(segment));
    if (/^[A-Za-z]:[\\/]/.test(absolute)) {
      return `file:///${segments.join("/")}`;
    }
    return `file://${segments.join("/")}`;
  }
  async openLinkWithDesktopShell(url) {
    var _a, _b;
    try {
      const win = window;
      const electron = typeof win.require === "function" ? win.require("electron") : null;
      if ((_a = electron == null ? void 0 : electron.shell) == null ? void 0 : _a.openExternal) {
        await electron.shell.openExternal(url);
        return true;
      }
      if (((_b = electron == null ? void 0 : electron.shell) == null ? void 0 : _b.openPath) && /^file:\/\//i.test(url)) {
        const path = decodeURIComponent(url.replace(/^file:\/\//i, ""));
        const result = await electron.shell.openPath(path);
        return !result;
      }
      window.open(url, "_blank");
      return true;
    } catch (e) {
      try {
        window.open(url, "_blank");
        return true;
      } catch (e2) {
        return false;
      }
    }
  }
  async tryOpenExternalFromChatLink(raw) {
    const decoded = this.decodeChatLinkValue(raw);
    if (!decoded) {
      return false;
    }
    try {
      if (/^obsidian:\/\//i.test(decoded)) {
        return await this.openLinkWithDesktopShell(decoded);
      }
      if (/^https?:\/\//i.test(decoded)) {
        return await this.openLinkWithDesktopShell(decoded);
      }
      let pathLike = decoded;
      if (/^file:\/\//i.test(pathLike)) {
        pathLike = pathLike.replace(/^file:\/\//i, "");
      }
      pathLike = pathLike.trim();
      if (!pathLike) {
        return false;
      }
      if (!(nodePath.isAbsolute(pathLike) || /^[A-Za-z]:[\\/]/.test(pathLike))) {
        return false;
      }
      const fileUrl = this.buildFileUrlFromAbsolutePath(pathLike);
      if (!fileUrl) {
        return false;
      }
      return await this.openLinkWithDesktopShell(fileUrl);
    } catch (e) {
      return false;
    }
  }
  bindChatMarkdownLinkHandlers(container) {
    container.addEventListener("click", (event) => {
      var _a, _b, _c;
      const target = event.target;
      const anchor = target == null ? void 0 : target.closest("a");
      if (!(anchor instanceof HTMLAnchorElement)) {
        const image = target == null ? void 0 : target.closest("img");
        if (!(image instanceof HTMLImageElement)) {
          return;
        }
        const src = ((_a = image.getAttribute("src")) != null ? _a : "").trim();
        if (!src) {
          return;
        }
        const internalImageFile = this.resolveVaultFileFromChatLink(src);
        const shouldInterceptImage = internalImageFile instanceof import_obsidian4.TFile || /^https?:\/\//i.test(src) || /^obsidian:\/\//i.test(src) || /^file:\/\//i.test(src) || nodePath.isAbsolute(src) || /^[A-Za-z]:[\\/]/.test(src);
        if (!shouldInterceptImage) {
          return;
        }
        event.preventDefault();
        event.stopPropagation();
        void (async () => {
          if (internalImageFile instanceof import_obsidian4.TFile) {
            await this.app.workspace.getLeaf(true).openFile(internalImageFile);
            return;
          }
          await this.tryOpenExternalFromChatLink(src);
        })();
        return;
      }
      const candidates = [
        (_b = anchor.getAttribute("href")) != null ? _b : "",
        (_c = anchor.textContent) != null ? _c : ""
      ].map((item) => item.trim()).filter((item) => item.length > 0);
      if (candidates.length === 0) {
        return;
      }
      const shouldIntercept = candidates.some((candidate) => {
        const decoded = this.decodeChatLinkValue(candidate);
        if (!decoded || decoded === "#") {
          return false;
        }
        if (/^https?:\/\//i.test(decoded) || /^obsidian:\/\//i.test(decoded) || /^file:\/\//i.test(decoded) || nodePath.isAbsolute(decoded) || /^[A-Za-z]:[\\/]/.test(decoded)) {
          return true;
        }
        return this.resolveVaultFileFromChatLink(decoded) instanceof import_obsidian4.TFile;
      });
      if (!shouldIntercept) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      const openInternal = async () => {
        for (const candidate of candidates) {
          const file = this.resolveVaultFileFromChatLink(candidate);
          if (!(file instanceof import_obsidian4.TFile)) {
            continue;
          }
          await this.app.workspace.getLeaf(true).openFile(file);
          return true;
        }
        return false;
      };
      const openExternalPath = async () => {
        for (const candidate of candidates) {
          if (await this.tryOpenExternalFromChatLink(candidate)) {
            return true;
          }
        }
        return false;
      };
      void (async () => {
        if (await openInternal()) {
          return;
        }
        if (await openExternalPath()) {
          return;
        }
      })();
    });
  }
  renderMarkdownBody(container, markdown, sourcePath, version) {
    container.empty();
    void import_obsidian4.MarkdownRenderer.renderMarkdown(markdown, container, sourcePath, this).catch(() => {
      container.setText(markdown);
    }).finally(() => {
      this.bindChatMarkdownLinkHandlers(container);
      if (version === this.renderVersion) {
        this.threadEl.scrollTop = this.threadEl.scrollHeight;
      }
    });
  }
  renderThinkingCard(parent, message) {
    var _a, _b;
    const timeline = (_a = message.timeline) != null ? _a : [];
    const latest = timeline.length > 0 ? timeline[timeline.length - 1] : void 0;
    const panel = parent.createEl("details", { cls: "omni-forge-chat-thinking-panel" });
    panel.open = false;
    const head = panel.createEl("summary", { cls: "omni-forge-chat-thinking-head" });
    const summaryText = latest ? `Thinking timeline \xB7 ${timeline.length} events \xB7 ${this.formatThinkingStage(latest.stage)}` : "Thinking timeline";
    head.createDiv({
      text: summaryText,
      cls: "omni-forge-chat-thinking-summary"
    });
    if (message.isDraft) {
      head.createDiv({
        cls: "omni-forge-chat-thinking-live",
        text: "LIVE"
      });
    }
    const body = panel.createDiv({ cls: "omni-forge-chat-thinking-body" });
    if (timeline.length > 0) {
      const timelineEl = body.createDiv({ cls: "omni-forge-chat-thinking-timeline" });
      for (const event of timeline.slice(-24)) {
        const card = timelineEl.createDiv({
          cls: `omni-forge-chat-thinking-event omni-forge-chat-thinking-event-${event.stage}`
        });
        card.createEl("span", {
          cls: "omni-forge-chat-thinking-event-stage",
          text: this.formatThinkingStage(event.stage)
        });
        const content = card.createDiv({ cls: "omni-forge-chat-thinking-event-content" });
        content.createDiv({
          cls: "omni-forge-chat-thinking-event-message",
          text: event.message
        });
        if (event.detail) {
          content.createDiv({
            cls: "omni-forge-chat-thinking-event-detail",
            text: event.detail
          });
        }
        card.createEl("span", {
          cls: "omni-forge-chat-thinking-event-time",
          text: this.formatTime(event.timestamp)
        });
      }
    }
    if ((_b = message.thinkingDetails) == null ? void 0 : _b.trim()) {
      const raw = body.createDiv({ cls: "omni-forge-chat-thinking-raw" });
      raw.createEl("div", {
        cls: "omni-forge-chat-thinking-raw-title",
        text: "Model thinking (raw)"
      });
      raw.createEl("pre", {
        cls: "omni-forge-chat-thinking-raw-body",
        text: message.thinkingDetails.trim()
      });
    } else if (!timeline.length) {
      body.setText(message.text || "(empty)");
    }
  }
  async startNewThread() {
    if (this.running) {
      const opened = await this.plugin.openLocalQaWorkspaceView(true);
      if (!opened) {
        new import_obsidian4.Notice(`실행 중에는 새 채팅창을 여세요. (최대 ${LOCAL_QA_MAX_PANES}개)`);
      }
      return;
    }
    if (this.messages.length > 0 && (this.plugin.isQaThreadAutoSyncEnabledForQa() || this.threadPath)) {
      await this.flushThreadSync(true);
    }
    this.messages = [];
    this.renderMessages();
    this.resetThreadState();
    this.inputEl.focus();
  }
  scheduleThreadSync(delayMs = 850) {
    if (!this.plugin.isQaThreadAutoSyncEnabledForQa() || this.messages.length === 0) {
      return;
    }
    if (this.syncTimer !== null) {
      window.clearTimeout(this.syncTimer);
    }
    this.setSyncStatus("Pending...");
    this.syncTimer = window.setTimeout(() => {
      this.syncTimer = null;
      void this.flushThreadSync(false);
    }, delayMs);
  }
  async flushThreadSync(force) {
    var _a;
    if (!force && !this.plugin.isQaThreadAutoSyncEnabledForQa()) {
      return;
    }
    if (this.messages.length === 0) {
      return;
    }
    if (this.syncInFlight) {
      this.syncQueued = true;
      return;
    }
    if (this.syncTimer !== null) {
      window.clearTimeout(this.syncTimer);
      this.syncTimer = null;
    }
    this.syncInFlight = true;
    this.setSyncStatus("Syncing...");
    try {
      const synced = await this.plugin.syncLocalQaTranscript({
        messages: this.messages,
        threadPath: (_a = this.threadPath) != null ? _a : void 0,
        threadId: this.threadId,
        createdAt: this.threadCreatedAt
      });
      this.threadPath = synced.path;
      this.threadId = synced.threadId;
      this.threadCreatedAt = synced.createdAt;
      this.setSyncStatus(`Synced ${this.formatTime(synced.updatedAt)}`);
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown thread sync error";
      this.setSyncStatus("Sync failed");
      new import_obsidian4.Notice(`Chat sync failed: ${message}`, 7e3);
    } finally {
      this.syncInFlight = false;
      if (this.syncQueued) {
        this.syncQueued = false;
        this.scheduleThreadSync(350);
      }
    }
  }
  async openThreadNote() {
    if (this.messages.length === 0) {
      new import_obsidian4.Notice("No chat messages yet. / \uC544\uC9C1 \uCC44\uD305 \uBA54\uC2DC\uC9C0\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return;
    }
    await this.flushThreadSync(true);
    if (!this.threadPath) {
      new import_obsidian4.Notice("Thread note is not ready yet. / \uC2A4\uB808\uB4DC \uB178\uD2B8\uAC00 \uC544\uC9C1 \uC900\uBE44\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
      return;
    }
    const target = this.app.vault.getAbstractFileByPath(this.threadPath);
    if (target instanceof import_obsidian4.TFile) {
      await this.app.workspace.getLeaf(true).openFile(target);
      return;
    }
    new import_obsidian4.Notice(`Thread note not found / \uC2A4\uB808\uB4DC \uB178\uD2B8 \uC5C6\uC74C: ${this.threadPath}`, 7e3);
  }
  renderSourceLink(parent, source) {
    const row = parent.createDiv({ cls: "omni-forge-chat-source-row" });
    const sourcePath = source.path.trim();
    const isAttachmentVirtual = sourcePath.startsWith("[ATTACHMENT-");
    const virtualLabel = isAttachmentVirtual ? sourcePath.replace(/^\[ATTACHMENT-[^\]]+\]\s*/, "").trim() : "";
    const fallbackTarget = isAttachmentVirtual ? this.resolveVaultFileFromChatLink(virtualLabel) : null;
    const target = !isAttachmentVirtual ? this.app.vault.getAbstractFileByPath(sourcePath) : fallbackTarget;
    const canOpenExternal = /^https?:\/\//i.test(sourcePath) || /^obsidian:\/\//i.test(sourcePath) || /^file:\/\//i.test(sourcePath) || nodePath.isAbsolute(sourcePath) || /^[A-Za-z]:[\\/]/.test(sourcePath) || isAttachmentVirtual && (/^https?:\/\//i.test(virtualLabel) || /^obsidian:\/\//i.test(virtualLabel) || /^file:\/\//i.test(virtualLabel) || nodePath.isAbsolute(virtualLabel) || /^[A-Za-z]:[\\/]/.test(virtualLabel));
    const externalPath = isAttachmentVirtual ? virtualLabel : sourcePath;
    if (target instanceof import_obsidian4.TFile) {
      const link = row.createEl("a", {
        text: sourcePath,
        href: "#",
        cls: "omni-forge-chat-source-link"
      });
      link.setAttr("title", sourcePath);
      link.onclick = async (event) => {
        event.preventDefault();
        await this.app.workspace.getLeaf(true).openFile(target);
      };
    } else if (canOpenExternal) {
      const link = row.createEl("a", {
        text: sourcePath,
        href: "#",
        cls: "omni-forge-chat-source-link"
      });
      link.setAttr("title", sourcePath);
      link.onclick = async (event) => {
        event.preventDefault();
        const opened = await this.tryOpenExternalFromChatLink(externalPath);
        if (!opened) {
          new import_obsidian4.Notice(`Source not found: ${externalPath}`, 5e3);
        }
      };
    } else {
      const text = row.createEl("span", {
        text: sourcePath,
        cls: "omni-forge-chat-source-link"
      });
      text.setAttr(
        "title",
        isAttachmentVirtual ? "\uAC00\uC0C1 \uCCA8\uBD80 \uCD9C\uCC98\uC785\uB2C8\uB2E4. \uC808\uB300\uACBD\uB85C/\uBCFC\uD2B8 \uACBD\uB85C\uAC00 \uD3EC\uD568\uB418\uBA74 \uD074\uB9AD \uC5F4\uAE30\uAC00 \uAC00\uB2A5\uD569\uB2C8\uB2E4." : `Source not found: ${sourcePath}`
      );
      text.style.opacity = "0.82";
      text.style.cursor = "default";
    }
    row.createEl("span", {
      text: formatSimilarity(source.similarity),
      cls: "omni-forge-chat-source-similarity"
    });
  }
  renderMessages() {
    var _a;
    this.renderVersion += 1;
    const version = this.renderVersion;
    this.threadEl.empty();
    const visibleMessages = this.plugin.settings.qaShowSystemMessages ? this.messages : this.messages.filter((message) => message.role !== "system");
    if (visibleMessages.length === 0) {
      this.threadEl.createDiv({
        cls: "omni-forge-chat-empty",
        text: "\uC9C8\uBB38\uC744 \uC785\uB825\uD574 \uB300\uD654\uB97C \uC2DC\uC791\uD558\uC138\uC694. / Ask a question to start."
      });
      return;
    }
    for (const message of visibleMessages) {
      const box = this.threadEl.createDiv({
        cls: `omni-forge-chat-message omni-forge-chat-message-${message.role}`
      });
      if (message.role === "thinking") {
        this.renderThinkingCard(box, message);
        continue;
      }
      if (message.role === "system") {
        const panel = box.createEl("details", { cls: "omni-forge-chat-system-panel" });
        panel.open = false;
        const summary = panel.createEl("summary", { cls: "omni-forge-chat-system-head" });
        summary.createEl("strong", { text: "System / \uC2DC\uC2A4\uD15C" });
        summary.createEl("small", {
          text: this.formatTime(message.timestamp),
          cls: "omni-forge-chat-message-time"
        });
        const body2 = panel.createDiv({ cls: "omni-forge-chat-message-body" });
        body2.setText(message.text);
        continue;
      }
      const head = box.createDiv({ cls: "omni-forge-chat-message-head" });
      head.createEl("strong", {
        text: message.role === "assistant" ? "Assistant / \uC5B4\uC2DC\uC2A4\uD134\uD2B8" : message.role === "user" ? "You / \uC0AC\uC6A9\uC790" : "System / \uC2DC\uC2A4\uD15C"
      });
      head.createEl("small", {
        text: this.formatTime(message.timestamp),
        cls: "omni-forge-chat-message-time"
      });
      const body = box.createDiv({ cls: "omni-forge-chat-message-body" });
      if (message.role === "assistant" && !message.isDraft) {
        body.addClass("omni-forge-chat-markdown");
        this.renderMarkdownBody(body, message.text, (_a = this.threadPath) != null ? _a : "", version);
      } else {
        body.setText(message.text);
      }
      if (message.role === "assistant" && message.sources && message.sources.length > 0) {
        const src = box.createDiv({ cls: "omni-forge-chat-sources" });
        src.createDiv({
          cls: "omni-forge-chat-sources-title",
          text: `Sources / \uCD9C\uCC98 (${message.sources.length})`
        });
        for (const source of message.sources) {
          this.renderSourceLink(src, source);
        }
      }
      if (message.role === "assistant" && message.model && message.embeddingModel) {
        box.createDiv({
          cls: "omni-forge-chat-message-meta",
          text: `model=${message.model} | embedding=${message.embeddingModel}`
        });
      }
    }
    this.threadEl.scrollTop = this.threadEl.scrollHeight;
  }
  pushMessage(message) {
    if (message.role === "system" && !this.plugin.settings.qaShowSystemMessages) {
      this.scheduleThreadSync();
      return;
    }
    this.messages.push(message);
    if (this.messages.length > 120) {
      this.messages = this.messages.slice(-120);
    }
    this.renderMessages();
    this.scheduleThreadSync();
  }
  buildHistoryTurns() {
    const turns = this.messages.filter((item) => item.role === "user" || item.role === "assistant").map((item) => ({
      role: item.role === "assistant" ? "assistant" : "user",
      text: item.text
    }));
    return turns.slice(-12);
  }
  async refreshScopeLabel() {
    const fileCount = this.plugin.getSelectedFilesForQa().length;
    const folderCount = this.plugin.getSelectedFolderPathsForQa().length;
    const attachmentCount = this.pendingAttachments.length;
    const role = this.plugin.getQaRolePresetForQa();
    const presetLabel = this.plugin.getQaPresetProfileLabelForQa();
    const conversationMode = this.plugin.getQaConversationModeLabelForQa();
    const model = this.plugin.getQaModelLabelForQa(role);
    const parserProfile = this.plugin.getParserModeProfileForQa();
    const modelHealth = this.plugin.getQaLocalModelValidationForQa(role);
    const modelStatusLabel = modelHealth.status === "ok" ? "OK" : modelHealth.status === "warn" ? "CHECK" : modelHealth.status === "blocked" ? "ISSUE" : "CLOUD";
    const syncMode = this.plugin.isQaThreadAutoSyncEnabledForQa() ? "auto / \uC790\uB3D9" : "manual / \uC218\uB3D9";
    const fullSummary = `Scope / \uBC94\uC704: files=${fileCount}, folders=${folderCount}, attachments=${attachmentCount}`;
    const runtimeSummary = `convo=${conversationMode} | preset=${presetLabel} | parser=${parserProfile.mode}(${parserProfile.focus}) | QA=${model} | model=${modelStatusLabel} | sync=${syncMode}`;
    this.scopeEl.empty();
    this.scopeEl.setAttr("title", fullSummary);
    this.scopeEl.createDiv({
      cls: "omni-forge-chat-scope-counts",
      text: `\uD30C\uC77C(Files): ${fileCount} / \uD3F4\uB354(Folders): ${folderCount} / \uCCA8\uBD80 \uD30C\uC77C(Attach): ${attachmentCount}`
    });
    const signalRow = this.scopeEl.createDiv({ cls: "omni-forge-chat-scope-signals" });
    const parserPill = signalRow.createSpan({
      cls: `omni-forge-status-pill omni-forge-status-pill-parser ${parserProfile.mode === "detailed" ? "is-detailed" : "is-fast"}`,
      text: parserProfile.mode === "detailed" ? this.localizeChatLabel("Parser: Detailed", "Parser: 상세") : this.localizeChatLabel("Parser: Fast", "Parser: 빠름")
    });
    parserPill.setAttr(
      "title",
      this.localizeChatLabel(
        parserProfile.summary,
        parserProfile.mode === "detailed" ? `Detailed 모드: OCR 품질 우선(최대 ${LOCAL_QA_PDF_OCR_MAX_PAGES_DETAILED}p)` : `Fast 모드: 속도 우선(최대 ${LOCAL_QA_PDF_OCR_MAX_PAGES_FAST}p)`
      )
    );
    const modelPill = signalRow.createSpan({
      cls: `omni-forge-status-pill omni-forge-status-pill-model is-${modelHealth.status}`,
      text: modelHealth.status === "ok" ? this.localizeChatLabel("Local model: OK", "로컬 모델: 정상") : modelHealth.status === "warn" ? this.localizeChatLabel("Local model: CHECK", "로컬 모델: 점검") : modelHealth.status === "blocked" ? this.localizeChatLabel("Local model: ISSUE", "로컬 모델: 이슈") : this.localizeChatLabel("Model: Cloud profile", "모델: 클라우드 프로필")
    });
    modelPill.setAttr("title", modelHealth.summary);
    if (this.runtimeSummaryEl) {
      const runtimeDetails = [
        runtimeSummary,
        this.localizeChatLabel(
          `Parser mode note: ${parserProfile.recommendation}`,
          parserProfile.mode === "detailed" ? "파서 모드 메모: 정확도 우선(속도 저하 가능)" : "파서 모드 메모: 속도 우선(품질 저하 시 상세 모드 권장)"
        ),
        this.localizeChatLabel(
          `Model check: ${modelHealth.summary}`,
          `모델 점검: ${modelHealth.summary}`
        )
      ].join("\n");
      this.runtimeSummaryEl.setText(runtimeDetails);
      this.runtimeSummaryEl.setAttr("title", runtimeDetails);
    }
  }
  async refreshActiveFileStatus() {
    if (!this.activeFileStatusEl || !this.contentEl.isConnected) {
      return;
    }
    this.activeFileStatusEl.empty();
    const active = this.resolveVisibleMarkdownFile();
    if (!(active instanceof import_obsidian4.TFile) || active.extension !== "md") {
      this.activeFileStatusEl.addClass("is-empty");
      return;
    }
    this.lastKnownOpenMarkdownPath = active.path;
    this.activeFileStatusEl.removeClass("is-empty");
    const chip = this.activeFileStatusEl.createDiv({
      cls: "omni-forge-chat-active-file-chip"
    });
    chip.addClass("is-current");
    chip.createSpan({
      cls: "omni-forge-chat-active-file-label",
      text: "Open file"
    });
    chip.createSpan({
      cls: "omni-forge-chat-active-file-name",
      text: `@${active.basename}`
    });
    chip.setAttr("title", active.path);
  }
  async submitQuestion(preloadedTurn) {
    var _a, _b, _c, _d, _e, _f;
    if (this.running) {
      if (!preloadedTurn) {
        this.preemptRunningTurnWithCurrentInput();
      }
      return;
    }
    this.stopRequested = false;
    const question = ((_a = preloadedTurn == null ? void 0 : preloadedTurn.question) != null ? _a : this.inputEl.value).trim();
    if (!question) {
      new import_obsidian4.Notice("Question is empty. / \uC9C8\uBB38\uC774 \uBE44\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.");
      return;
    }
    const selectedFiles = this.plugin.getSelectedFilesForQa();
    const qaContextEnabled = this.plugin.isQaContextEnabledForQa();
    const attachmentsForTurn = (_b = preloadedTurn == null ? void 0 : preloadedTurn.attachments) != null ? _b : this.consumePendingAttachments();
    if (this.plugin.consumeSelectedAskGuardForQa()) {
      if (selectedFiles.length === 0) {
        if (attachmentsForTurn.length > 0) {
          this.mergePendingAttachments(attachmentsForTurn);
        }
        this.pushMessage({
          role: "system",
          text: "선택 기반 질문 모드입니다. 먼저 노트를 선택한 뒤 다시 질문해 주세요. (선택 강제 가드)",
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        new import_obsidian4.Notice("선택된 노트가 없어 실행을 중단했습니다. '노트 선택' 후 다시 시도하세요.", 6e3);
        return;
      }
      if (!qaContextEnabled) {
        await this.plugin.setQaContextEnabledForQa(true);
        this.refreshQaContextButton();
      }
      this.pushMessage({
        role: "system",
        text: `선택 강제 모드로 실행합니다. 선택 노트 ${selectedFiles.length}개를 우선 근거로 사용합니다.`,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
    const hasPendingAttachments = attachmentsForTurn.length > 0;
    const openFileForTurn = this.resolveVisibleMarkdownFile();
    const openFilePathForTurn = (_c = preloadedTurn == null ? void 0 : preloadedTurn.openFilePath) != null ? _c : openFileForTurn instanceof import_obsidian4.TFile && openFileForTurn.extension === "md" ? openFileForTurn.path : void 0;
    const openSelectionForTurn = (_d = preloadedTurn == null ? void 0 : preloadedTurn.openSelection) != null ? _d : this.captureOpenSelectionSnapshot(openFilePathForTurn);
    if (!qaContextEnabled && !hasPendingAttachments) {
      this.pushMessage({
        role: "system",
        text: openFilePathForTurn ? `QA 컨텍스트 OFF 상태입니다. 선택 노트 리트리벌 대신 현재 열린 문서를 보조 컨텍스트로 사용합니다: ${openFilePathForTurn}` : "QA 컨텍스트 OFF 상태입니다. 선택 노트 리트리벌 없이 일반 채팅으로 진행합니다.",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } else if (selectedFiles.length === 0 && !hasPendingAttachments) {
      this.pushMessage({
        role: "system",
        text: openFilePathForTurn ? `\uC120\uD0DD \uB178\uD2B8/\uCCA8\uBD80\uAC00 \uC5C6\uC5B4 \uD604\uC7AC \uC5F4\uB9B0 \uBB38\uC11C\uB97C \uC6B0\uC120 \uCEE8\uD14D\uC2A4\uD2B8\uB85C \uC0AC\uC6A9\uD569\uB2C8\uB2E4: ${openFilePathForTurn}` : "\uC120\uD0DD \uB178\uD2B8/\uCCA8\uBD80 \uC5C6\uC774 \uC77C\uBC18 \uB300\uD654\uB97C \uC9C4\uD589\uD569\uB2C8\uB2E4. \uD544\uC694\uD558\uBA74 \uB178\uD2B8\uB97C \uC120\uD0DD\uD558\uAC70\uB098 \uCCA8\uBD80\uB97C \uCD94\uAC00\uD558\uC138\uC694.",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
    if (attachmentsForTurn.length > 0) {
      this.pushMessage({
        role: "system",
        text: `\uC774\uBC88 \uC9C8\uBB38\uC5D0 \uCCA8\uBD80 ${attachmentsForTurn.length}\uAC1C\uB97C \uD3EC\uD568\uD569\uB2C8\uB2E4.`,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
    const parsedTopK = Number.parseInt(this.topKInput.value, 10);
    const topK = Number.isFinite(parsedTopK) && parsedTopK >= 1 ? Math.min(15, parsedTopK) : this.plugin.settings.qaTopK;
    if (!preloadedTurn) {
      this.inputEl.value = "";
    }
    this.pushMessage({
      role: "user",
      text: question,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    this.running = true;
    this.refreshSendButtonState();
    this.stopButton.disabled = false;
    this.stopRequested = false;
    const abortController = new AbortController();
    this.activeRequestController = abortController;
    const thinkingMessage = {
      role: "thinking",
      text: "- Retrieving relevant notes...",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      isDraft: true
    };
    this.messages.push(thinkingMessage);
    const thinkingIndex = this.messages.length - 1;
    const draftMessage = {
      role: "assistant",
      text: "",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      isDraft: true
    };
    this.messages.push(draftMessage);
    const draftIndex = this.messages.length - 1;
    this.renderMessages();
    this.scheduleThreadSync(300);
    const timeline = [];
    let modelThinking = "";
    let rawResponse = "";
    let thinkingStreamAnnounced = false;
    const updateThinkingMessage = (isDraft, forceTimestamp) => {
      const item = this.messages[thinkingIndex];
      if (!item || item.role !== "thinking") {
        return;
      }
      item.timeline = [...timeline];
      item.thinkingDetails = modelThinking.trim() || void 0;
      item.text = this.buildThinkingTranscriptText(timeline, modelThinking);
      item.isDraft = isDraft;
      item.timestamp = forceTimestamp != null ? forceTimestamp : (/* @__PURE__ */ new Date()).toISOString();
      this.scheduleStreamRender(80);
      this.scheduleThreadSync(900);
    };
    const pushTimelineEvent = (event) => {
      var _a2;
      const timestamp = (_a2 = event.timestamp) != null ? _a2 : (/* @__PURE__ */ new Date()).toISOString();
      const prev = timeline[timeline.length - 1];
      if (prev && prev.stage === event.stage && prev.message === event.message && prev.detail === event.detail) {
        return;
      }
      timeline.push({
        stage: event.stage,
        message: event.message,
        detail: event.detail,
        timestamp
      });
      if (timeline.length > 80) {
        timeline.splice(0, timeline.length - 80);
      }
      updateThinkingMessage(true, timestamp);
    };
    pushTimelineEvent({
      stage: "retrieval",
      message: "Retrieval started"
    });
    try {
      const result = await this.plugin.askLocalQa(
        question,
        topK,
        this.buildHistoryTurns(),
        (token) => {
          if (abortController.signal.aborted || this.stopRequested) {
            return;
          }
          rawResponse += token;
          const parsed = splitThinkingBlocks(rawResponse);
          const draft2 = this.messages[draftIndex];
          if (draft2 && draft2.role === "assistant") {
            draft2.text = parsed.answer;
            draft2.isDraft = true;
          }
          if (parsed.thinking.trim()) {
            modelThinking = parsed.thinking.trim();
          }
          updateThinkingMessage(parsed.hasOpenThinking || modelThinking.length > 0);
          if (!parsed.thinking.trim()) {
            this.scheduleStreamRender(70);
            this.scheduleThreadSync(1100);
          }
        },
        (event) => {
          if (abortController.signal.aborted || this.stopRequested) {
            return;
          }
          if (event.thinkingChunk) {
            modelThinking += event.thinkingChunk;
            if (!thinkingStreamAnnounced) {
              pushTimelineEvent({
                stage: "thinking",
                message: "Model thinking stream started",
                timestamp: event.timestamp
              });
              thinkingStreamAnnounced = true;
            } else {
              updateThinkingMessage(true, event.timestamp);
            }
            return;
          }
          pushTimelineEvent(event);
        },
        abortController.signal,
        attachmentsForTurn,
        {
          openFilePath: openFilePathForTurn,
          openSelection: openSelectionForTurn
        }
      );
      const draft = this.messages[draftIndex];
      if (draft && draft.role === "assistant") {
        draft.text = result.answer;
        draft.timestamp = (/* @__PURE__ */ new Date()).toISOString();
        draft.sources = result.sources;
        draft.model = result.model;
        draft.embeddingModel = result.embeddingModel;
        draft.retrievalCacheHits = result.retrievalCacheHits;
        draft.retrievalCacheWrites = result.retrievalCacheWrites;
        draft.isDraft = false;
        if (result.thinking.trim()) {
          modelThinking = result.thinking.trim();
          if (!thinkingStreamAnnounced) {
            pushTimelineEvent({
              stage: "thinking",
              message: "Model thinking captured"
            });
            thinkingStreamAnnounced = true;
          }
        }
        pushTimelineEvent({
          stage: "generation",
          message: "Answer generated"
        });
        updateThinkingMessage(false);
        this.renderMessages();
        this.scheduleThreadSync(120);
      } else {
        this.pushMessage({
          role: "assistant",
          text: result.answer,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          sources: result.sources,
          model: result.model,
          embeddingModel: result.embeddingModel,
          retrievalCacheHits: result.retrievalCacheHits,
          retrievalCacheWrites: result.retrievalCacheWrites,
          isDraft: false
        });
      }
      const thinking = this.messages[thinkingIndex];
      if (thinking && thinking.role === "thinking") {
        const hasTimeline = ((_e = (_d = thinking.timeline) == null ? void 0 : _d.length) != null ? _e : 0) > 0;
        const hasThinkingText = Boolean((_f = thinking.thinkingDetails) == null ? void 0 : _f.trim());
        if (!hasTimeline && !hasThinkingText) {
          this.messages.splice(thinkingIndex, 1);
        } else {
          thinking.isDraft = false;
          thinking.timestamp = (/* @__PURE__ */ new Date()).toISOString();
          thinking.text = this.buildThinkingTranscriptText(timeline, modelThinking);
        }
      }
      this.renderMessages();
    } catch (error) {
      const preemptPending = this.pendingPreemptTurn !== null;
      if (attachmentsForTurn.length > 0 && (!this.plugin.isAbortError(error) || !preemptPending)) {
        this.mergePendingAttachments(attachmentsForTurn);
      }
      const cancelled = this.plugin.isAbortError(error);
      const message = cancelled ? "\uC694\uCCAD\uC774 \uC911\uC9C0\uB418\uC5C8\uC2B5\uB2C8\uB2E4." : error instanceof Error ? error.message : "Unknown local QA error";
      const draft = this.messages[draftIndex];
      if (cancelled) {
        if (draft && draft.role === "assistant") {
          this.messages.splice(draftIndex, 1);
        }
      } else if (draft && draft.role === "assistant" && !draft.text.trim()) {
        this.messages.splice(draftIndex, 1);
      } else if (draft && draft.role === "assistant") {
        draft.isDraft = false;
      }
      const thinking = this.messages[thinkingIndex];
      if (thinking && thinking.role === "thinking") {
        pushTimelineEvent({
          stage: cancelled ? "warning" : "error",
          message: cancelled ? "Request cancelled by user" : `Error: ${message}`
        });
        thinking.isDraft = false;
        thinking.timestamp = (/* @__PURE__ */ new Date()).toISOString();
      }
      this.pushMessage({
        role: "system",
        text: cancelled ? preemptPending ? "steer \uC804\uD658\uC744 \uC704\uD574 \uC774\uC804 \uC751\uB2F5\uC744 \uC911\uC9C0\uD588\uC2B5\uB2C8\uB2E4." : `\uC911\uC9C0: ${message}` : `\uC624\uB958: ${message}`,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      if (!cancelled) {
        new import_obsidian4.Notice(`Local Q&A failed: ${message}`, 7e3);
      }
    } finally {
      this.running = false;
      this.stopRequested = false;
      this.refreshSendButtonState();
      this.stopButton.disabled = true;
      this.activeRequestController = null;
      if (this.streamRenderTimer !== null) {
        window.clearTimeout(this.streamRenderTimer);
        this.streamRenderTimer = null;
      }
      await this.refreshScopeLabel();
      this.inputEl.focus();
      const preemptTurn = this.pendingPreemptTurn;
      this.pendingPreemptTurn = null;
      if (preemptTurn) {
        await this.submitQuestion(preemptTurn);
      } else {
        void this.drainQueuedTurns();
      }
    }
  }
};
var SETTINGS_HEADER_KO_MAP = {
  "Local provider config": "\uB85C\uCEEC \uC81C\uACF5\uC790 \uC124\uC815",
  "Cloud provider config": "\uD074\uB77C\uC6B0\uB4DC \uC81C\uACF5\uC790 \uC124\uC815",
  Behavior: "\uB3D9\uC791 \uC124\uC815",
  "Semantic linking (Ollama embeddings)": "\uC2DC\uB9E8\uD2F1 \uB9C1\uD06C(\uC62C\uB77C\uB9C8 \uC784\uBCA0\uB529)",
  "Property cleanup": "\uC18D\uC131 \uC815\uB9AC",
  "Selection and backup": "\uC120\uD0DD \uBC0F \uBC31\uC5C5",
  MOC: "MOC"
};
var SETTINGS_NAME_KO_MAP = {
  "Settings view mode": "\uC124\uC815 \uBCF4\uAE30 \uBAA8\uB4DC",
  "Settings UI language": "\uC124\uC815 UI \uC5B8\uC5B4",
  "Plugin mission": "\uD50C\uB7EC\uADF8\uC778 \uBAA9\uC801",
  "Quick one-click setup": "\uBE60\uB978 \uC6D0\uD074\uB9AD \uC124\uC815",
  "Conversation mode (chat runtime)": "\uB300\uD654 \uBAA8\uB4DC(\uCC44\uD305 \uB7F0\uD0C0\uC784)",
  "Mode behavior summary": "\uBAA8\uB4DC \uB3D9\uC791 \uC694\uC57D",
  "Quick custom profile slots": "\uBE60\uB978 \uCEE4\uC2A4\uD140 \uD504\uB85C\uD544 \uC2AC\uB86F",
  "Quick model pickers": "\uBE60\uB978 \uBAA8\uB378 \uC120\uD0DD\uAE30",
  "Quick provider": "\uBE60\uB978 \uC81C\uACF5\uC790",
  "Chat model source": "\uCC44\uD305 \uBAA8\uB378 \uC18C\uC2A4",
  "Chat model profile": "\uCC44\uD305 \uBAA8\uB378 \uD504\uB85C\uD544",
  "Model inventory refresh": "\uBAA8\uB378 \uC778\uBCA4\uD1A0\uB9AC \uC0C8\uB85C\uACE0\uCE68",
  "One-click local presets": "\uC6D0\uD074\uB9AD \uB85C\uCEEC \uD504\uB9AC\uC14B",
  "Flash profile": "Flash \uD504\uB85C\uD544",
  "Pro profile": "Pro \uD504\uB85C\uD544",
  "Local AI readiness": "\uB85C\uCEEC AI \uC900\uBE44 \uC0C1\uD0DC",
  "Open preset guide": "\uD504\uB9AC\uC14B \uAC00\uC774\uB4DC \uC5F4\uAE30",
  "Guide actions": "\uAC00\uC774\uB4DC \uB3D9\uC791",
  "Need advanced options?": "\uACE0\uAE09 \uC124\uC815\uC774 \uD544\uC694\uD55C\uAC00\uC694?",
  Provider: "\uC81C\uACF5\uC790",
  "Codex bridge note": "Codex \uBE0C\uB9AC\uC9C0 \uC548\uB0B4",
  "Ollama base URL": "Ollama \uAE30\uBCF8 URL",
  "Ollama detected model picker": "Ollama \uAC10\uC9C0 \uBAA8\uB378 \uC120\uD0DD\uAE30",
  "Ollama auto-match policy": "Ollama \uC790\uB3D9 \uB9E4\uCE6D \uC815\uCC45",
  "Ollama model (manual)": "Ollama \uBAA8\uB378(\uC218\uB3D9)",
  "Auto-pick recommended Ollama model": "\uAD8C\uC7A5 Ollama \uBAA8\uB378 \uC790\uB3D9 \uC120\uD0DD",
  "Ollama detection summary": "Ollama \uAC10\uC9C0 \uC694\uC57D",
  "LM Studio base URL": "LM Studio \uAE30\uBCF8 URL",
  "LM Studio model": "LM Studio \uBAA8\uB378",
  "LM Studio API key (optional)": "LM Studio API \uD0A4(\uC120\uD0DD)",
  "OpenAI base URL": "OpenAI \uAE30\uBCF8 URL",
  "OpenAI model": "OpenAI \uBAA8\uB378",
  "OpenAI API key": "OpenAI API \uD0A4",
  "Anthropic model": "Anthropic \uBAA8\uB378",
  "Anthropic API key": "Anthropic API \uD0A4",
  "Gemini model": "Gemini \uBAA8\uB378",
  "Gemini API key": "Gemini API \uD0A4",
  "Analyzed depth mode": "\uBD84\uC11D \uAE4A\uC774 \uBAA8\uB4DC",
  "Analyzed runtime estimate": "\uBD84\uC11D \uC608\uC0C1 \uC2DC\uAC04",
  "Analyzed scope snapshot": "\uBD84\uC11D \uBC94\uC704 \uC2A4\uB0C5\uC0F7",
  "Suggestion mode (recommended)": "\uC81C\uC548 \uBAA8\uB4DC(\uAD8C\uC7A5)",
  "Show reasons for each field": "\uAC01 \uD544\uB4DC \uADFC\uAC70 \uD45C\uC2DC",
  "Show progress notices": "\uC9C4\uD589 \uC54C\uB9BC \uD45C\uC2DC",
  "Analyze tags": "\uD0DC\uADF8 \uBD84\uC11D",
  "Analyze topic": "\uC8FC\uC81C \uBD84\uC11D",
  "Analyze linked": "\uC5F0\uACB0 \uB178\uD2B8 \uBD84\uC11D",
  "Force all-to-all linked (deterministic)": "\uC120\uD0DD \uB178\uD2B8 \uC804\uCCB4 \uC0C1\uD638 linked \uAC15\uC81C(\uACB0\uC815\uC801)",
  "Analyze index": "\uC778\uB371\uC2A4 \uBD84\uC11D",
  "Max tags": "\uCD5C\uB300 \uD0DC\uADF8 \uC218",
  "Max linked": "\uCD5C\uB300 linked \uC218",
  "Enable semantic candidate ranking": "\uC2DC\uB9E8\uD2F1 \uD6C4\uBCF4 \uB7AD\uD0B9 \uC0AC\uC6A9",
  "Embedding Ollama base URL": "\uC784\uBCA0\uB529 Ollama \uAE30\uBCF8 URL",
  "Embedding detected model picker": "\uC784\uBCA0\uB529 \uAC10\uC9C0 \uBAA8\uB378 \uC120\uD0DD\uAE30",
  "Embedding auto-match policy": "\uC784\uBCA0\uB529 \uC790\uB3D9 \uB9E4\uCE6D \uC815\uCC45",
  "Cloud embedding behavior": "\uD074\uB77C\uC6B0\uB4DC \uC784\uBCA0\uB529 \uB3D9\uC791",
  "Embedding model (manual)": "\uC784\uBCA0\uB529 \uBAA8\uB378(\uC218\uB3D9)",
  "Auto-pick recommended embedding model": "\uAD8C\uC7A5 \uC784\uBCA0\uB529 \uBAA8\uB378 \uC790\uB3D9 \uC120\uD0DD",
  "Embedding detection summary": "\uC784\uBCA0\uB529 \uAC10\uC9C0 \uC694\uC57D",
  "Semantic top-k candidates": "\uC2DC\uB9E8\uD2F1 top-k \uD6C4\uBCF4 \uC218",
  "Semantic min similarity": "\uC2DC\uB9E8\uD2F1 \uCD5C\uC18C \uC720\uC0AC\uB3C4",
  "Semantic source max chars": "\uC2DC\uB9E8\uD2F1 \uC18C\uC2A4 \uCD5C\uB300 \uBB38\uC790 \uC218",
  "Q&A Ollama base URL": "Q&A Ollama \uAE30\uBCF8 URL",
  "Q&A model": "Q&A \uBAA8\uB378",
  "Q&A pipeline preset": "Q&A \uD30C\uC774\uD504\uB77C\uC778 \uD504\uB9AC\uC14B",
  "Role model detection controls": "\uC5ED\uD560 \uBAA8\uB378 \uAC10\uC9C0 \uC81C\uC5B4",
  "Role model detection summary": "\uC5ED\uD560 \uBAA8\uB378 \uAC10\uC9C0 \uC694\uC57D",
  "Auto-pick recommended role models": "\uAD8C\uC7A5 \uC5ED\uD560 \uBAA8\uB378 \uC790\uB3D9 \uC120\uD0DD",
  "Apply role recommendations now": "\uC5ED\uD560 \uCD94\uCC9C\uAC12 \uC989\uC2DC \uC801\uC6A9",
  "Role recommendation summary": "\uC5ED\uD560\uBCC4 \uCD94\uCC9C \uC694\uC57D",
  "Ask model (text)": "Ask \uBAA8\uB378(\uD14D\uC2A4\uD2B8)",
  "Ask model (vision)": "Ask \uBAA8\uB378(\uBE44\uC804)",
  "Image generator model": "\uC774\uBBF8\uC9C0 \uC0DD\uC131 \uBAA8\uB378",
  "Coder model": "Coder \uBAA8\uB378",
  "Debugger model": "Debugger \uBAA8\uB378",
  "Debugger agent": "Debugger \uC5D0\uC774\uC804\uD2B8",
  "Architect model": "Architect \uBAA8\uB378",
  "Orchestrator model": "Orchestrator \uBAA8\uB378",
  "Safeguard model": "Safeguard \uBAA8\uB378",
  "Role system prompt editor": "\uC5ED\uD560 \uC2DC\uC2A4\uD15C \uD504\uB86C\uD504\uD2B8 \uD3B8\uC9D1\uAE30",
  "Prefer Ollama /api/chat (with fallback)": "Ollama /api/chat \uC6B0\uC120(\uD3F4\uBC31 \uD3EC\uD568)",
  "Show system messages in chat": "\uCC44\uD305 \uC2DC\uC2A4\uD15C \uBA54\uC2DC\uC9C0 \uD45C\uC2DC",
  "Chat transcript folder path": "\uCC44\uD305 \uAE30\uB85D \uD3F4\uB354 \uACBD\uB85C",
  "Attachment ingest folder path": "\uCCA8\uBD80 \uBBF8\uB7EC\uB9C1 \uD3F4\uB354 \uACBD\uB85C",
  "Use QA context in chat": "\uCC44\uD305\uC5D0\uC11C QA \uCEE8\uD14D\uC2A4\uD2B8 \uC0AC\uC6A9",
  "Parser mode": "\uD30C\uC11C \uBAA8\uB4DC",
  "Parser tool readiness": "\uD30C\uC11C \uB3C4\uAD6C \uC900\uBE44 \uC0C1\uD0DC",
  "Auto-sync chat thread": "\uCC44\uD305 \uC2A4\uB808\uB4DC \uC790\uB3D9 \uB3D9\uAE30\uD654",
  "PDF attachments in chat": "\uCC44\uD305 PDF \uCCA8\uBD80",
  "Allow PDF attachments in chat (experimental)": "\uCC44\uD305 PDF \uCCA8\uBD80 \uD5C8\uC6A9(\uC2E4\uD5D8)",
  "Enable agent tool mode (experimental)": "\uC5D0\uC774\uC804\uD2B8 \uB3C4\uAD6C \uBAA8\uB4DC \uC0AC\uC6A9(\uC2E4\uD5D8)",
  "Require approval before tool execution": "\uB3C4\uAD6C \uC2E4\uD589 \uC804 \uC2B9\uC778 \uD544\uC694",
  "Allow shell tool (danger)": "\uC178 \uB3C4\uAD6C \uD5C8\uC6A9(\uC704\uD5D8)",
  "Agent shell full access (danger)": "\uC5D0\uC774\uC804\uD2B8 \uC178 \uC804\uCCB4 \uC811\uADFC(\uC704\uD5D8)",
  "Shell tool timeout (seconds)": "\uC178 \uB3C4\uAD6C \uD0C0\uC784\uC544\uC6C3(\uCD08)",
  "Shell tool default cwd (vault-relative, optional)": "\uC178 \uB3C4\uAD6C \uAE30\uBCF8 \uC791\uC5C5 \uD3F4\uB354(vault-relative, \uC120\uD0DD)",
  "Agent path allowlist (absolute, comma/newline)": "\uC5D0\uC774\uC804\uD2B8 \uACBD\uB85C \uD5C8\uC6A9\uBAA9\uB85D(\uC808\uB300\uACBD\uB85C, \uC27C\uD45C/\uC904\uBC14\uAFC8)",
  "Balanced preset base model": "Balanced \uD504\uB9AC\uC14B \uAE30\uBCF8 \uBAA8\uB378",
  "Balanced preset vision model": "Balanced \uD504\uB9AC\uC14B \uBE44\uC804 \uBAA8\uB378",
  "Balanced preset embedding model": "Balanced \uD504\uB9AC\uC14B \uC784\uBCA0\uB529 \uBAA8\uB378",
  "Pro preset base model": "Pro \uD504\uB9AC\uC14B \uAE30\uBCF8 \uBAA8\uB378",
  "Pro preset vision model": "Pro \uD504\uB9AC\uC14B \uBE44\uC804 \uBAA8\uB378",
  "Pro preset embedding model": "Pro \uD504\uB9AC\uC14B \uC784\uBCA0\uB529 \uBAA8\uB378",
  "Quality+ preset base model": "Quality+ \uD504\uB9AC\uC14B \uAE30\uBCF8 \uBAA8\uB378",
  "Quality+ preset vision model": "Quality+ \uD504\uB9AC\uC14B \uBE44\uC804 \uBAA8\uB378",
  "Quality+ preset embedding model": "Quality+ \uD504\uB9AC\uC14B \uC784\uBCA0\uB529 \uBAA8\uB378",
  "Preset override warning summary": "\uD504\uB9AC\uC14B \uC624\uBC84\uB77C\uC774\uB4DC \uACBD\uACE0 \uC694\uC57D",
  "Agent role model health check": "\uC5D0\uC774\uC804\uD2B8 \uC5ED\uD560 \uBAA8\uB378 \uC0C1\uD0DC \uC810\uAC80",
  "Allow non-local Q&A endpoint (danger)": "\uB85C\uCEEC \uC678 Q&A \uC5D4\uB4DC\uD3EC\uC778\uD2B8 \uD5C8\uC6A9(\uC704\uD5D8)",
  "Allowed outbound hosts (non-local Q&A)": "\uD5C8\uC6A9 \uC678\uBD80 \uD638\uC2A4\uD2B8(\uBE44\uB85C\uCEEC Q&A)",
  "Remove legacy AI-prefixed keys": "\uB808\uAC70\uC2DC AI \uC811\uB450 \uD0A4 \uC81C\uAC70",
  "Enable cleanup rules during apply": "\uC801\uC6A9 \uC2DC \uC815\uB9AC \uADDC\uCE59 \uC0AC\uC6A9",
  "Cleanup exact keys": "\uC815\uB9AC \uC815\uD655 \uD0A4",
  "Pick cleanup keys from selected notes": "\uC120\uD0DD \uB178\uD2B8\uC5D0\uC11C \uC815\uB9AC \uD0A4 \uC120\uD0DD",
  "Cleanup key prefixes": "\uC815\uB9AC \uD0A4 \uC811\uB450\uC5B4",
  "Never remove these keys": "\uC808\uB300 \uC81C\uAC70\uD558\uC9C0 \uC54A\uC744 \uD0A4",
  "Run cleanup command": "\uC815\uB9AC \uBA85\uB839 \uC2E4\uD589",
  "Cleanup dry-run report folder": "\uC815\uB9AC dry-run \uB9AC\uD3EC\uD2B8 \uD3F4\uB354",
  "Sort tags and linked arrays": "tags/linked \uBC30\uC5F4 \uC815\uB82C",
  "Include subfolders for selected folders": "\uC120\uD0DD \uD3F4\uB354 \uD558\uC704\uD3F4\uB354 \uD3EC\uD568",
  "Selection path width percent": "\uC120\uD0DD \uACBD\uB85C \uB108\uBE44 \uBE44\uC728",
  "Excluded folder patterns": "\uC81C\uC678 \uD3F4\uB354 \uD328\uD134",
  "Backup selected notes before apply": "\uC801\uC6A9 \uC804 \uC120\uD0DD \uB178\uD2B8 \uBC31\uC5C5",
  "Backup root path": "\uBC31\uC5C5 \uB8E8\uD2B8 \uACBD\uB85C",
  "Backup retention count": "\uBC31\uC5C5 \uBCF4\uAD00 \uAC1C\uC218",
  "Generate MOC after apply": "\uC801\uC6A9 \uD6C4 MOC \uC0DD\uC131",
  "MOC file path": "MOC \uD30C\uC77C \uACBD\uB85C"
};
var SETTINGS_DESC_KO_MAP = {
  "Simple shows essentials only. Full shows all advanced controls without removing features.": "Simple\uC740 \uD575\uC2EC \uC635\uC158\uB9CC \uBCF4\uC774\uACE0, Full\uC740 \uBAA8\uB4E0 \uACE0\uAE09 \uC635\uC158\uC744 \uD45C\uC2DC\uD569\uB2C8\uB2E4(\uAE30\uB2A5\uC740 \uC81C\uAC70\uB418\uC9C0 \uC54A\uC74C).",
  "Choose language style used in setting labels/descriptions across all tabs.": "\uBAA8\uB4E0 \uD0ED\uC758 \uC124\uC815 \uB77C\uBCA8/\uC124\uBA85\uC5D0 \uC0AC\uC6A9\uD560 \uC5B8\uC5B4 \uD45C\uC2DC \uBC29\uC2DD\uC744 \uC120\uD0DD\uD569\uB2C8\uB2E4.",
  "1) Auto-link notes for graph-based second-brain insight. 2) Secure local AI chat/generation grounded in your notes and attachments.": "1) \uB178\uD2B8 linked \uC790\uB3D9\uD654\uB85C \uADF8\uB798\uD504 \uAE30\uBC18 \uC81C2\uC758 \uB1CC/\uC778\uC0AC\uC774\uD2B8\uB97C \uC9C0\uC6D0\uD569\uB2C8\uB2E4. 2) \uB178\uD2B8\xB7\uCCA8\uBD80 \uAE30\uBC18 \uB85C\uCEEC AI \uCC44\uD305/\uC0DD\uC131\uC744 \uBCF4\uC548 \uC6B0\uC120\uC73C\uB85C \uC81C\uACF5\uD569\uB2C8\uB2E4.",
  "Fast, balanced, and quality presets for local usage.": "\uB85C\uCEEC \uC0AC\uC6A9 \uAE30\uC900\uC73C\uB85C \uC18D\uB3C4/\uADE0\uD615/\uD488\uC9C8 \uD504\uB9AC\uC14B\uC744 \uC6D0\uD074\uB9AD \uC801\uC6A9\uD569\uB2C8\uB2E4.",
  "Ask/Plan/Agent/Orchestration \uBAA8\uB4DC\uB97C \uC120\uD0DD\uD558\uBA74 \uC5ED\uD560/\uD30C\uC774\uD504\uB77C\uC778/\uC5D0\uC774\uC804\uD2B8 \uB3C4\uAD6C \uAE30\uBCF8\uAC12\uC744 \uC989\uC2DC \uC7AC\uBC30\uCE58\uD569\uB2C8\uB2E4.": "Ask/Plan/Agent/Orchestration \uBAA8\uB4DC\uB97C \uC120\uD0DD\uD558\uBA74 \uC5ED\uD560/\uD30C\uC774\uD504\uB77C\uC778/\uC5D0\uC774\uC804\uD2B8 \uB3C4\uAD6C \uAE30\uBCF8\uAC12\uC744 \uC989\uC2DC \uC7AC\uBC30\uCE58\uD569\uB2C8\uB2E4.",
  "Fast/Balanced/Quality+ presets with automatic local model detection and role assignment.": "Fast/Balanced/Quality+\uB97C \uB204\uB974\uBA74 \uB85C\uCEEC \uBAA8\uB378\uC744 \uC790\uB3D9 \uAC10\uC9C0\uD558\uACE0 \uAE30\uBCF8/\uC5ED\uD560 \uBAA8\uB378 \uBC30\uCE58\uB97C \uC790\uB3D9 \uC801\uC6A9\uD569\uB2C8\uB2E4.",
  "Flash/Pro presets with automatic local model detection and role assignment.": "Flash/Pro\uB97C \uB204\uB974\uBA74 \uB85C\uCEEC \uBAA8\uB378\uC744 \uC790\uB3D9 \uAC10\uC9C0\uD558\uACE0 \uAE30\uBCF8/\uC5ED\uD560 \uBAA8\uB378 \uBC30\uCE58\uB97C \uC790\uB3D9 \uC801\uC6A9\uD569\uB2C8\uB2E4.",
  "See what each preset changes and which local models are recommended.": "\uAC01 \uD504\uB9AC\uC14B\uC5D0\uC11C \uBC14\uB00C\uB294 \uC124\uC815\uACFC \uAD8C\uC7A5 \uB85C\uCEEC \uBAA8\uB378 \uAD6C\uC131\uC744 \uD655\uC778\uD569\uB2C8\uB2E4.",
  "Refresh local detection or return to Quick tab.": "\uB85C\uCEEC \uAC10\uC9C0\uB97C \uC0C8\uB85C\uACE0\uCE68\uD558\uAC70\uB098 Quick \uD0ED\uC73C\uB85C \uB3CC\uC544\uAC11\uB2C8\uB2E4.",
  "Switch to Full once to access all expert controls. Features are unchanged.": "\uC804\uBB38\uAC00\uC6A9 \uC804\uCCB4 \uC81C\uC5B4\uAC00 \uD544\uC694\uD558\uBA74 Full\uB85C \uC804\uD658\uD558\uC138\uC694. \uAE30\uB2A5\uC740 \uB3D9\uC77C\uD558\uAC8C \uC720\uC9C0\uB429\uB2C8\uB2E4.",
  "Return to Simple to focus on essentials.": "\uD575\uC2EC \uD56D\uBAA9 \uC911\uC2EC\uC73C\uB85C \uBCF4\uB824\uBA74 Simple\uB85C \uB3CC\uC544\uAC11\uB2C8\uB2E4.",
  "Choose AI provider. Local providers are recommended first.": "AI \uC81C\uACF5\uC790\uB97C \uC120\uD0DD\uD569\uB2C8\uB2E4. \uB85C\uCEEC \uC81C\uACF5\uC790\uB97C \uC6B0\uC120 \uAD8C\uC7A5\uD569\uB2C8\uB2E4.",
  "Choose provider in order: local > local QA bridge > cloud. Local defaults to Flash profile.": "\uC81C\uACF5\uC790 \uC21C\uC11C\uB294 \uB85C\uCEEC > \uB85C\uCEEC QA \uBE0C\uB9AC\uC9C0 > \uD074\uB77C\uC6B0\uB4DC\uC785\uB2C8\uB2E4. \uB85C\uCEEC \uC120\uD0DD \uC2DC Flash \uD504\uB85C\uD544\uC744 \uAE30\uBCF8 \uC0AC\uC6A9\uD569\uB2C8\uB2E4.",
  "Meaning: Q&A calls Codex through an OpenAI-compatible bridge endpoint (for example Agent Client) instead of a direct plugin API integration.": "\uC758\uBBF8: \uD50C\uB7EC\uADF8\uC778\uC774 Codex\uB97C \uC9C1\uC811 API \uC5F0\uB3D9\uD558\uB294 \uB300\uC2E0 OpenAI \uD638\uD658 \uBE0C\uB9AC\uC9C0 \uC5D4\uB4DC\uD3EC\uC778\uD2B8(\uC608: Agent Client)\uB97C \uD1B5\uD574 Q&A\uB97C \uD638\uCD9C\uD55C\uB2E4\uB294 \uB73B\uC785\uB2C8\uB2E4.",
  "Refresh local model detection and embedding inventory now.": "\uB85C\uCEEC \uBAA8\uB378 \uAC10\uC9C0\uC640 \uC784\uBCA0\uB529 \uC778\uBCA4\uD1A0\uB9AC\uB97C \uC989\uC2DC \uC0C8\uB85C\uACE0\uCE68\uD569\uB2C8\uB2E4.",
  "Choose among detected models. (\uCD94\uCC9C)=recommended, (\uBD88\uAC00)=not suitable for analysis.": "\uAC10\uC9C0\uB41C \uBAA8\uB378 \uC911\uC5D0\uC11C \uC120\uD0DD\uD569\uB2C8\uB2E4. (\uCD94\uCC9C)=\uAD8C\uC7A5, (\uBD88\uAC00)=\uBD84\uC11D \uBD80\uC801\uD569",
  "On refresh/detect, recommended model is applied automatically.": "\uC0C8\uB85C\uACE0\uCE68/\uAC10\uC9C0 \uC2DC \uAD8C\uC7A5 \uBAA8\uB378\uC744 \uC790\uB3D9 \uC801\uC6A9\uD569\uB2C8\uB2E4.",
  "Manual override if you want a custom model name.": "\uC0AC\uC6A9\uC790 \uC9C0\uC815 \uBAA8\uB378\uBA85\uC744 \uC9C1\uC811 \uC785\uB825\uD560 \uB54C \uC0AC\uC6A9\uD569\uB2C8\uB2E4.",
  "Detect local models and auto-choose recommended when current is missing.": "\uB85C\uCEEC \uBAA8\uB378\uC744 \uAC10\uC9C0\uD574 \uD604\uC7AC \uBAA8\uB378\uC774 \uC5C6\uC73C\uBA74 \uAD8C\uC7A5 \uBAA8\uB378\uC744 \uC790\uB3D9 \uC120\uD0DD\uD569\uB2C8\uB2E4.",
  "Analyze first, preview changes, and apply only when approved.": "\uBA3C\uC800 \uBD84\uC11D\uD558\uACE0 \uBCC0\uACBD \uBBF8\uB9AC\uBCF4\uAE30\uB97C \uD655\uC778\uD55C \uB4A4 \uC2B9\uC778 \uC2DC\uC5D0\uB9CC \uC801\uC6A9\uD569\uB2C8\uB2E4.",
  "When enabled, linked field includes all selected notes for each note (except self). maxLinked is ignored in this mode.": "\uCF1C\uBA74 \uAC01 \uB178\uD2B8\uC758 linked\uC5D0 \uC120\uD0DD\uB41C \uBAA8\uB4E0 \uB178\uD2B8(\uC790\uAE30 \uC790\uC2E0 \uC81C\uC678)\uB97C \uB123\uC2B5\uB2C8\uB2E4. \uC774 \uBAA8\uB4DC\uC5D0\uC11C\uB294 maxLinked\uB97C \uBB34\uC2DC\uD569\uB2C8\uB2E4.",
  "In addition to persistent progress modal, show short notices.": "\uACE0\uC815 \uC9C4\uD589 \uBAA8\uB2EC \uC678\uC5D0\uB3C4 \uC9E7\uC740 \uC54C\uB9BC\uC744 \uD45C\uC2DC\uD569\uB2C8\uB2E4.",
  "Quick: changed-notes \uC911\uC2EC + semantic off. Detailed: semantic on + \uC804\uCCB4 \uBC94\uC704 \uAE30\uBC18 \uBD84\uC11D.": "Quick\uC740 \uBCC0\uACBD \uB178\uD2B8 \uC911\uC2EC+semantic off, Detailed\uB294 semantic on+\uC804\uCCB4 \uBC94\uC704 \uAE30\uBC18 \uBD84\uC11D\uC785\uB2C8\uB2E4.",
  "Quick: changed-notes centric + semantic off. Detailed: semantic on + full-scope analysis. Embedding model is auto-matched by profile when depth changes.": "Quick\uC740 \uBCC0\uACBD \uB178\uD2B8 \uC911\uC2EC+semantic off, Detailed\uB294 semantic on+\uC804\uCCB4 \uBC94\uC704 \uAE30\uBC18 \uBD84\uC11D\uC785\uB2C8\uB2E4. \uAE4A\uC774 \uBCC0\uACBD \uC2DC \uC784\uBCA0\uB529 \uBAA8\uB378\uB3C4 \uD504\uB85C\uD544 \uAE30\uC900\uC73C\uB85C \uC790\uB3D9 \uB9E4\uCE6D\uB429\uB2C8\uB2E4.",
  "Use local Ollama embeddings to rank likely related notes before AI linked suggestion.": "AI linked \uC81C\uC548 \uC804\uC5D0 \uB85C\uCEEC Ollama \uC784\uBCA0\uB529\uC73C\uB85C \uAD00\uB828 \uAC00\uB2A5 \uB178\uD2B8\uB97C \uC6B0\uC120 \uC815\uB82C\uD569\uB2C8\uB2E4.",
  "Choose among detected models. (\uCD94\uCC9C)=recommended, (\uBD88\uAC00)=not suitable for embeddings.": "\uAC10\uC9C0\uB41C \uBAA8\uB378 \uC911\uC5D0\uC11C \uC120\uD0DD\uD569\uB2C8\uB2E4. (\uCD94\uCC9C)=\uAD8C\uC7A5, (\uBD88\uAC00)=\uC784\uBCA0\uB529 \uBD80\uC801\uD569",
  "Choose among embedding-capable detected models. (\uCD94\uCC9C)=recommended.": "\uC784\uBCA0\uB529 \uAC00\uB2A5\uD55C \uAC10\uC9C0 \uBAA8\uB378 \uC911\uC5D0\uC11C \uC120\uD0DD\uD569\uB2C8\uB2E4. (\uCD94\uCC9C)=\uAD8C\uC7A5",
  "Embedding detected picker is shown only for Ollama provider. In cloud mode, this picker is hidden and semantic linking uses the last saved local embedding model when enabled.": "Embedding \uAC10\uC9C0 \uC120\uD0DD\uAE30\uB294 Ollama \uC81C\uACF5\uC790\uC77C \uB54C\uB9CC \uD45C\uC2DC\uB429\uB2C8\uB2E4. \uD074\uB77C\uC6B0\uB4DC \uBAA8\uB4DC\uC5D0\uC11C\uB294 \uC120\uD0DD\uAE30\uAC00 \uC228\uACA8\uC9C0\uBA70, semantic linking\uC774 \uCF1C\uC838 \uC788\uC73C\uBA74 \uB9C8\uC9C0\uB9C9 \uC800\uC7A5\uB41C \uB85C\uCEEC \uC784\uBCA0\uB529 \uBAA8\uB378\uC744 \uC0AC\uC6A9\uD569\uB2C8\uB2E4.",
  "On refresh/detect, recommended embedding model is applied automatically.": "\uC0C8\uB85C\uACE0\uCE68/\uAC10\uC9C0 \uC2DC \uAD8C\uC7A5 \uC784\uBCA0\uB529 \uBAA8\uB378\uC744 \uC790\uB3D9 \uC801\uC6A9\uD569\uB2C8\uB2E4.",
  "Manual override if you want a custom embedding model name.": "\uC0AC\uC6A9\uC790 \uC9C0\uC815 \uC784\uBCA0\uB529 \uBAA8\uB378\uBA85\uC744 \uC9C1\uC811 \uC785\uB825\uD560 \uB54C \uC0AC\uC6A9\uD569\uB2C8\uB2E4.",
  "Range: 0.0 to 1.0": "\uBC94\uC704: 0.0 ~ 1.0",
  "Trim note text before embedding to keep local runs fast.": "\uB85C\uCEEC \uC2E4\uD589 \uC131\uB2A5\uC744 \uC704\uD574 \uC784\uBCA0\uB529 \uC804 \uB178\uD2B8 \uD14D\uC2A4\uD2B8 \uAE38\uC774\uB97C \uC81C\uD55C\uD569\uB2C8\uB2E4.",
  "Leave empty to use main Ollama base URL.": "\uBE44\uC6CC\uB450\uBA74 \uBA54\uC778 Ollama \uAE30\uBCF8 URL\uC744 \uC0AC\uC6A9\uD569\uB2C8\uB2E4.",
  "Leave empty to use main analysis model.": "\uBE44\uC6CC\uB450\uBA74 \uBA54\uC778 \uBD84\uC11D \uBAA8\uB378\uC744 \uC0AC\uC6A9\uD569\uB2C8\uB2E4.",
  "Select execution pipeline for post-generation passes.": "\uC0DD\uC131 \uD6C4 \uD6C4\uCC98\uB9AC \uD328\uC2A4\uC758 \uC2E4\uD589 \uD30C\uC774\uD504\uB77C\uC778\uC744 \uC120\uD0DD\uD569\uB2C8\uB2E4.",
  "Refresh local model detection manually, then choose role-specific models below.": "\uB85C\uCEEC \uBAA8\uB378 \uAC10\uC9C0\uB97C \uC218\uB3D9\uC73C\uB85C \uAC31\uC2E0\uD55C \uB4A4, \uC544\uB798\uC5D0\uC11C \uC5ED\uD560\uBCC4 \uBAA8\uB378\uC744 \uC120\uD0DD\uD569\uB2C8\uB2E4.",
  "Auto-fill role model fields from detected models when values are missing or legacy-uniform.": "\uAC12\uC774 \uBE44\uC5B4 \uC788\uAC70\uB098 \uAE30\uC874\uCC98\uB7FC \uB3D9\uC77C \uBAA8\uB378\uB85C\uB9CC \uCC44\uC6CC\uC9C4 \uACBD\uC6B0, \uAC10\uC9C0 \uBAA8\uB378 \uAE30\uBC18 \uAD8C\uC7A5\uAC12\uC73C\uB85C \uC5ED\uD560\uBCC4 \uD544\uB4DC\uB97C \uC790\uB3D9 \uCC44\uC6C1\uB2C8\uB2E4.",
  "Calculate role-specific recommended models from detected list and apply.": "\uAC10\uC9C0\uB41C \uBAA8\uB378 \uBAA9\uB85D\uC5D0\uC11C \uC5ED\uD560\uBCC4 \uAD8C\uC7A5 \uBAA8\uB378\uC744 \uACC4\uC0B0\uD574 \uC989\uC2DC \uC801\uC6A9\uD569\uB2C8\uB2E4.",
  "Optional role-specific model. Empty uses Q&A model as fallback.": "\uC5ED\uD560 \uC804\uC6A9 \uBAA8\uB378(\uC120\uD0DD)\uC785\uB2C8\uB2E4. \uBE44\uC6B0\uBA74 Q&A \uBAA8\uB378\uC744 \uC0AC\uC6A9\uD569\uB2C8\uB2E4.",
  "Prefer vision-capable models for Ask (vision). Chat supports image attachments (drop/upload/paste).": "Ask(\uBE44\uC804)\uC740 \uBE44\uC804 \uAC00\uB2A5\uD55C \uBAA8\uB378\uC744 \uC6B0\uC120 \uAD8C\uC7A5\uD569\uB2C8\uB2E4. \uCC44\uD305\uC740 \uC774\uBBF8\uC9C0 \uCCA8\uBD80(\uB4DC\uB798\uADF8/\uC5C5\uB85C\uB4DC/\uBD99\uC5EC\uB123\uAE30)\uB97C \uC9C0\uC6D0\uD569\uB2C8\uB2E4.",
  "Reserved for image-generation workflows. Current chat UI is text-first.": "\uC774\uBBF8\uC9C0 \uC0DD\uC131 \uC6CC\uD06C\uD50C\uB85C\uC6A9 \uC608\uC57D \uBAA8\uB378\uC785\uB2C8\uB2E4. \uD604\uC7AC \uCC44\uD305 UI\uB294 \uD14D\uC2A4\uD2B8 \uC911\uC2EC\uC785\uB2C8\uB2E4.",
  "Add extra system instructions per role agent. Empty keeps built-in role prompt only.": "\uC5ED\uD560\uBCC4 \uC5D0\uC774\uC804\uD2B8\uC5D0 \uCD94\uAC00 \uC2DC\uC2A4\uD15C \uC9C0\uC2DC\uB97C \uB123\uC2B5\uB2C8\uB2E4. \uBE44\uC6B0\uBA74 \uAE30\uBCF8 \uC5ED\uD560 \uD504\uB86C\uD504\uD2B8\uB9CC \uC0AC\uC6A9\uD569\uB2C8\uB2E4.",
  "Use role-based chat first, then fallback to /api/generate when unavailable.": "\uC5ED\uD560 \uAE30\uBC18 /api/chat\uC744 \uC6B0\uC120 \uC0AC\uC6A9\uD558\uACE0, \uBD88\uAC00\uD558\uBA74 /api/generate\uB85C \uD3F4\uBC31\uD569\uB2C8\uB2E4.",
  "Off by default. When OFF, system logs are hidden and omitted from saved chat transcript.": "\uAE30\uBCF8\uAC12\uC740 OFF\uC785\uB2C8\uB2E4. OFF\uC77C \uB54C \uC2DC\uC2A4\uD15C \uB85C\uADF8\uB294 \uCC44\uD305 \uD654\uBA74\uC5D0\uC11C \uC228\uACA8\uC9C0\uACE0 \uC800\uC7A5\uB41C \uCC44\uD305 \uAE30\uB85D\uC5D0\uC11C\uB3C4 \uC81C\uC678\uB429\uB2C8\uB2E4.",
  "Vault-relative path for saving chat transcripts.": "\uCC44\uD305 \uAE30\uB85D \uC800\uC7A5\uC6A9 vault-relative \uACBD\uB85C\uC785\uB2C8\uB2E4.",
  "Vault-relative folder where external attachments are mirrored for stable source links.": "\uC678\uBD80 \uCCA8\uBD80\uB97C \uC548\uC815\uC801\uC778 \uCD9C\uCC98 \uB9C1\uD06C\uB85C \uC5F4\uAE30 \uC704\uD574 vault \uB0B4\uBD80\uB85C \uBBF8\uB7EC\uB9C1\uD558\uB294 \uD3F4\uB354 \uACBD\uB85C\uC785\uB2C8\uB2E4.",
  "When disabled, chat runs in general mode without selected-note retrieval context.": "\uBE44\uD65C\uC131\uD654\uD558\uBA74 \uC120\uD0DD \uB178\uD2B8 \uB9AC\uD2B8\uB9AC\uBC8C \uC5C6\uC774 \uC77C\uBC18 \uCC44\uD305 \uBAA8\uB4DC\uB85C \uB3D9\uC791\uD569\uB2C8\uB2E4.",
  "Fast: lightweight parsing. Detailed: OCR and deeper parser chain for difficult files.": "Fast\uB294 \uACBD\uB7C9 \uD30C\uC11C, Detailed\uB294 OCR/\uC2EC\uD654 \uCCB4\uC778\uC744 \uC801\uADF9 \uC0AC\uC6A9\uD569\uB2C8\uB2E4.",
  "When enabled, the current chat thread is continuously saved and updated as messages change.": "\uD65C\uC131\uD654\uD558\uBA74 \uD604\uC7AC \uCC44\uD305 \uC2A4\uB808\uB4DC\uB97C \uBA54\uC2DC\uC9C0 \uBCC0\uACBD\uC5D0 \uB9DE\uCDB0 \uACC4\uC18D \uC800\uC7A5/\uB3D9\uAE30\uD654\uD569\uB2C8\uB2E4.",
  "When enabled, PDF files can be attached in chat. Current mode keeps metadata/label context and routes to vision role for safer handling.": "\uD65C\uC131\uD654\uD558\uBA74 \uCC44\uD305\uC5D0\uC11C PDF \uCCA8\uBD80\uB97C \uD5C8\uC6A9\uD569\uB2C8\uB2E4. \uD604\uC7AC\uB294 \uBA54\uD0C0\uB370\uC774\uD130/\uB77C\uBCA8 \uC911\uC2EC \uCEE8\uD14D\uC2A4\uD2B8\uB85C \uCC98\uB9AC\uD558\uBA70 \uBE44\uC804 \uC5ED\uD560\uB85C \uC6B0\uC120 \uB77C\uC6B0\uD305\uD569\uB2C8\uB2E4.",
  "Shows all preset override fields currently marked with warning (\u26A0) in one place.": "\u26A0 \uACBD\uACE0\uAC00 \uBD99\uC740 \uD504\uB9AC\uC14B \uC624\uBC84\uB77C\uC774\uB4DC \uD544\uB4DC\uB97C \uD55C \uACF3\uC5D0\uC11C \uBAA8\uC544 \uBCF4\uC5EC\uC90D\uB2C8\uB2E4.",
  "Quick diagnostic for role-model auto assignment and unavailable role mappings.": "\uC5ED\uD560 \uBAA8\uB378 \uC790\uB3D9 \uBC30\uCE58\uC640 \uBD88\uAC00 \uB9E4\uD551\uC744 \uBE60\uB974\uAC8C \uC810\uAC80\uD569\uB2C8\uB2E4.",
  "Allow model-proposed actions (read/write/list/shell) from chat responses via omni-forge-actions JSON block.": "\uCC44\uD305 \uC751\uB2F5\uC758 omni-forge-actions JSON \uBE14\uB85D\uC744 \uD1B5\uD574 \uBAA8\uB378 \uC81C\uC548 \uC561\uC158(\uC77D\uAE30/\uC4F0\uAE30/\uBAA9\uB85D/\uC178)\uC744 \uD5C8\uC6A9\uD569\uB2C8\uB2E4.",
  "Recommended. If enabled, proposed actions are queued and run only after user sends '\uC2B9\uC778' or '/approve'.": "\uAD8C\uC7A5 \uC124\uC815\uC785\uB2C8\uB2E4. \uCF1C\uBA74 \uC81C\uC548\uB41C \uC561\uC158\uC744 \uB300\uAE30\uC5F4\uC5D0 \uB450\uACE0 \uC0AC\uC6A9\uC790\uAC00 '\uC2B9\uC778' \uB610\uB294 '/approve' \uC785\uB825 \uC2DC\uC5D0\uB9CC \uC2E4\uD589\uD569\uB2C8\uB2E4.",
  "Allows run_shell actions via local terminal command execution. Keep off unless absolutely needed.": "\uB85C\uCEEC \uD130\uBBF8\uB110 \uBA85\uB839 \uC2E4\uD589 \uAE30\uBC18 run_shell \uC561\uC158\uC744 \uD5C8\uC6A9\uD569\uB2C8\uB2E4. \uAF2D \uD544\uC694\uD560 \uB54C\uB9CC \uCF1C\uC138\uC694.",
  "If enabled, run_shell and agent file actions(read/write/list) can use any absolute path (allowlist bypass).": "\uD65C\uC131\uD654\uD558\uBA74 run_shell\uACFC \uC5D0\uC774\uC804\uD2B8 \uD30C\uC77C \uC561\uC158(read/write/list)\uC774 \uC784\uC758\uC758 \uC808\uB300\uACBD\uB85C\uB97C \uC0AC\uC6A9\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4(allowlist \uC6B0\uD68C).",
  "Per command timeout for run_shell actions.": "run_shell \uC561\uC158\uC758 \uBA85\uB839\uBCC4 \uC81C\uD55C \uC2DC\uAC04\uC785\uB2C8\uB2E4.",
  "Example: '.' for vault root, 'Projects' for a subfolder. Empty means vault root.": "\uC608: vault \uB8E8\uD2B8\uB294 '.', \uD558\uC704 \uD3F4\uB354\uB294 'Projects'. \uBE44\uC6CC\uB450\uBA74 vault \uB8E8\uD2B8\uB97C \uC0AC\uC6A9\uD569\uB2C8\uB2E4.",
  "Shell tool absolute cwd allowlist. Default: (empty, set explicitly if needed)": "Shell \uB3C4\uAD6C\uC758 \uC808\uB300\uACBD\uB85C \uC791\uC5C5 \uD3F4\uB354 \uD5C8\uC6A9 \uBAA9\uB85D\uC785\uB2C8\uB2E4. \uAE30\uBCF8\uAC12: (\uBE44\uC5B4 \uC788\uC74C, \uD544\uC694 \uC2DC \uC9C1\uC811 \uC124\uC815)",
  "Absolute path allowlist for run_shell cwd and agent file actions(read/write/list) when full access is OFF. Default: (empty, vault-only)": "full access OFF\uC77C \uB54C run_shell cwd\uC640 \uC5D0\uC774\uC804\uD2B8 \uD30C\uC77C \uC561\uC158(read/write/list)\uC5D0 \uC0AC\uC6A9\uD560 \uC808\uB300\uACBD\uB85C \uD5C8\uC6A9 \uBAA9\uB85D\uC785\uB2C8\uB2E4. \uAE30\uBCF8\uAC12: (\uBE44\uC5B4 \uC788\uC74C, vault \uC804\uC6A9)",
  "Optional manual base-model override for Balanced preset.": "Balanced \uD504\uB9AC\uC14B \uC801\uC6A9 \uC2DC \uAE30\uBCF8 \uBAA8\uB378\uC744 \uC218\uB3D9\uC73C\uB85C \uB36E\uC5B4\uC501\uB2C8\uB2E4(\uC120\uD0DD).",
  "Optional manual vision-model override for Balanced preset.": "Balanced \uD504\uB9AC\uC14B \uC801\uC6A9 \uC2DC \uBE44\uC804 \uBAA8\uB378\uC744 \uC218\uB3D9\uC73C\uB85C \uB36E\uC5B4\uC501\uB2C8\uB2E4(\uC120\uD0DD).",
  "Optional manual embedding-model override for Balanced preset.": "Balanced \uD504\uB9AC\uC14B \uC801\uC6A9 \uC2DC \uC784\uBCA0\uB529 \uBAA8\uB378\uC744 \uC218\uB3D9\uC73C\uB85C \uB36E\uC5B4\uC501\uB2C8\uB2E4(\uC120\uD0DD).",
  "Optional manual base-model override for Pro preset.": "Pro \uD504\uB9AC\uC14B \uC801\uC6A9 \uC2DC \uAE30\uBCF8 \uBAA8\uB378\uC744 \uC218\uB3D9\uC73C\uB85C \uB36E\uC5B4\uC501\uB2C8\uB2E4(\uC120\uD0DD).",
  "Optional manual vision-model override for Pro preset.": "Pro \uD504\uB9AC\uC14B \uC801\uC6A9 \uC2DC \uBE44\uC804 \uBAA8\uB378\uC744 \uC218\uB3D9\uC73C\uB85C \uB36E\uC5B4\uC501\uB2C8\uB2E4(\uC120\uD0DD).",
  "Optional manual embedding-model override for Pro preset.": "Pro \uD504\uB9AC\uC14B \uC801\uC6A9 \uC2DC \uC784\uBCA0\uB529 \uBAA8\uB378\uC744 \uC218\uB3D9\uC73C\uB85C \uB36E\uC5B4\uC501\uB2C8\uB2E4(\uC120\uD0DD).",
  "Optional manual base-model override for Quality+ preset.": "Quality+ \uD504\uB9AC\uC14B \uC801\uC6A9 \uC2DC \uAE30\uBCF8 \uBAA8\uB378\uC744 \uC218\uB3D9\uC73C\uB85C \uB36E\uC5B4\uC501\uB2C8\uB2E4(\uC120\uD0DD).",
  "Optional manual vision-model override for Quality+ preset.": "Quality+ \uD504\uB9AC\uC14B \uC801\uC6A9 \uC2DC \uBE44\uC804 \uBAA8\uB378\uC744 \uC218\uB3D9\uC73C\uB85C \uB36E\uC5B4\uC501\uB2C8\uB2E4(\uC120\uD0DD).",
  "Optional manual embedding-model override for Quality+ preset.": "Quality+ \uD504\uB9AC\uC14B \uC801\uC6A9 \uC2DC \uC784\uBCA0\uB529 \uBAA8\uB378\uC744 \uC218\uB3D9\uC73C\uB85C \uB36E\uC5B4\uC501\uB2C8\uB2E4(\uC120\uD0DD).",
  "Off by default. Keep disabled to prevent note data leaving localhost.": "\uAE30\uBCF8\uAC12\uC740 \uAEBC\uC9D0\uC785\uB2C8\uB2E4. \uB178\uD2B8 \uB370\uC774\uD130\uAC00 localhost \uBC16\uC73C\uB85C \uB098\uAC00\uC9C0 \uC54A\uB3C4\uB85D \uBE44\uD65C\uC131 \uC0C1\uD0DC\uB97C \uAD8C\uC7A5\uD569\uB2C8\uB2E4.",
  "Comma/newline-separated host allowlist used when non-local endpoint is enabled. Example: api.openai.com, api.anthropic.com": "\uBE44\uB85C\uCEEC \uC5D4\uB4DC\uD3EC\uC778\uD2B8\uB97C \uC0AC\uC6A9\uD560 \uB54C \uC801\uC6A9\uD560 \uD638\uC2A4\uD2B8 \uD5C8\uC6A9 \uBAA9\uB85D\uC785\uB2C8\uB2E4(\uC27C\uD45C/\uC904\uBC14\uAFC8 \uAD6C\uBD84). \uC608: api.openai.com, api.anthropic.com",
  "If enabled, removes only legacy keys like ai_*/autolinker_* while preserving other existing keys (including linter date fields).": "\uD65C\uC131\uD654\uD558\uBA74 ai_*/autolinker_* \uAC19\uC740 \uB808\uAC70\uC2DC \uD0A4\uB9CC \uC81C\uAC70\uD558\uACE0, \uB2E4\uB978 \uAE30\uC874 \uD0A4(\uB9B0\uD130 \uB0A0\uC9DC \uD544\uB4DC \uD3EC\uD568)\uB294 \uC720\uC9C0\uD569\uB2C8\uB2E4.",
  "When applying AI suggestions, also remove frontmatter keys by rules below.": "AI \uC81C\uC548 \uC801\uC6A9 \uC2DC \uC544\uB798 \uADDC\uCE59\uC5D0 \uB530\uB77C frontmatter \uD0A4\uB3C4 \uD568\uAED8 \uC815\uB9AC\uD569\uB2C8\uB2E4.",
  "Comma/newline separated keys. Example: related, linked_context": "\uC27C\uD45C/\uC904\uBC14\uAFC8\uC73C\uB85C \uAD6C\uBD84\uD55C \uD0A4 \uBAA9\uB85D\uC785\uB2C8\uB2E4. \uC608: related, linked_context",
  "Scan selected notes and choose keys by checkbox.": "\uC120\uD0DD\uD55C \uB178\uD2B8\uB97C \uC2A4\uCE94\uD574 \uCCB4\uD06C\uBC15\uC2A4\uB85C \uC815\uB9AC \uD0A4\uB97C \uC120\uD0DD\uD569\uB2C8\uB2E4.",
  "Comma/newline separated prefixes. Example: temp_, draft_": "\uC27C\uD45C/\uC904\uBC14\uAFC8\uC73C\uB85C \uAD6C\uBD84\uD55C \uC811\uB450\uC5B4 \uBAA9\uB85D\uC785\uB2C8\uB2E4. \uC608: temp_, draft_",
  "Comma/newline separated keys that override cleanup rules.": "\uC815\uB9AC \uADDC\uCE59\uBCF4\uB2E4 \uC6B0\uC120\uD558\uB294 \uD0A4 \uBAA9\uB85D(\uC27C\uD45C/\uC904\uBC14\uAFC8 \uAD6C\uBD84)\uC785\uB2C8\uB2E4.",
  "Use command palette: apply='Cleanup frontmatter properties for selected notes', preview='Dry-run cleanup frontmatter properties for selected notes'.": "\uBA85\uB839 \uD314\uB808\uD2B8 \uC0AC\uC6A9: apply='Cleanup frontmatter properties for selected notes', preview='Dry-run cleanup frontmatter properties for selected notes'.",
  "Vault-relative folder for cleanup dry-run report files.": "\uC815\uB9AC dry-run \uB9AC\uD3EC\uD2B8 \uC800\uC7A5\uC6A9 vault-relative \uD3F4\uB354\uC785\uB2C8\uB2E4.",
  "Helps keep stable output and reduce linter churn.": "\uCD9C\uB825 \uC548\uC815\uC131\uC744 \uB192\uC774\uACE0 \uB9B0\uD130 \uBCC0\uACBD \uC7A1\uC74C\uC744 \uC904\uC5EC\uC90D\uB2C8\uB2E4.",
  "Controls path width in Select target notes/folders modal (45-100).": "Select target notes/folders \uBAA8\uB2EC\uC758 \uACBD\uB85C \uB108\uBE44\uB97C \uC870\uC808\uD569\uB2C8\uB2E4(45-100).",
  "Comma-separated substrings. Matched folders are ignored during selection/analysis.": "\uC27C\uD45C\uB85C \uAD6C\uBD84\uD55C \uBB38\uC790\uC5F4 \uD328\uD134\uC785\uB2C8\uB2E4. \uC77C\uCE58\uD558\uB294 \uD3F4\uB354\uB294 \uC120\uD0DD/\uBD84\uC11D\uC5D0\uC11C \uC81C\uC678\uB429\uB2C8\uB2E4.",
  "You can also override this every run from the backup confirmation dialog.": "\uBC31\uC5C5 \uD655\uC778 \uB300\uD654\uC0C1\uC790\uC5D0\uC11C \uC2E4\uD589\uB9C8\uB2E4 \uC774 \uC124\uC815\uC744 \uB36E\uC5B4\uC4F8 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
  "Vault-relative folder path used for versioned backups.": "\uBC84\uC804\uD615 \uBC31\uC5C5\uC5D0 \uC0AC\uC6A9\uD558\uB294 vault-relative \uD3F4\uB354 \uACBD\uB85C\uC785\uB2C8\uB2E4.",
  "Keep only latest N backups (old backups are deleted automatically).": "\uCD5C\uC2E0 N\uAC1C \uBC31\uC5C5\uB9CC \uC720\uC9C0\uD569\uB2C8\uB2E4(\uC624\uB798\uB41C \uBC31\uC5C5\uC740 \uC790\uB3D9 \uC0AD\uC81C).",
  "Vault-relative markdown path.": "vault-relative \uB9C8\uD06C\uB2E4\uC6B4 \uACBD\uB85C\uC785\uB2C8\uB2E4."
};
function toKoreanBilingualParts(originalText, translationMap) {
  var _a;
  const normalized = (_a = originalText == null ? void 0 : originalText.trim()) != null ? _a : "";
  if (!normalized || normalized.includes(" / ")) {
    return null;
  }
  const translated = translationMap[normalized];
  if (!translated) {
    return null;
  }
  return { en: normalized, ko: translated };
}
function splitInlineBilingualText(originalText) {
  var _a, _b;
  const normalized = (_a = originalText == null ? void 0 : originalText.trim()) != null ? _a : "";
  if (!normalized || !normalized.includes(" / ")) {
    return null;
  }
  const parts = normalized.split(" / ");
  if (parts.length < 2) {
    return null;
  }
  const en = ((_b = parts[0]) != null ? _b : "").trim();
  const ko = parts.slice(1).join(" / ").trim();
  if (!en || !ko) {
    return null;
  }
  return { en, ko };
}
var ROLE_MODEL_FALLBACK_VALUE = "__fallback__";
var ROLE_MODEL_SETTING_CONFIGS = [
  {
    key: "qaAskModel",
    role: "ask",
    name: "Ask model (text)",
    description: "Optional role-specific model. Empty uses Q&A model as fallback."
  },
  {
    key: "qaAskVisionModel",
    role: "ask_vision",
    name: "Ask model (vision)",
    description: "Prefer vision-capable models for Ask (vision). Chat supports image attachments (drop/upload/paste)."
  },
  {
    key: "qaImageGeneratorModel",
    role: "image_generator",
    name: "Image generator model",
    description: "Reserved for image-generation workflows. Current chat UI is text-first."
  },
  {
    key: "qaCoderModel",
    role: "coder",
    name: "Coder model",
    description: "Optional role-specific model. Empty uses Q&A model as fallback."
  },
  {
    key: "qaDebuggerModel",
    role: "debugger",
    name: "Debugger model",
    description: "Optional role-specific model. Empty uses Q&A model as fallback."
  },
  {
    key: "qaArchitectModel",
    role: "architect",
    name: "Architect model",
    description: "Optional role-specific model. Empty uses Q&A model as fallback."
  },
  {
    key: "qaOrchestratorModel",
    role: "orchestrator",
    name: "Orchestrator model",
    description: "Optional role-specific model. Empty uses Q&A model as fallback."
  },
  {
    key: "qaSafeguardModel",
    role: "safeguard",
    name: "Safeguard model",
    description: "Optional role-specific model. Empty uses Q&A model as fallback."
  }
];
var CODER_MODEL_REGEX = /(coder|code|codellama|codestral|starcoder|deepseek-coder)/i;
var SAFEGUARD_MODEL_REGEX = /(guard|safeguard|safety|llama-guard)/i;
var VISION_MODEL_REGEX = /(vision|llava|bakllava|moondream|qwen.*vl|pixtral|internvl|minicpm[-_]?v|florence|gemma3)/i;
var IMAGE_GENERATOR_MODEL_REGEX = /(flux|sdxl|stable[-_ ]?diffusion|diffusion|imagegen|image-gen)/i;
var GENERAL_TEXT_MODEL_REGEX = /(qwen|llama|gpt-(?!oss)|gpt-oss|gemma|mistral|devstral|phi|deepseek|yi|claude|gemini|codex|o1|o3|o4)/i;
var CLOUD_OPENAI_MODEL_REGEX = /\b(gpt-(?!oss)|o1|o3|o4|codex)\b/i;
var CLOUD_ANTHROPIC_MODEL_REGEX = /\bclaude\b/i;
var CLOUD_GEMINI_MODEL_REGEX = /\bgemini\b/i;
var LARGE_MODEL_SIZE_REGEX = /:(12|14|20|24|27|30|32|34|70)b\b/i;
var MID_MODEL_SIZE_REGEX = /:(7|8|9|10|11)b\b/i;
var SMALL_MODEL_SIZE_REGEX = /:(0\.[0-9]+|1|2|3|4|5|6)b\b/i;
function extractModelSizeBillions(modelName) {
  const matched = modelName.toLowerCase().match(/:(\d+(?:\.\d+)?)b\b/);
  if (!matched) {
    return null;
  }
  const parsed = Number.parseFloat(matched[1]);
  return Number.isFinite(parsed) ? parsed : null;
}
function isOllamaModelAllowedForQaRole(role, modelName) {
  const trimmed = modelName.trim();
  if (!trimmed) {
    return false;
  }
  if (role === "ask_vision" || role === "image_generator") {
    return VISION_MODEL_REGEX.test(trimmed.toLowerCase());
  }
  return isOllamaModelAnalyzable(trimmed);
}
function scoreRoleModel(role, modelName) {
  if (!isOllamaModelAllowedForQaRole(role, modelName)) {
    return -100;
  }
  const lower = modelName.toLowerCase();
  const isCoder = CODER_MODEL_REGEX.test(lower);
  const isSafeguard = SAFEGUARD_MODEL_REGEX.test(lower);
  const isVision = VISION_MODEL_REGEX.test(lower);
  const isImageGenerator = IMAGE_GENERATOR_MODEL_REGEX.test(lower);
  const isGeneral = GENERAL_TEXT_MODEL_REGEX.test(lower) && !isVision && !isImageGenerator;
  const isLarge = LARGE_MODEL_SIZE_REGEX.test(lower);
  const isMid = MID_MODEL_SIZE_REGEX.test(lower);
  const isSmall = SMALL_MODEL_SIZE_REGEX.test(lower);
  const sizeB = extractModelSizeBillions(lower);
  let score = 0;
  switch (role) {
    case "ask":
      score += isGeneral ? 40 : 20;
      if (isCoder) {
        score -= 16;
      }
      if (isSafeguard) {
        score -= 18;
      }
      if (isVision || isImageGenerator) {
        score -= 12;
      }
      if (isLarge) {
        score += 6;
      } else if (isMid) {
        score += 4;
      } else if (isSmall) {
        score -= 2;
      }
      if (sizeB !== null) {
        if (sizeB >= 12 && sizeB <= 20) {
          score += 6;
        } else if (sizeB > 20) {
          score += 2;
        }
      }
      break;
    case "ask_vision":
      score += isGeneral ? 34 : 18;
      if (isVision) {
        score += 34;
      } else {
        score -= 10;
      }
      if (/llama3\.2-vision/.test(lower)) {
        score += 14;
      }
      if (isCoder) {
        score -= 8;
      }
      if (isSafeguard) {
        score -= 12;
      }
      if (isLarge) {
        score += 6;
      } else if (isMid) {
        score += 4;
      }
      if (sizeB !== null && sizeB >= 12 && sizeB <= 20) {
        score += 6;
      } else if (sizeB !== null && sizeB > 24) {
        score += 1;
      }
      break;
    case "image_generator":
      score += isGeneral ? 28 : 15;
      if (isImageGenerator) {
        score += 8;
      }
      if (/llama3\.2-vision/.test(lower)) {
        score += 10;
      }
      if (isCoder || isSafeguard) {
        score -= 10;
      }
      if (isMid) {
        score += 4;
      }
      if (isLarge) {
        score += 4;
      }
      if (sizeB !== null && sizeB >= 12 && sizeB <= 24) {
        score += 5;
      }
      break;
    case "coder":
    case "debugger":
      score += isCoder ? 60 : 18;
      if (isSafeguard) {
        score -= 20;
      }
      if (isGeneral) {
        score += 8;
      }
      if (isLarge) {
        score += 8;
      } else if (isMid) {
        score += 5;
      } else if (isSmall) {
        score -= 4;
      }
      if (sizeB !== null) {
        if (sizeB >= 20) {
          score += 8;
        } else if (sizeB >= 12) {
          score += 4;
        }
      }
      break;
    case "safeguard":
      score += isSafeguard ? 65 : 18;
      if (isCoder) {
        score -= 18;
      }
      if (isGeneral) {
        score += 8;
      }
      if (isLarge) {
        score += 6;
      }
      if (sizeB !== null && sizeB >= 14) {
        score += 4;
      }
      break;
    case "architect":
    case "orchestrator":
      score += isGeneral ? 38 : 18;
      score += isLarge ? 22 : isMid ? 8 : -2;
      if (isCoder) {
        score -= 8;
      }
      if (isSafeguard) {
        score -= 12;
      }
      if (sizeB !== null) {
        if (sizeB >= 30) {
          score += 14;
        } else if (sizeB >= 20) {
          score += 10;
        } else if (sizeB >= 12) {
          score += 6;
        }
      }
      break;
    default:
      score += 22;
      break;
  }
  if (!isGeneral && !isCoder && !isSafeguard && !(role === "ask_vision" && isVision)) {
    score -= 4;
  }
  if (/qwen3/.test(lower)) {
    score += 4;
  } else if (/gpt-oss/.test(lower)) {
    score += 3;
  } else if (/devstral|mistral/.test(lower)) {
    score += 2;
  } else if (/gemma/.test(lower)) {
    score += 1;
  }
  return score;
}
function buildRoleSpecificOllamaModelOptions(role, models) {
  var _a;
  const scored = models.map((model) => ({ model, score: scoreRoleModel(role, model) })).sort((a, b) => b.score - a.score || a.model.localeCompare(b.model));
  const recommended = (_a = scored.find((item) => item.score > -100)) == null ? void 0 : _a.model;
  const options = models.map((model) => {
    const isRoleCompatible = isOllamaModelAllowedForQaRole(role, model);
    if (!isRoleCompatible) {
      return {
        model,
        status: "unavailable",
        reason: role === "ask_vision" || role === "image_generator" ? "Not suitable for vision/image role." : "Not suitable for current text-based role pipeline."
      };
    }
    if (recommended && model === recommended) {
      return {
        model,
        status: "recommended",
        reason: `Recommended for ${role} role based on detected local model profile.`
      };
    }
    return {
      model,
      status: "available",
      reason: (role === "ask_vision" || role === "image_generator") && VISION_MODEL_REGEX.test(model.toLowerCase()) ? "Available vision-capable model for multimodal role." : "Available text-capable model."
    };
  });
  const weight = (status) => {
    switch (status) {
      case "recommended":
        return 0;
      case "available":
        return 1;
      case "unavailable":
        return 2;
      default:
        return 3;
    }
  };
  return options.sort(
    (a, b) => weight(a.status) - weight(b.status) || a.model.localeCompare(b.model)
  );
}
var QA_ROLE_PRESET_OPTIONS = [
  { value: "ask", label: "Ask (default / \uAE30\uBCF8)" },
  { value: "ask_vision", label: "Ask (vision / \uBE44\uC804)" },
  { value: "image_generator", label: "Image generator / \uC774\uBBF8\uC9C0 \uC0DD\uC131" },
  { value: "orchestrator", label: "Orchestrator / \uC624\uCF00\uC2A4\uD2B8\uB808\uC774\uD130" },
  { value: "coder", label: "Coder / \uCF54\uB354" },
  { value: "debugger", label: "Debugger / \uB514\uBC84\uAC70" },
  { value: "architect", label: "Architect / \uC544\uD0A4\uD14D\uD2B8" },
  { value: "safeguard", label: "Safeguard (security / \uBCF4\uC548)" }
];
var QA_PIPELINE_PRESET_OPTIONS = [
  {
    value: "orchestrator_safeguard",
    label: "Orchestrator -> Safeguard (default / \uAE30\uBCF8)"
  },
  {
    value: "orchestrator_auto_route",
    label: "Orchestrator -> Auto route sub agents -> Safeguard (\uC790\uB3D9 \uB77C\uC6B0\uD305)"
  },
  {
    value: "orchestrator_coder_safeguard",
    label: "Orchestrator -> Coder -> Safeguard"
  },
  {
    value: "orchestrator_architect_safeguard",
    label: "Orchestrator -> Architect -> Safeguard"
  },
  {
    value: "orchestrator_architect_coder_safeguard",
    label: "Orchestrator -> Architect -> Coder -> Safeguard"
  },
  {
    value: "legacy_auto",
    label: "Legacy auto (\uAE30\uC874 \uC790\uB3D9 \uADDC\uCE59)"
  }
];
function getQaPipelinePresetLabel(value) {
  var _a;
  const found = QA_PIPELINE_PRESET_OPTIONS.find((option) => option.value === value);
  return (_a = found == null ? void 0 : found.label) != null ? _a : value;
}
var QA_QUICK_CUSTOM_SLOT_CONFIGS = [
  { key: "qaQuickCustomProfileSlot1", label: "\uCEE4\uC2A4\uD140 1" },
  { key: "qaQuickCustomProfileSlot2", label: "\uCEE4\uC2A4\uD140 2" },
  { key: "qaQuickCustomProfileSlot3", label: "\uCEE4\uC2A4\uD140 3" }
];
var QA_CONVERSATION_MODE_OPTIONS = [
  { value: "ask", label: "Ask" },
  { value: "plan", label: "Plan" },
  { value: "agent", label: "Agent" },
  { value: "orchestration", label: "Orchestration" }
];
function getQaLocalPresetProfileLabel(value) {
  switch (value) {
    case "fast_local":
      return "Flash";
    case "balanced_local":
      return "Pro";
    case "quality_local":
      return "Pro";
    case "custom":
    default:
      return "Custom";
  }
}
function getQaConversationModeLabel(value) {
  var _a;
  const found = QA_CONVERSATION_MODE_OPTIONS.find((option) => option.value === value);
  return (_a = found == null ? void 0 : found.label) != null ? _a : "Ask";
}
var _KnowledgeWeaverSettingTab = class _KnowledgeWeaverSettingTab extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.rolePromptEditorTarget = "ask";
    this.plugin = plugin;
  }
  formatDetectedModelLabel(option) {
    const suffix = option.status === "recommended" ? " (\uCD94\uCC9C)" : option.status === "unavailable" ? " (\uBD88\uAC00)" : "";
    return `${option.model}${suffix}`;
  }
  addRoleModelPickerSetting(containerEl, config, roleOptions) {
    const currentValue = this.plugin.settings[config.key].trim();
    const compatibleOptions = roleOptions.filter((option) => option.status !== "unavailable");
    const hasCompatible = compatibleOptions.length > 0;
    const currentUnavailable = currentValue.length > 0 && !roleOptions.some((option) => option.model === currentValue && option.status !== "unavailable");
    const setting = new import_obsidian4.Setting(containerEl).setName(config.name).setDesc(
      hasCompatible ? currentUnavailable ? `${config.description}
\u26A0 \uD604\uC7AC \uC120\uD0DD \uBAA8\uB378 '${currentValue}'\uC740(\uB294) \uC774 \uC5ED\uD560\uC5D0\uC11C \uBD88\uAC00\uC785\uB2C8\uB2E4. \uD3F4\uBC31 \uB610\uB294 \uAD8C\uC7A5 \uBAA8\uB378\uB85C \uBCC0\uACBD\uD558\uC138\uC694.` : config.description : `${config.description}
\u26A0 \uD604\uC7AC \uAC10\uC9C0\uB41C \uD638\uD658 \uBAA8\uB378\uC774 \uC5C6\uC5B4 \uC774 \uC5ED\uD560\uC740 \uC2E4\uD589 \uBD88\uAC00 \uC0C1\uD0DC\uC785\uB2C8\uB2E4.`
    ).addDropdown((dropdown) => {
      dropdown.addOption(
        ROLE_MODEL_FALLBACK_VALUE,
        "Use Q&A model fallback / Q&A \uBAA8\uB378 \uD3F4\uBC31"
      );
      for (const option of compatibleOptions) {
        dropdown.addOption(option.model, this.formatDetectedModelLabel(option));
      }
      const selected = currentValue && compatibleOptions.some((option) => option.model === currentValue) ? currentValue : ROLE_MODEL_FALLBACK_VALUE;
      dropdown.setValue(selected);
      dropdown.onChange(async (value) => {
        const chosen = roleOptions.find((option) => option.model === value);
        if ((chosen == null ? void 0 : chosen.status) === "unavailable") {
          new import_obsidian4.Notice(`Selected model is marked as (\uBD88\uAC00): ${value}`, 4500);
          this.display();
          return;
        }
        this.plugin.settings[config.key] = value === ROLE_MODEL_FALLBACK_VALUE ? "" : value;
        await this.plugin.saveSettings();
        this.display();
      });
      if (!hasCompatible) {
        dropdown.setDisabled(true);
      }
    });
    if (!hasCompatible) {
      setting.settingEl.addClass("omni-forge-setting-unavailable-model");
      const link = config.role === "ask_vision" || config.role === "image_generator" ? "https://ollama.com/library/qwen2.5vl" : "https://ollama.com/library/qwen3";
      setting.addButton(
        (button) => button.setButtonText("\uCD94\uCC9C \uBAA8\uB378 \uB9C1\uD06C").onClick(() => {
          window.open(link);
        })
      ).addExtraButton(
        (button) => button.setIcon("alert-triangle").setTooltip("\uAC10\uC9C0\uB41C \uD638\uD658 \uBAA8\uB378\uC774 \uC5C6\uC5B4 \uD574\uB2F9 \uC5ED\uD560\uC744 \uC0AC\uC6A9\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.")
      );
    }
  }
  getPresetModelAvailabilityInfo(kind, modelName, presetHint) {
    var _a, _b, _c, _d, _e, _f;
    const current = modelName.trim();
    if (kind === "embedding") {
      const options2 = this.plugin.getEmbeddingModelOptions();
      const detected2 = options2.map((option) => option.model);
      const recommended2 = (_b = (_a = options2.find((option) => option.status === "recommended")) == null ? void 0 : _a.model) != null ? _b : "";
      const available2 = !current || detected2.includes(current);
      if (!current) {
        return {
          available: true,
          note: `\uD604\uC7AC \uBE44\uC5B4 \uC788\uC74C. \uAD8C\uC7A5 \uC784\uBCA0\uB529 \uBAA8\uB378: ${recommended2 || "(none / \uC5C6\uC74C)"}`,
          recommended: recommended2,
          link: "https://ollama.com/library/nomic-embed-text",
          detectedCount: detected2.length
        };
      }
      return {
        available: available2,
        note: available2 ? `\uD604\uC7AC \uBAA8\uB378 \uAC10\uC9C0\uB428: ${current}` : `\u26A0 \uD604\uC7AC \uBAA8\uB378 '${current}'\uC774(\uAC00) \uAC10\uC9C0 \uBAA9\uB85D\uC5D0 \uC5C6\uC2B5\uB2C8\uB2E4. \uC2E4\uD589 \uC2DC \uD3F4\uBC31/\uC131\uB2A5 \uC800\uD558\uAC00 \uBC1C\uC0DD\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.`,
        recommended: recommended2,
        link: "https://ollama.com/library/nomic-embed-text",
        detectedCount: detected2.length
      };
    }
    const options = this.plugin.getOllamaModelOptions();
    const filtered = kind === "vision" ? options.filter((option) => VISION_MODEL_REGEX.test(option.model.toLowerCase())) : options;
    const detected = filtered.map((option) => option.model);
    const recommendedFromPreset = presetHint ? this.plugin.getRecommendedPresetOverrideModelForQa(presetHint, kind) : "";
    const recommended = recommendedFromPreset || (kind === "vision" ? ((_c = filtered.find((option) => option.status === "recommended")) == null ? void 0 : _c.model) || ((_d = filtered.find((option) => option.status === "available")) == null ? void 0 : _d.model) || "" : ((_e = filtered.find((option) => option.status === "recommended")) == null ? void 0 : _e.model) || ((_f = options.find((option) => option.status === "recommended")) == null ? void 0 : _f.model) || "");
    const available = !current || detected.includes(current);
    const link = kind === "vision" ? "https://ollama.com/library/qwen2.5vl" : "https://ollama.com/library/qwen3";
    if (kind === "vision" && detected.length === 0) {
      return {
        available: false,
        note: "\u26A0 \uAC10\uC9C0\uB41C \uBE44\uC804 \uBAA8\uB378\uC774 \uC5C6\uC2B5\uB2C8\uB2E4. Ask(vision) \uC5ED\uD560 \uBC0F \uC774\uBBF8\uC9C0/PDF \uAE30\uBC18 \uCC98\uB9AC\uB294 \uD604\uC7AC \uD65C\uC6A9 \uBD88\uAC00\uC785\uB2C8\uB2E4.",
        recommended: "",
        link,
        detectedCount: 0
      };
    }
    if (!current) {
      return {
        available: true,
        note: `\uD604\uC7AC \uBE44\uC5B4 \uC788\uC74C. \uAD8C\uC7A5 \uBAA8\uB378: ${recommended || "(none / \uC5C6\uC74C)"}`,
        recommended,
        link,
        detectedCount: detected.length
      };
    }
    return {
      available,
      note: available ? `\uD604\uC7AC \uBAA8\uB378 \uAC10\uC9C0\uB428: ${current}` : `\u26A0 \uD604\uC7AC \uBAA8\uB378 '${current}'\uC774(\uAC00) \uAC10\uC9C0 \uBAA9\uB85D\uC5D0 \uC5C6\uC2B5\uB2C8\uB2E4. \uC2E4\uD589 \uC2DC \uD3F4\uBC31/\uC131\uB2A5 \uC800\uD558\uAC00 \uBC1C\uC0DD\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.`,
      recommended,
      link,
      detectedCount: detected.length
    };
  }
  addPresetProfileModelSetting(containerEl, config) {
    const current = this.plugin.settings[config.key].trim();
    const availability = this.getPresetModelAvailabilityInfo(config.kind, current, config.preset);
    const showModelGuideLink = !availability.available || !availability.recommended || availability.detectedCount === 0;
    const setting = new import_obsidian4.Setting(containerEl).setName(config.name).setDesc(`${config.description}
${availability.note}`).addText(
      (text) => text.setPlaceholder(config.placeholder).setValue(current).onChange(async (value) => {
        this.plugin.settings[config.key] = value.trim();
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (showModelGuideLink) {
      setting.addButton(
        (button) => button.setButtonText("\uCD94\uCC9C \uBAA8\uB378 \uB9C1\uD06C").onClick(async () => {
          window.open(availability.link);
        })
      );
    }
    if (availability.recommended) {
      setting.addButton(
        (button) => button.setButtonText("\uAD8C\uC7A5\uAC12").onClick(async () => {
          this.plugin.settings[config.key] = availability.recommended;
          await this.plugin.saveSettings();
          this.display();
        })
      );
    }
    if (!availability.available || config.kind === "vision" && availability.detectedCount === 0) {
      setting.settingEl.addClass("omni-forge-setting-unavailable-model");
      setting.addExtraButton(
        (button) => button.setIcon("alert-triangle").setTooltip(
          config.kind === "vision" && availability.detectedCount === 0 ? "\uBE44\uC804 \uBAA8\uB378\uC774 \uAC10\uC9C0\uB418\uC9C0 \uC54A\uC544 \uD574\uB2F9 \uD504\uB9AC\uC14B \uBE44\uC804 \uACBD\uB85C\uB97C \uC0AC\uC6A9\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4." : "\uAC10\uC9C0\uB418\uC9C0 \uC54A\uC740 \uBAA8\uB378\uC785\uB2C8\uB2E4. \uC124\uCE58/\uC774\uB984 \uD655\uC778\uC774 \uD544\uC694\uD569\uB2C8\uB2E4."
        )
      );
    }
  }
  collectPresetOverrideWarnings() {
    const checks = [
      { name: "Pro base", key: "qaBalancedPresetBaseModel", kind: "text" },
      { name: "Pro vision", key: "qaBalancedPresetVisionModel", kind: "vision" },
      { name: "Pro embedding", key: "qaBalancedPresetEmbeddingModel", kind: "embedding" }
    ];
    const warnings = [];
    for (const check of checks) {
      const value = this.plugin.settings[check.key].trim();
      if (!value) {
        continue;
      }
      const availability = this.getPresetModelAvailabilityInfo(
        check.kind,
        value,
        "balanced_local"
      );
      if (!availability.available) {
        warnings.push({
          name: check.name,
          note: availability.note,
          link: availability.link
        });
      }
    }
    return warnings;
  }
  getRoleModelHealthSummary() {
    const unavailable = [];
    const blockedRoles = [];
    for (const config of ROLE_MODEL_SETTING_CONFIGS) {
      const options = this.plugin.getRoleModelOptionsForQa(config.role);
      const hasCompatible = options.some((option) => option.status !== "unavailable");
      if (!hasCompatible) {
        blockedRoles.push(config.name);
      }
      const selected = this.plugin.settings[config.key].trim();
      if (!selected) {
        continue;
      }
      if (!isOllamaModelAllowedForQaRole(config.role, selected)) {
        unavailable.push(`${config.name}=${selected}`);
      }
    }
    const parts = [];
    if (blockedRoles.length > 0) {
      parts.push(`\uD65C\uC6A9 \uBD88\uAC00 \uC5ED\uD560 ${blockedRoles.length}\uAC1C: ${blockedRoles.join(", ")}`);
    }
    if (unavailable.length > 0) {
      parts.push(`\uBD88\uAC00 \uB9E4\uD551 ${unavailable.length}\uAC1C: ${unavailable.join(", ")}`);
    }
    if (parts.length === 0) {
      parts.push("\uC5ED\uD560 \uBAA8\uB378 \uB9E4\uD551 \uC0C1\uD0DC \uC815\uC0C1(\uBD88\uAC00 \uD56D\uBAA9 \uC5C6\uC74C).");
    }
    return { unavailable, blockedRoles, summary: parts.join(" | ") };
  }
  getVaultFolderOptionsForShellCwd() {
    const seen = /* @__PURE__ */ new Set();
    const folders = this.app.vault.getAllLoadedFiles().filter((entry) => entry instanceof import_obsidian4.TFolder).map((folder) => (0, import_obsidian4.normalizePath)(folder.path)).filter((path) => path.length > 0 && path !== "/").sort((a, b) => a.localeCompare(b, void 0, { sensitivity: "base" }));
    const unique = [];
    for (const folderPath of folders) {
      if (seen.has(folderPath)) {
        continue;
      }
      seen.add(folderPath);
      unique.push(folderPath);
    }
    return unique;
  }
  splitGuideLines(rawText) {
    return (rawText != null ? rawText : "").split(/\n|\|/g).map((line) => line.trim()).filter((line) => line.length > 0);
  }
  addViewModeAndPresetControls(containerEl) {
    const provider = this.plugin.settings.provider;
    const family = provider === "ollama" || provider === "lmstudio" ? "local" : "cloud";
    new import_obsidian4.Setting(containerEl).setName("Chat model profile / \uCC44\uD305 \uBAA8\uB378 \uD504\uB85C\uD544").setDesc("Local: local-flash/local-pro. Cloud: codex/claude/gemini (bridge endpoint required).").addDropdown((dropdown) => {
      const options = this.plugin.getQaChatModelProfileOptionsForQa(family);
      for (const option of options) {
        dropdown.addOption(option.value, option.label);
      }
      const current = this.plugin.getQaChatModelProfileForQa();
      const fallback = options.length > 0 ? options[0].value : "";
      dropdown.setValue(options.some((option) => option.value === current) ? current : fallback);
      dropdown.onChange(async (value) => {
        if (provider === "lmstudio") {
          const normalized = value === "local-pro" ? "local-pro" : "local-flash";
          this.plugin.settings.qaChatModelFamily = "local";
          this.plugin.settings.qaChatModelProfile = normalized;
          this.plugin.settings.qaLocalPresetProfile = normalized === "local-pro" ? "balanced_local" : "fast_local";
          await this.plugin.saveSettings();
          await this.plugin.refreshOpenQaWorkspaceViews();
        } else {
          const summary = await this.plugin.applyQaChatModelProfileForQa(value, family);
          new import_obsidian4.Notice(summary, 6e3);
        }
        this.display();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("Model inventory refresh / \uBAA8\uB378 \uC778\uBCA4\uD1A0\uB9AC \uC0C8\uB85C\uACE0\uCE68").setDesc("Refresh local model detection and embedding inventory now.").addButton(
      (button) => button.setButtonText("Refresh / \uC0C8\uB85C\uACE0\uCE68").onClick(async () => {
        await this.plugin.refreshOllamaDetection({ notify: true, autoApply: true });
        await this.plugin.refreshEmbeddingModelDetection({ notify: false, autoApply: true });
        this.display();
      })
    );
  }
  addChatPresetControls(containerEl) {
    const uiMode = this.plugin.settings.settingsUiLanguage;
    const localize = (en, ko) => uiMode === "en" ? en : uiMode === "ko" ? ko : `${en} / ${ko}`;
    const textOptions = this.plugin.getOllamaModelOptions().filter((option) => option.status !== "unavailable");
    const embeddingOptions = this.plugin.getEmbeddingModelOptions().filter((option) => option.status !== "unavailable");
    const summarizeDetected = (options, limit = 4) => {
      if (options.length === 0) {
        return "(none)";
      }
      const names = options.slice(0, limit).map((option) => option.model);
      return options.length > limit ? `${names.join(", ")} ... (+${options.length - limit})` : names.join(", ");
    };
    const flashText = this.plugin.getRecommendedPresetOverrideModelForQa("fast_local", "text") || "(none)";
    const flashVision = this.plugin.getRecommendedPresetOverrideModelForQa("fast_local", "vision") || "(none)";
    const flashEmbedding = this.plugin.getRecommendedPresetOverrideModelForQa("fast_local", "embedding") || "(none)";
    new import_obsidian4.Setting(containerEl).setName("Flash profile / Flash \uD504\uB85C\uD544").setDesc(
      [
        localize(`Detected text models: ${summarizeDetected(textOptions)}`, `감지 텍스트 모델: ${summarizeDetected(textOptions)}`),
        localize(`Detected embedding models: ${summarizeDetected(embeddingOptions)}`, `감지 임베딩 모델: ${summarizeDetected(embeddingOptions)}`),
        localize(`Recommended: text=${flashText}, vision=${flashVision}, embedding=${flashEmbedding}`, `추천값: text=${flashText}, vision=${flashVision}, embedding=${flashEmbedding}`)
      ].join("\n")
    ).addButton(
      (button) => button.setButtonText(localize("Apply Flash", "Flash 적용")).onClick(async () => {
        const summary = await this.plugin.applyQaChatModelProfileForQa("local-flash", "local");
        new import_obsidian4.Notice(summary, 6500);
        this.display();
      })
    );
    const proText = this.plugin.getRecommendedPresetOverrideModelForQa("balanced_local", "text") || "(none)";
    const proVision = this.plugin.getRecommendedPresetOverrideModelForQa("balanced_local", "vision") || "(none)";
    const proEmbedding = this.plugin.getRecommendedPresetOverrideModelForQa("balanced_local", "embedding") || "(none)";
    new import_obsidian4.Setting(containerEl).setName("Pro profile / Pro \uD504\uB85C\uD544").setDesc(
      [
        localize(`Detected text models: ${summarizeDetected(textOptions)}`, `감지 텍스트 모델: ${summarizeDetected(textOptions)}`),
        localize(`Detected embedding models: ${summarizeDetected(embeddingOptions)}`, `감지 임베딩 모델: ${summarizeDetected(embeddingOptions)}`),
        localize(`Recommended: text=${proText}, vision=${proVision}, embedding=${proEmbedding}`, `추천값: text=${proText}, vision=${proVision}, embedding=${proEmbedding}`)
      ].join("\n")
    ).addButton(
      (button) => button.setButtonText(localize("Apply Pro", "Pro 적용")).onClick(async () => {
        const summary = await this.plugin.applyQaChatModelProfileForQa("local-pro", "local");
        new import_obsidian4.Notice(summary, 6500);
        this.display();
      })
    ).addButton(
      (button) => button.setButtonText(localize("Refresh detect", "감지 새로고침")).onClick(async () => {
        await this.plugin.refreshOllamaDetection({ notify: true, autoApply: true });
        await this.plugin.refreshEmbeddingModelDetection({ notify: false, autoApply: true });
        this.display();
      })
    );
  }
  addSettingsTabSwitcher(containerEl) {
    const row = containerEl.createDiv({ cls: "omni-forge-settings-tab-row" });
    const mode = this.plugin.settings.settingsUiLanguage;
    for (const tab of _KnowledgeWeaverSettingTab.TAB_OPTIONS) {
      const label = mode === "en" ? tab.en : mode === "ko" ? tab.ko : `${tab.en} / ${tab.ko}`;
      const button = row.createEl("button", { text: label });
      button.addClass("omni-forge-settings-tab-btn");
      if (this.plugin.settings.settingsActiveTab === tab.key) {
        button.addClass("is-active");
      }
      button.onclick = async () => {
        if (this.plugin.settings.settingsActiveTab === tab.key) {
          return;
        }
        this.plugin.settings.settingsActiveTab = tab.key;
        await this.plugin.saveSettings();
        this.display();
      };
    }
  }
  addSettingsLanguageControl(containerEl) {
    const languageSetting = new import_obsidian4.Setting(containerEl).setName("Settings UI language").setDesc("Choose language style used in setting labels/descriptions across all tabs.").addDropdown(
      (dropdown) => dropdown.addOption("ko", "[KO] \uD55C\uAD6D\uC5B4").addOption("en", "[EN] English").addOption("bilingual", "[KO/EN] Bilingual").setValue(this.plugin.settings.settingsUiLanguage).onChange(async (value) => {
        const next = value === "en" || value === "bilingual" ? value : "ko";
        this.plugin.settings.settingsUiLanguage = next;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    languageSetting.settingEl.addClass("omni-forge-settings-quick");
  }
  isSectionVisibleForTab(sectionTitle, tab) {
    if (tab === "advanced") {
      return true;
    }
    if (tab === "guide") {
      return false;
    }
    switch (tab) {
      case "quick":
        return sectionTitle === "__prelude" || sectionTitle === "Local provider config" || sectionTitle === "Cloud provider config" || sectionTitle === "Local Q&A (security-first) / \uB85C\uCEEC Q&A (\uBCF4\uC548 \uC6B0\uC120)";
      case "analyzed":
        return sectionTitle === "Behavior" || sectionTitle === "Semantic linking (Ollama embeddings)" || sectionTitle === "Property cleanup" || sectionTitle === "Selection and backup" || sectionTitle === "MOC";
      case "chat":
        return sectionTitle === "__prelude" || sectionTitle === "Behavior" || sectionTitle === "Local Q&A (security-first) / \uB85C\uCEEC Q&A (\uBCF4\uC548 \uC6B0\uC120)";
      case "orchestration":
        return sectionTitle === "__prelude" || sectionTitle === "Local Q&A (security-first) / \uB85C\uCEEC Q&A (\uBCF4\uC548 \uC6B0\uC120)" || sectionTitle === "Pipeline prompt tips / \uD30C\uC774\uD504\uB77C\uC778 \uD504\uB86C\uD504\uD2B8 \uD301";
      default:
        return true;
    }
  }
  settingNameStartsWithPrefixes(name, prefixes) {
    return prefixes.some(
      (prefix) => name.startsWith(prefix)
    );
  }
  isSettingVisibleForTab(name, tab) {
    if (name.startsWith("Settings UI language")) {
      return true;
    }
    switch (tab) {
      case "quick":
        return this.settingNameStartsWithPrefixes(
          name,
          _KnowledgeWeaverSettingTab.QUICK_TAB_VISIBLE_NAME_PREFIXES
        );
      case "analyzed":
        {
          const visible = this.settingNameStartsWithPrefixes(
            name,
            _KnowledgeWeaverSettingTab.ANALYZED_TAB_VISIBLE_NAME_PREFIXES
          );
          if (!visible) {
            return false;
          }
          if (this.plugin.settings.provider !== "ollama" && this.settingNameStartsWithPrefixes(name, _KnowledgeWeaverSettingTab.ANALYZED_OLLAMA_ONLY_PREFIXES)) {
            return false;
          }
          return true;
        }
      case "chat":
        {
          const visible = this.settingNameStartsWithPrefixes(
            name,
            _KnowledgeWeaverSettingTab.CHAT_TAB_VISIBLE_NAME_PREFIXES
          );
          if (!visible) {
            return false;
          }
          if (this.plugin.settings.provider !== "ollama" && this.settingNameStartsWithPrefixes(name, _KnowledgeWeaverSettingTab.CHAT_OLLAMA_ONLY_PREFIXES)) {
            return false;
          }
          if (this.plugin.settings.provider !== "ollama" && this.plugin.settings.provider !== "lmstudio" && this.settingNameStartsWithPrefixes(name, _KnowledgeWeaverSettingTab.CHAT_LOCAL_PROFILE_PREFIXES)) {
            return false;
          }
          return true;
        }
      case "orchestration":
        return this.settingNameStartsWithPrefixes(
          name,
          _KnowledgeWeaverSettingTab.ORCHESTRATION_TAB_VISIBLE_NAME_PREFIXES
        );
      case "advanced":
        return this.settingNameStartsWithPrefixes(
          name,
          _KnowledgeWeaverSettingTab.ADVANCED_TAB_VISIBLE_NAME_PREFIXES
        );
      case "skills":
      case "parser":
      case "guide":
        return false;
      default:
        return true;
    }
  }
  moveSectionBlockToTop(containerEl, title) {
    const children = Array.from(containerEl.children);
    const targetHeader = children.find(
      (child) => child instanceof HTMLElement && child.tagName === "H3" && ((child.textContent || "").trim() === title)
    );
    if (!(targetHeader instanceof HTMLElement)) {
      return;
    }
    const firstSectionHeader = children.find(
      (child) => child instanceof HTMLElement && child.tagName === "H3"
    );
    if (!(firstSectionHeader instanceof HTMLElement) || firstSectionHeader === targetHeader) {
      return;
    }
    const blockNodes = [];
    let cursor = targetHeader;
    while (cursor instanceof HTMLElement) {
      blockNodes.push(cursor);
      const next = cursor.nextElementSibling;
      if (!(next instanceof HTMLElement) || next.tagName === "H3") {
        break;
      }
      cursor = next;
    }
    const fragment = document.createDocumentFragment();
    for (const node of blockNodes) {
      fragment.appendChild(node);
    }
    containerEl.insertBefore(fragment, firstSectionHeader);
  }
  prioritizeAnalyzedEmbeddingSection(containerEl) {
    this.moveSectionBlockToTop(containerEl, "Behavior");
  }
  applySettingsTabVisibility(containerEl) {
    var _a, _b, _c, _d, _e, _f, _g;
    const activeTab = this.plugin.settings.settingsActiveTab;
    if (activeTab === "guide") {
      return;
    }
    let currentSection = "__prelude";
    for (const child of Array.from(containerEl.children)) {
      if (!(child instanceof HTMLElement)) {
        continue;
      }
      if (child.tagName === "H2" || child.classList.contains("omni-forge-settings-tab-row") || child.classList.contains("omni-forge-settings-mode-note")) {
        continue;
      }
      if (child.tagName === "P" && !child.classList.contains("setting-item")) {
        continue;
      }
      if (child.tagName === "H3") {
        currentSection = ((_a = child.textContent) != null ? _a : "").trim();
        const visible = this.isSectionVisibleForTab(currentSection, activeTab);
        child.classList.toggle("omni-forge-hidden-tab", !visible);
        continue;
      }
      let shouldHide = !this.isSectionVisibleForTab(currentSection, activeTab);
      if (!shouldHide && child.classList.contains("setting-item")) {
        const name = (_d = (_c = (_b = child.querySelector(".setting-item-name")) == null ? void 0 : _b.textContent) == null ? void 0 : _c.trim()) != null ? _d : "";
        if (name && !this.isSettingVisibleForTab(name, activeTab)) {
          shouldHide = true;
        }
      } else if (shouldHide && child.classList.contains("setting-item")) {
        const name = (_g = (_f = (_e = child.querySelector(".setting-item-name")) == null ? void 0 : _e.textContent) == null ? void 0 : _f.trim()) != null ? _g : "";
        if (name.startsWith("Settings UI language")) {
          shouldHide = false;
        }
      }
      if (shouldHide) {
        child.classList.add("omni-forge-hidden-tab");
      }
    }
  }
  hideEmptySettingSections(containerEl) {
    const children = Array.from(containerEl.children).filter(
      (child) => child instanceof HTMLElement
    );
    for (let i = 0; i < children.length; i += 1) {
      const child = children[i];
      if (child.tagName !== "H3") {
        continue;
      }
      let hasVisibleSetting = false;
      for (let j = i + 1; j < children.length; j += 1) {
        const candidate = children[j];
        if (candidate.tagName === "H3") {
          break;
        }
        if (!candidate.classList.contains("setting-item")) {
          continue;
        }
        if (!candidate.classList.contains("omni-forge-hidden-tab") && !candidate.classList.contains("omni-forge-hidden-simple")) {
          hasVisibleSetting = true;
          break;
        }
      }
      child.classList.toggle("omni-forge-hidden-tab", !hasVisibleSetting);
    }
  }
  isSimpleEssentialSettingName(name) {
    return _KnowledgeWeaverSettingTab.SIMPLE_VISIBLE_NAME_PREFIXES.some(
      (prefix) => name.startsWith(prefix)
    );
  }
  applyCompactSettingsVisibility(containerEl) {
    var _a, _b, _c, _d;
    if (this.plugin.settings.settingsViewMode !== "simple") {
      return;
    }
    if (this.plugin.settings.settingsActiveTab !== "quick") {
      return;
    }
    let hideSection = false;
    for (const child of Array.from(containerEl.children)) {
      if (child.tagName === "H3") {
        const title = ((_a = child.textContent) != null ? _a : "").trim();
        hideSection = _KnowledgeWeaverSettingTab.SIMPLE_HIDDEN_SECTION_TITLES.has(title);
        child.toggleClass("omni-forge-hidden-simple", hideSection);
        continue;
      }
      if (hideSection) {
        child.classList.add("omni-forge-hidden-simple");
      }
    }
    const items = containerEl.querySelectorAll(".setting-item");
    for (const item of Array.from(items)) {
      const name = (_d = (_c = (_b = item.querySelector(".setting-item-name")) == null ? void 0 : _b.textContent) == null ? void 0 : _c.trim()) != null ? _d : "";
      if (!name) {
        continue;
      }
      const hiddenByKeyword = _KnowledgeWeaverSettingTab.SIMPLE_HIDDEN_NAME_KEYWORDS.some(
        (keyword) => name.includes(keyword)
      );
      const hiddenByNonEssential = !this.isSimpleEssentialSettingName(name);
      const shouldHide = hiddenByKeyword || hiddenByNonEssential;
      if (shouldHide) {
        item.classList.add("omni-forge-hidden-simple");
      }
    }
  }
  renderGuideTab(containerEl) {
    containerEl.createEl("h3", { text: "Quick preset guide / \uBE60\uB978 \uC124\uC815 \uAC00\uC774\uB4DC" });
    containerEl.createEl("p", {
      text: [
        "One-click presets detect local models first.",
        "Then they auto-assign base/role/embedding models by preset + hardware capability."
      ].join("\n"),
      cls: "omni-forge-settings-guide-note omni-forge-settings-guide-preline"
    });
    containerEl.createEl("h3", { text: "Preset warning snapshot / \uD504\uB9AC\uC14B \uACBD\uACE0 \uC2A4\uB0C5\uC0F7" });
    const warningList = containerEl.createEl("ul", { cls: "omni-forge-settings-guide-list" });
    const warnings = this.collectPresetOverrideWarnings();
    if (warnings.length === 0) {
      warningList.createEl("li", { text: "\uD604\uC7AC \uD504\uB9AC\uC14B \uC624\uBC84\uB77C\uC774\uB4DC \uACBD\uACE0(\u26A0) \uC5C6\uC74C" });
    } else {
      for (const warning of warnings) {
        warningList.createEl("li", {
          text: `${warning.name}: ${warning.note}`
        });
      }
    }
    warningList.createEl("li", {
      text: "\uB9B4\uB9AC\uC988 \uC804\uC5D0\uB294 \uACBD\uACE0(\u26A0)\uAC00 \uBD99\uC740 \uD504\uB9AC\uC14B \uC624\uBC84\uB77C\uC774\uB4DC \uD544\uB4DC\uB97C \uC6B0\uC120 \uD655\uC778\uD558\uC138\uC694."
    });
    new import_obsidian4.Setting(containerEl).setName("Hardware snapshot / \uCEF4\uD4E8\uD130 \uC0AC\uC591 \uBCF4\uAE30").setDesc(this.plugin.getHardwareCapabilitySummaryForQa()).addButton(
      (button) => button.setButtonText("Open summary").onClick(async () => {
        new import_obsidian4.Notice(this.plugin.getHardwareCapabilitySummaryForQa(), 7e3);
      })
    );
    const detectedModels = this.plugin.getOllamaModelOptions();
    const hardwareSummary = this.plugin.getHardwareCapabilitySummaryForQa();
    const readiness = containerEl.createDiv({ cls: "omni-forge-settings-guide-card" });
    readiness.createEl("strong", {
      text: detectedModels.length > 0 ? `Local AI ready: ${detectedModels.length} model(s) detected` : "Local AI not ready: no Ollama model detected"
    });
    const readinessLines = detectedModels.length > 0 ? this.splitGuideLines(this.plugin.getOllamaDetectionSummary()) : [
      "Install/start Ollama.",
      "Pull at least one text model + one vision model + one embedding model."
    ];
    const hardwareLines = this.splitGuideLines(hardwareSummary);
    const readinessList = readiness.createEl("ul", {
      cls: "omni-forge-settings-guide-list omni-forge-settings-guide-card-list"
    });
    for (const line of [...readinessLines, ...hardwareLines]) {
      readinessList.createEl("li", { text: line });
    }
    containerEl.createEl("h3", { text: "When to use each preset / \uD504\uB9AC\uC14B \uC120\uD0DD \uAE30\uC900" });
    const presetList = containerEl.createEl("ul", { cls: "omni-forge-settings-guide-list" });
    presetList.createEl("li", {
      text: "Flash: \uBB38\uC11C 1~20\uAC1C \uAE30\uBC18 \uBE60\uB978 \uC870\uD68C/\uC694\uC57D. Role/Pipeline\uC744 \uACBD\uB7C9 \uACE0\uC815\uD574 \uC9C0\uC5F0\uC744 \uCD5C\uC18C\uD654\uD569\uB2C8\uB2E4."
    });
    presetList.createEl("li", {
      text: "Pro: \uC218\uC2ED~\uC218\uBC31\uAC1C \uBB38\uC11C \uBD84\uC11D/\uC778\uC0AC\uC774\uD2B8/\uCD08\uC548 \uC791\uC131. Orchestrator/Safeguard \uC911\uC2EC\uC73C\uB85C \uD488\uC9C8\uACFC \uC18D\uB3C4\uB97C \uADE0\uD615\uD654\uD569\uB2C8\uB2E4."
    });
    presetList.createEl("li", {
      text: "\uB85C\uCEEC \uBAA8\uB378\uC774 \uAC10\uC9C0\uB418\uC9C0 \uC54A\uC73C\uBA74 \uD504\uB9AC\uC14B\uC740 \uBCF4\uC548/\uB3D9\uC791 \uAE30\uBCF8\uAC12\uB9CC \uC801\uC6A9\uD558\uACE0 \uAE30\uC874 Provider\uB97C \uC720\uC9C0\uD569\uB2C8\uB2E4."
    });
    containerEl.createEl("h3", { text: "Chat shortcut reference / \uCC44\uD305 \uB2E8\uCD95\uD0A4 \uC548\uB0B4" });
    const shortcutList = containerEl.createEl("ul", { cls: "omni-forge-settings-guide-list" });
    shortcutList.createEl("li", {
      text: "Enter: \uC804\uC1A1"
    });
    shortcutList.createEl("li", {
      text: "Shift+Enter: \uC904\uBC14\uAFC8"
    });
    shortcutList.createEl("li", {
      text: "Ctrl/Cmd+V: \uC774\uBBF8\uC9C0/\uD14D\uC2A4\uD2B8/PDF \uCCA8\uBD80 \uBD99\uC5EC\uB123\uAE30"
    });
    shortcutList.createEl("li", {
      text: "\uC911\uC9C0 \uBC84\uD2BC(Stop): \uC2A4\uD2B8\uB9AC\uBC0D/\uB9AC\uD2B8\uB9AC\uBC8C/\uD6C4\uCC98\uB9AC \uC989\uC2DC \uC911\uB2E8"
    });
    containerEl.createEl("h3", { text: "Agent external-path policy / \uC5D0\uC774\uC804\uD2B8 \uC678\uBD80 \uACBD\uB85C \uC815\uCC45" });
    const securityGuideList = containerEl.createEl("ul", { cls: "omni-forge-settings-guide-list" });
    securityGuideList.createEl("li", {
      text: "\uAE30\uBCF8\uAC12\uC740 \uBCF4\uC218\uC801(vault \uBC94\uC704)\uC785\uB2C8\uB2E4. \uC678\uBD80 \uC808\uB300\uACBD\uB85C \uC811\uADFC\uC740 allowlist \uB610\uB294 full access \uC870\uAC74\uC5D0\uC11C\uB9CC \uD5C8\uC6A9\uB429\uB2C8\uB2E4."
    });
    securityGuideList.createEl("li", {
      text: "full access\uB97C \uCF1C\uAE30 \uC804\uC5D0\uB294 allowlist \uACBD\uB85C\uB97C \uBA3C\uC800 \uC9C0\uC815\uD558\uACE0, \uD544\uC694\uD55C \uCD5C\uC18C \uBC94\uC704\uB9CC \uB4F1\uB85D\uD558\uC138\uC694."
    });
    securityGuideList.createEl("li", {
      text: "\uC2DC\uC2A4\uD15C \uD504\uB86C\uD504\uD2B8\uC5D0 '\uC678\uBD80 \uACBD\uB85C \uC811\uADFC \uC2DC \uBC18\uB4DC\uC2DC \uD5C8\uC6A9 \uACBD\uB85C/\uC2B9\uC778 \uC870\uAC74/\uB85C\uADF8 \uAE30\uB85D' \uADDC\uCE59\uC744 \uBA85\uC2DC\uD558\uBA74 \uC815\uCC45 \uCDA9\uB3CC\uC744 \uC904\uC77C \uC218 \uC788\uC2B5\uB2C8\uB2E4."
    });
    securityGuideList.createEl("li", {
      text: "\uC0C1\uC138 \uC815\uCC45\uC740 README\uC758 \uBCF4\uC548 \uC8FC\uC758\uC0AC\uD56D \uC139\uC158\uC744 \uCC38\uACE0\uD558\uC138\uC694."
    });
    containerEl.createEl("h3", { text: "PDF parsing notes / PDF \uD30C\uC2F1 \uACE0\uB824\uC0AC\uD56D" });
    const pdfGuideList = containerEl.createEl("ul", { cls: "omni-forge-settings-guide-list" });
    pdfGuideList.createEl("li", {
      text: "PDF\uB294 pdftotext -> OCR(tesseract/pdftoppm) -> fallback \uCCB4\uC778\uC73C\uB85C \uBCF8\uBB38 \uCD94\uCD9C\uC744 \uC2DC\uB3C4\uD569\uB2C8\uB2E4."
    });
    pdfGuideList.createEl("li", {
      text: "\uC774\uBBF8\uC9C0 \uCCA8\uBD80\uB3C4 OCR \uD30C\uC11C\uB97C \uD1B5\uD574 \uD14D\uC2A4\uD2B8\uB97C \uBCF4\uAC15\uD569\uB2C8\uB2E4. \uB2E8, \uD45C/\uC218\uC2DD/\uC2A4\uCE94\uC740 \uC624\uC778\uC2DD \uAC00\uB2A5\uC131\uC774 \uC788\uC5B4 \uD575\uC2EC \uAD6C\uAC04 \uD14D\uC2A4\uD2B8 \uBC1C\uCDCC\uB97C \uD568\uAED8 \uCCA8\uBD80\uD558\uC138\uC694."
    });
    pdfGuideList.createEl("li", {
      text: "\uCD9C\uCC98 \uC815\uD655\uC131\uC774 \uC911\uC694\uD55C \uC791\uC5C5(\uD3C9\uAC00\uACC4\uD68D/\uBC95\uC801 \uBB38\uC11C)\uC740 PDF \uC6D0\uBB38 \uD398\uC774\uC9C0 \uBC88\uD638\uB97C \uD568\uAED8 \uC694\uAD6C\uD558\uB3C4\uB85D \uD504\uB86C\uD504\uD2B8\uB97C \uACE0\uC815\uD558\uC138\uC694."
    });
    pdfGuideList.createEl("li", {
      text: "\uC0C1\uC138 \uC6B4\uC601 \uD301\uC740 README\uC758 \uBB38\uC81C \uD574\uACB0 \uC139\uC158\uC744 \uCC38\uACE0\uD558\uC138\uC694."
    });
    containerEl.createEl("h3", { text: "Reference models by tier / \uD2F0\uC5B4\uBCC4 \uCC38\uACE0 \uBAA8\uB378" });
    const modelList = containerEl.createEl("ul", { cls: "omni-forge-settings-guide-list" });
    modelList.createEl("li", {
      text: "Flash tier text: qwen3:8b / llama3.1:8b / gemma3:4b"
    });
    modelList.createEl("li", {
      text: "Pro tier text: qwen3:14b / gpt-oss:20b / qwen3:30b (\uD658\uACBD \uC758\uC874)"
    });
    modelList.createEl("li", {
      text: "Vision: qwen2.5vl \uACC4\uC5F4, llava \uACC4\uC5F4"
    });
    modelList.createEl("li", {
      text: "Embedding: nomic-embed-text, bge-m3, mxbai-embed-large, e5/gte \uACC4\uC5F4"
    });
    containerEl.createEl("pre", {
      cls: "omni-forge-settings-guide-code",
      text: [
        "ollama pull qwen3:8b",
        "ollama pull qwen3:14b",
        "ollama pull qwen2.5vl:7b",
        "ollama pull nomic-embed-text"
      ].join("\n")
    });
    containerEl.createEl("h3", { text: "Official references / \uACF5\uC2DD \uCC38\uACE0" });
    const refList = containerEl.createEl("ul", { cls: "omni-forge-settings-guide-list" });
    const references = [
      "https://ollama.com/library/qwen3",
      "https://ollama.com/library/qwen2.5vl",
      "https://ollama.com/library/nomic-embed-text",
      "https://docs.ollama.com/api/chat",
      "https://docs.ollama.com/api/generate"
    ];
    for (const url of references) {
      const item = refList.createEl("li");
      item.createEl("a", { text: url, href: url });
    }
  }
  renderOrchestrationTab(containerEl) {
    const mode = this.plugin.settings.settingsUiLanguage;
    const t = (en, ko) => mode === "en" ? en : mode === "ko" ? ko : `${en} / ${ko}`;
    containerEl.createEl("h3", { text: "Orchestration controls / \uC624\uCF00\uC2A4\uD2B8\uB808\uC774\uC158 \uC81C\uC5B4" });
    containerEl.createEl("p", {
      cls: "omni-forge-settings-guide-note",
      text: "\uB0B4\uBD80 \uBB38\uC11C \uBCF4\uD638\uB97C \uC6B0\uC120\uD558\uBA70, \uC678\uBD80 \uC5F0\uACB0\uC740 allowlist \uAE30\uBC18\uC73C\uB85C \uC81C\uD55C\uB41C \uC0C1\uD0DC\uC5D0\uC11C\uB9CC \uC2E4\uD589\uD558\uC138\uC694."
    });
    new import_obsidian4.Setting(containerEl).setName("Conversation mode (chat runtime)").setDesc("\uC624\uCF00\uC2A4\uD2B8\uB808\uC774\uC158 \uC911\uC2EC\uC73C\uB85C \uBAA8\uB4DC\uB97C \uACE0\uC815\uD558\uACE0 \uD30C\uC774\uD504\uB77C\uC778 \uAE30\uBCF8\uAC12\uC744 \uB9DE\uCDA5\uB2C8\uB2E4.").addButton(
      (button) => button.setButtonText(t("Apply orchestration mode", "\uC624\uCF00\uC2A4\uD2B8\uB808\uC774\uC158 \uBAA8\uB4DC \uC801\uC6A9")).setCta().onClick(async () => {
        await this.plugin.setQaConversationModeForQa("orchestration");
        await this.plugin.applyRecommendedRoleModelsForQa(false, true);
        this.display();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Debugger agent / \uB514\uBC84\uAC70 \uC5D0\uC774\uC804\uD2B8").setDesc(
      t(`Current debugger model: ${this.plugin.getQaModelLabelForQa("debugger")}`, `\uD604\uC7AC \uB514\uBC84\uAC70 \uBAA8\uB378: ${this.plugin.getQaModelLabelForQa("debugger")}`)
    ).addButton(
      (button) => button.setButtonText(t("Apply debugger recommendation", "\uB514\uBC84\uAC70 \uCD94\uCC9C \uC801\uC6A9")).onClick(async () => {
        await this.plugin.refreshOllamaDetection({ notify: false, autoApply: true });
        await this.plugin.applyRecommendedRoleModelsForQa(true, true);
        this.display();
      })
    );
    const health = this.getRoleModelHealthSummary();
    const hasIssue = health.blockedRoles.length > 0 || health.unavailable.length > 0;
    const readinessSetting = new import_obsidian4.Setting(containerEl).setName("Orchestration agent readiness / \uC624\uCF00\uC2A4\uD2B8\uB808\uC774\uC158 \uC5D0\uC774\uC804\uD2B8 \uC900\uBE44 \uC0C1\uD0DC").setDesc(
      hasIssue ? `${health.summary}
\uD544\uC218 \uC5ED\uD560 \uBAA8\uB378\uC774 \uC5C6\uC73C\uBA74 \uD30C\uC774\uD504\uB77C\uC778 \uC5D0\uC774\uC804\uD2B8\uAC00 \uC77C\uBD80 \uC0DD\uB7B5\uB429\uB2C8\uB2E4.` : "\uBAA8\uB4E0 \uC5ED\uD560 \uBAA8\uB378 \uC0C1\uD0DC\uAC00 \uC815\uC0C1\uC785\uB2C8\uB2E4."
    );
    if (hasIssue) {
      readinessSetting.addButton(
        (button) => button.setButtonText(t("Text model link", "\uD14D\uC2A4\uD2B8 \uBAA8\uB378 \uB9C1\uD06C")).onClick(() => {
          window.open("https://ollama.com/library/qwen3");
        })
      ).addButton(
        (button) => button.setButtonText(t("Vision model link", "\uBE44\uC804 \uBAA8\uB378 \uB9C1\uD06C")).onClick(() => {
          window.open("https://ollama.com/library/qwen2.5vl");
        })
      ).addButton(
        (button) => button.setButtonText(t("Embedding model link", "\uC784\uBCA0\uB529 \uBAA8\uB378 \uB9C1\uD06C")).onClick(() => {
          window.open("https://ollama.com/library/nomic-embed-text");
        })
      );
    }
  }
  renderSkillsTab(containerEl) {
    containerEl.createEl("h3", { text: "Skills manager / \uC2A4\uD0AC \uAD00\uB9AC" });
    containerEl.createEl("p", {
      cls: "omni-forge-settings-guide-note",
      text: "SKILL.md \uAC00 \uC788\uB294 \uD3F4\uB354\uB97C \uC9C0\uC815\uD558\uBA74 \uC2A4\uD0AC \uBB38\uC11C\uB97C \uC790\uB3D9 \uD0D0\uC9C0\uD574 \uC81C\uBAA9/\uC694\uC57D\uC744 \uBCF4\uC5EC\uC90D\uB2C8\uB2E4."
    });
    const resultEl = containerEl.createDiv({ cls: "omni-forge-settings-guide-card" });
    const renderScanResult = async () => {
      const root = this.plugin.settings.qaSkillsRootPath.trim();
      if (!root) {
        resultEl.setText("Skills folder path is empty. / \uC2A4\uD0AC \uD3F4\uB354 \uACBD\uB85C\uAC00 \uBE44\uC5B4 \uC788\uC2B5\uB2C8\uB2E4.");
        return;
      }
      const scanned = await this.plugin.scanSkillsFolderForQa(root);
      resultEl.empty();
      if (scanned.error) {
        resultEl.createEl("strong", { text: `Scan failed / \uD0D0\uC9C0 \uC2E4\uD328: ${scanned.error}` });
        return;
      }
      resultEl.createEl("strong", { text: `Detected ${scanned.skills.length} skill(s) / \uD0D0\uC9C0 ${scanned.skills.length}\uAC1C` });
      const list = resultEl.createEl("ul", { cls: "omni-forge-settings-guide-list" });
      if (scanned.skills.length === 0) {
        list.createEl("li", { text: "No SKILL.md found under the selected root. / \uC120\uD0DD \uACBD\uB85C\uC5D0\uC11C SKILL.md\uB97C \uCC3E\uC9C0 \uBABB\uD588\uC2B5\uB2C8\uB2E4." });
        return;
      }
      for (const skill of scanned.skills) {
        const item = list.createEl("li");
        item.createEl("div", { text: `${skill.id}: ${skill.title}` });
        item.createEl("small", {
          text: skill.summary || skill.docPath
        });
      }
    };
    new import_obsidian4.Setting(containerEl).setName("Skills folder path / \uC2A4\uD0AC \uD3F4\uB354 \uACBD\uB85C").setDesc("Absolute path where skill subfolders contain SKILL.md.").addText(
      (text) => text.setPlaceholder("/Users/.../skills").setValue(this.plugin.settings.qaSkillsRootPath).onChange(async (value) => {
        this.plugin.settings.qaSkillsRootPath = value.trim();
        await this.plugin.saveSettings();
      })
    ).addButton(
      (button) => button.setButtonText("Scan / \uD0D0\uC9C0").onClick(async () => {
        await renderScanResult();
      })
    ).addButton(
      (button) => button.setButtonText("Sample template / \uC0D8\uD50C \uC591\uC2DD").onClick(async () => {
        const root = this.plugin.settings.qaSkillsRootPath.trim();
        if (!root) {
          new import_obsidian4.Notice("Set skills folder path first. / \uBA3C\uC800 \uC2A4\uD0AC \uD3F4\uB354 \uACBD\uB85C\uB97C \uC785\uB825\uD558\uC138\uC694.", 4500);
          return;
        }
        try {
          const sampleDir = nodePath.join(nodePath.resolve(root), "sample-skill");
          await nodeFs.promises.mkdir(sampleDir, { recursive: true });
          const samplePath = nodePath.join(sampleDir, "SKILL.md");
          const sampleBody = [
            "# Sample Skill",
            "",
            "A short one-line description of what this skill does.",
            "",
            "## When to use",
            "- Use when this workflow is requested.",
            "",
            "## Inputs",
            "- Input A",
            "- Input B",
            "",
            "## Steps",
            "1. Step one",
            "2. Step two",
            "",
            "## Output",
            "- Expected result format"
          ].join("\n");
          await nodeFs.promises.writeFile(samplePath, sampleBody, "utf8");
          new import_obsidian4.Notice(`Sample created: ${samplePath}`, 5e3);
          await renderScanResult();
        } catch (error) {
          const message = error instanceof Error ? error.message : "Unknown sample template error";
          new import_obsidian4.Notice(`Sample create failed: ${message}`, 6e3);
        }
      })
    );
    void renderScanResult();
  }
  renderParserTab(containerEl) {
    const mode = this.plugin.settings.settingsUiLanguage;
    const t = (en, ko) => mode === "en" ? en : mode === "ko" ? ko : `${en} / ${ko}`;
    containerEl.createEl("h3", { text: "Parser pipeline / \uD30C\uC11C \uD30C\uC774\uD504\uB77C\uC778" });
    containerEl.createEl("p", {
      cls: "omni-forge-settings-guide-note",
      text: "PDF/\uC774\uBBF8\uC9C0 \uD30C\uC11C\uB97C \uC911\uC2EC\uC73C\uB85C \uCCA8\uBD80 \uCEE8\uD14D\uC2A4\uD2B8 \uD488\uC9C8\uC744 \uB192\uC785\uB2C8\uB2E4. HWPX\uB294 XML 1\uCC28 \uCD94\uCD9C\uC744 \uC2DC\uB3C4\uD558\uACE0, HWP\uB294 soffice \uAC10\uC9C0 \uC2DC hwp->pdf \uC790\uB3D9\uBCC0\uD658(PoC)\uC744 \uC2DC\uB3C4\uD55C \uB4A4 \uC2E4\uD328 \uC2DC \uAC00\uC774\uB4DC\uB85C \uD3F4\uBC31\uD569\uB2C8\uB2E4."
    });
    const parserQuick = new import_obsidian4.Setting(containerEl).setName(t("Parser inbox quick actions", "Parser inbox 빠른 동작")).setDesc(t("Open inbox, run scan, trigger OCR re-parse, and toggle watch.", "inbox 열기, 즉시 스캔, OCR 재파싱, watch 토글을 한 번에 실행"));
    parserQuick.addButton((button) => button.setButtonText(t("Open inbox", "inbox 열기")).onClick(async () => {
      await this.plugin.openParserInboxFolderForQa();
    }));
    parserQuick.addButton((button) => button.setButtonText(t("Scan now", "즉시 스캔")).onClick(async () => {
      await this.plugin.scanParserInboxNowForQa();
      this.display();
    }));
    parserQuick.addButton((button) => button.setButtonText(t("OCR re-parse", "OCR 재파싱")).onClick(async () => {
      await this.plugin.scanParserInboxNowForQa({ forceOcr: true });
      this.display();
    }));
    parserQuick.addButton((button) => button.setButtonText(t("Formats", "지원 포맷")).onClick(() => {
      new import_obsidian4.Notice(`Parser formats: ${this.plugin.getParserSupportedFormatsForQa().join(", ")}`, 7e3);
    }));
    parserQuick.addButton((button) => button.setButtonText(this.plugin.settings.qaParserInboxWatchEnabled ? t("Watch ON", "watch ON") : t("Watch OFF", "watch OFF")).onClick(async () => {
      const next = !this.plugin.settings.qaParserInboxWatchEnabled;
      await this.plugin.setParserInboxWatchEnabledForQa(next);
      this.display();
    }));
    const parserStatus = this.plugin.getParserInboxStatusForQa();
    const parserLast = this.plugin.getParserInboxLastEventForQa();
    const parserProfile = this.plugin.getParserModeProfileForQa();
    new import_obsidian4.Setting(containerEl).setName(t("Parser status", "파서 상태")).setDesc(`모드 ${parserProfile.mode.toUpperCase()}(${parserProfile.focus}) | 진행률 ${parserStatus.processed || 0}/${parserStatus.total || 0} | 소요 ${this.plugin.formatParserEtaMsForQa(parserStatus.elapsedMs || 0)} | ETA ${this.plugin.formatParserEtaMsForQa(parserStatus.etaMs || 0)} | 큐 ${parserStatus.queueLength || 0} | 단계 ${parserStatus.stage || "idle"} | 최근 ${parserLast.fileName} | 결과 ${parserLast.result} (s:${parserStatus.success || 0}/k:${parserStatus.skip || 0}/e:${parserStatus.error || 0}) | 메시지 ${parserLast.message || "-"}`);
    new import_obsidian4.Setting(containerEl).setName("HWP/HWPX workaround").setDesc("HWPX는 1차 텍스트 추출 지원. HWP는 soffice가 감지되면 자동변환(PoC)을 시도하고, 미탐지/실패 시 PDF 또는 DOCX 수동 변환 안내로 폴백합니다.").addButton((button) => button.setButtonText("우회 안내 보기").onClick(() => {
      new import_obsidian4.Notice("HWPX는 XML 1차 추출을 시도합니다. HWP는 soffice 자동변환(PoC)을 먼저 시도하며 실패 시 PDF/DOCX 수동 변환 경로를 안내합니다.", 7e3);
    }));
    new import_obsidian4.Setting(containerEl).setName("Parser mode indicator").setDesc(
      `${parserProfile.summary}
${parserProfile.recommendation}`
    );
    new import_obsidian4.Setting(containerEl).setName("Parser mode").setDesc("Fast\uB294 \uACBD\uB7C9 \uD30C\uC11C, Detailed\uB294 OCR \uD398\uC774\uC9C0 \uD655\uC7A5\uACFC \uAE34 \uD14D\uC2A4\uD2B8 \uCD94\uCD9C\uC744 \uC0AC\uC6A9\uD569\uB2C8\uB2E4.").addDropdown(
      (dropdown) => dropdown.addOption("fast", "Fast / \uBE60\uB978 \uD30C\uC11C").addOption("detailed", "Detailed / \uC0C1\uC138 \uD30C\uC11C").setValue(this.plugin.settings.qaParserMode).onChange(async (value) => {
        this.plugin.settings.qaParserMode = value === "detailed" ? "detailed" : "fast";
        await this.plugin.saveSettings();
        await this.plugin.refreshOpenQaWorkspaceViews();
        const nextProfile = this.plugin.getParserModeProfileForQa();
        new import_obsidian4.Notice(`Parser mode -> ${nextProfile.badge} (${nextProfile.focus})`, 4500);
        this.display();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("PDF attachments in chat").setDesc("\uAE30\uBCF8 ON\uC785\uB2C8\uB2E4. PDF\uB294 pdftotext -> OCR -> fallback \uCCB4\uC778\uC73C\uB85C \uC790\uB3D9 \uCC98\uB9AC\uB429\uB2C8\uB2E4.");
    new import_obsidian4.Setting(containerEl).setName("Parser tool readiness").setDesc(this.plugin.getParserToolReadinessSummaryForQa()).addButton(
      (button) => button.setButtonText("Refresh / \uC810\uAC80").onClick(async () => {
        await this.plugin.refreshParserToolReadinessForQa(true);
        this.display();
      })
    );
    const parserList = containerEl.createEl("ul", { cls: "omni-forge-settings-guide-list" });
    parserList.createEl("li", {
      text: t("PDF: pdftotext(text extraction) + pdftoppm/tesseract(OCR) + fallback", "PDF: pdftotext(\uD14D\uC2A4\uD2B8 \uCD94\uCD9C) + pdftoppm/tesseract(OCR) + fallback")
    });
    parserList.createEl("li", {
      text: t("Image: tesseract OCR + original image context", "Image: tesseract OCR + \uC6D0\uBCF8 \uC774\uBBF8\uC9C0 \uCEE8\uD14D\uC2A4\uD2B8")
    });
    parserList.createEl("li", {
      text: t("HWP: try soffice PoC (hwp->pdf->parser chain) when available; fallback to manual PDF/DOCX conversion guide. HWPX: first-pass XML extraction.", "HWP: soffice 가능 시 hwp->pdf->parser chain(PoC)을 시도하고, 실패 시 PDF/DOCX 수동 변환 안내로 폴백합니다. HWPX: XML 1차 추출을 우선 시도합니다.")
    });
    const tips = containerEl.createEl("details", { cls: "omni-forge-chat-collapsible omni-forge-settings-parser-tips" });
    tips.open = false;
    tips.createEl("summary", { text: t("Parser command tips", "\uD30C\uC11C \uBA85\uB839 \uD301") });
    tips.createEl("small", {
      text: t(
        "Collapsed by default. Open when parser readiness shows missing.",
        "\uAE30\uBCF8 \uC228\uAE40. parser readiness\uAC00 missing\uC77C \uB54C \uD3BC\uCCD0 \uD655\uC778\uD558\uC138\uC694."
      )
    });
    const tipsList = tips.createEl("ul", { cls: "omni-forge-settings-guide-list" });
    tipsList.createEl("li", { text: "macOS(Homebrew): brew install poppler tesseract" });
    tipsList.createEl("li", { text: "Ubuntu/Debian: sudo apt-get install poppler-utils tesseract-ocr tesseract-ocr-kor" });
    tipsList.createEl("li", { text: "Windows(Chocolatey): choco install poppler tesseract" });
    tipsList.createEl("li", {
      text: t("Terminal check: `pdftotext -v`, `pdftoppm -v`, `tesseract --version`.", "\uD130\uBBF8\uB110 \uD655\uC778: `pdftotext -v`, `pdftoppm -v`, `tesseract --version`.")
    });
    tipsList.createEl("li", {
      text: t(
        "If any command fails, parser quality drops to fallback mode (possible omission/OCR errors).",
        "\uBA85\uB839 \uD558\uB098\uB77C\uB3C4 \uC2E4\uD328\uD558\uBA74 parser \uD488\uC9C8\uC740 fallback \uBAA8\uB4DC\uB85C \uD558\uB77D\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4(\uB204\uB77D/OCR \uC624\uC778\uC2DD \uAC00\uB2A5)."
      )
    });
    tipsList.createEl("li", {
      text: t(
        "After installation, restart Obsidian and press `Refresh / 점검` in this tab.",
        "\uC124\uCE58 \uD6C4 Obsidian \uC7AC\uC2DC\uC791 -> \uC774 \uD0ED\uC5D0\uC11C `Refresh / \uC810\uAC80` \uD074\uB9AD"
      )
    });
    for (const line of this.plugin.getParserToolReadinessLinesForQa()) {
      tipsList.createEl("li", { text: line });
    }
    new import_obsidian4.Setting(containerEl).setName("Attachment ingest folder path").setDesc("\uC678\uBD80 \uCCA8\uBD80\uB97C vault \uB0B4\uBD80\uB85C \uBBF8\uB7EC\uB9C1\uD560 \uACBD\uB85C\uC785\uB2C8\uB2E4.").addText(
      (text) => text.setPlaceholder("Omni Forge Ingest").setValue(this.plugin.settings.qaAttachmentIngestRootPath).onChange(async (value) => {
        this.plugin.settings.qaAttachmentIngestRootPath = (0, import_obsidian4.normalizePath)(
          value.trim() || DEFAULT_SETTINGS.qaAttachmentIngestRootPath
        );
        await this.plugin.saveSettings();
      })
    );
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("omni-forge-settings-tab");
    this.addSettingsLanguageControl(containerEl);
    const uiMode = this.plugin.settings.settingsUiLanguage;
    containerEl.createEl("h2", {
      text: uiMode === "en" ? "Omni Forge Settings" : uiMode === "ko" ? "Omni Forge \uC124\uC815" : "Omni Forge Settings / Omni Forge \uC124\uC815"
    });
    containerEl.createEl("p", {
      text: uiMode === "en" ? "Language docs: README.md (EN) | README_KO.md (KO)" : uiMode === "ko" ? "\uC5B8\uC5B4 \uBB38\uC11C: README.md (EN) | README_KO.md (KO)" : "Language docs / \uC5B8\uC5B4 \uBB38\uC11C: README.md (EN) | README_KO.md (KO)"
    });
    this.addSettingsTabSwitcher(containerEl);
    const activeTab = this.plugin.settings.settingsActiveTab === "advanced" ? "guide" : this.plugin.settings.settingsActiveTab;
    if (activeTab === "chat") {
      this.addViewModeAndPresetControls(containerEl);
      this.addChatPresetControls(containerEl);
    }
    if (activeTab === "orchestration") {
      this.renderOrchestrationTab(containerEl);
    }
    if (activeTab === "skills") {
      this.renderSkillsTab(containerEl);
      this.applyBilingualSettingsLabels(containerEl);
      return;
    }
    if (activeTab === "parser") {
      this.renderParserTab(containerEl);
      this.applyBilingualSettingsLabels(containerEl);
      return;
    }
    if (activeTab === "guide") {
      this.renderGuideTab(containerEl);
      this.applyBilingualSettingsLabels(containerEl);
      return;
    }
    new import_obsidian4.Setting(containerEl).setName("Quick provider / \uBE60\uB978 \uC81C\uACF5\uC790").setDesc("Choose provider in order: local > local QA bridge > cloud. Local defaults to Flash profile.").addDropdown(
      (dropdown) => dropdown.addOption("ollama", "Ollama (local / \uB85C\uCEEC)").addOption("lmstudio", "LM Studio (local QA / \uB85C\uCEEC QA)").addOption("openai", "Codex/OpenAI (cloud bridge)").addOption("anthropic", "Claude / \uD074\uB85C\uB4DC").addOption("gemini", "Gemini / \uC81C\uBBF8\uB098\uC774").setValue(this.plugin.settings.provider).onChange(async (value) => {
        this.plugin.settings.provider = value;
        if (value === "ollama") {
          this.plugin.settings.qaChatModelFamily = "local";
          this.plugin.settings.qaChatModelProfile = "local-flash";
          this.plugin.settings.qaLocalPresetProfile = "fast_local";
          this.plugin.settings.qaAllowNonLocalEndpoint = false;
          await this.plugin.saveSettings();
          await this.plugin.refreshOllamaDetection({ notify: false, autoApply: true });
          await this.plugin.refreshEmbeddingModelDetection({ notify: false, autoApply: true });
          this.plugin.settings.qaOllamaModel = this.plugin.settings.ollamaModel.trim() || this.plugin.settings.qaOllamaModel;
        } else if (value === "lmstudio") {
          this.plugin.settings.qaChatModelFamily = "local";
          this.plugin.settings.qaChatModelProfile = "local-flash";
          this.plugin.settings.qaLocalPresetProfile = "custom";
          this.plugin.settings.qaAllowNonLocalEndpoint = false;
          this.plugin.settings.qaOllamaModel = this.plugin.settings.lmStudioModel.trim() || this.plugin.settings.qaOllamaModel;
        } else if (value === "openai") {
          this.plugin.settings.qaChatModelFamily = "cloud";
          this.plugin.settings.qaChatModelProfile = "codex";
          this.plugin.settings.qaAllowNonLocalEndpoint = true;
          this.plugin.settings.qaOllamaBaseUrl = toOpenAICompatibleBase(this.plugin.settings.openAIBaseUrl.trim() || DEFAULT_SETTINGS.openAIBaseUrl);
          this.plugin.appendQaAllowedOutboundHostFromUrl(this.plugin.settings.qaOllamaBaseUrl);
          this.plugin.settings.qaOllamaModel = this.plugin.settings.openAIModel.trim() || DEFAULT_SETTINGS.openAIModel;
        } else if (value === "anthropic") {
          this.plugin.settings.qaChatModelFamily = "cloud";
          this.plugin.settings.qaChatModelProfile = "claude";
          this.plugin.settings.qaAllowNonLocalEndpoint = true;
          this.plugin.settings.qaOllamaBaseUrl = toOpenAICompatibleBase(this.plugin.settings.openAIBaseUrl.trim() || DEFAULT_SETTINGS.openAIBaseUrl);
          this.plugin.appendQaAllowedOutboundHostFromUrl(this.plugin.settings.qaOllamaBaseUrl);
          this.plugin.settings.qaOllamaModel = this.plugin.settings.anthropicModel.trim() || DEFAULT_SETTINGS.anthropicModel;
        } else if (value === "gemini") {
          this.plugin.settings.qaChatModelFamily = "cloud";
          this.plugin.settings.qaChatModelProfile = "gemini";
          this.plugin.settings.qaAllowNonLocalEndpoint = true;
          this.plugin.settings.qaOllamaBaseUrl = toOpenAICompatibleBase(this.plugin.settings.openAIBaseUrl.trim() || DEFAULT_SETTINGS.openAIBaseUrl);
          this.plugin.appendQaAllowedOutboundHostFromUrl(this.plugin.settings.qaOllamaBaseUrl);
          this.plugin.settings.qaOllamaModel = this.plugin.settings.geminiModel.trim() || DEFAULT_SETTINGS.geminiModel;
        }
        await this.plugin.saveSettings();
        await this.plugin.refreshOpenQaWorkspaceViews();
        this.display();
      })
    ).addButton(
      (button) => button.setButtonText(uiMode === "en" ? "Local detect + Flash" : uiMode === "ko" ? "\uB85C\uCEEC \uAC10\uC9C0 + Flash" : "Local detect + Flash / \uB85C\uCEEC \uAC10\uC9C0 + Flash").onClick(async () => {
        const summary = await this.plugin.applyQaChatModelProfileForQa("local-flash", "local");
        new import_obsidian4.Notice(summary, 6500);
        this.display();
      })
    ).addButton(
      (button) => button.setButtonText(uiMode === "en" ? "Google OAuth Login" : uiMode === "ko" ? "Google OAuth 로그인" : "Google OAuth Login / Google OAuth 로그인").onClick(async () => {
        this.plugin.applyGoogleOAuthQuickSetupForQa();
        await this.plugin.saveSettings();
        const validation = this.plugin.getOAuthLoginValidationForQa();
        if (!validation.ready) {
          new import_obsidian4.Notice(`${validation.message} ${validation.guidance || ""}`.trim(), 8e3);
          focusOAuthField(validation.focusField);
          this.display();
          return;
        }
        try {
          await this.plugin.startOAuthLoginForQa();
          new import_obsidian4.Notice("OAuth login completed. / OAuth 로그인 완료", 4e3);
        } catch (error) {
          new import_obsidian4.Notice(this.plugin.formatOAuthLoginFailureForQa(error), 8e3);
        }
        this.display();
      })
    );
    const showCodexBridgeNote = this.plugin.getQaChatModelProfileForQa() === "codex";
    if (showCodexBridgeNote) {
      new import_obsidian4.Setting(containerEl).setName("Codex bridge note / Codex \uBE0C\uB9AC\uC9C0 \uC548\uB0B4").setDesc(
        "Meaning: Q&A calls Codex through an OpenAI-compatible bridge endpoint (for example Agent Client) instead of a direct plugin API integration."
      );
    }
    containerEl.createEl("h3", { text: "Local provider config" });
    new import_obsidian4.Setting(containerEl).setName("Ollama base URL").addText(
      (text) => text.setPlaceholder("http://127.0.0.1:11434").setValue(this.plugin.settings.ollamaBaseUrl).onChange(async (value) => {
        this.plugin.settings.ollamaBaseUrl = value.trim();
        if (this.plugin.getQaChatModelFamilyForQa() === "local" || !this.plugin.settings.qaOllamaBaseUrl.trim()) {
          this.plugin.settings.qaOllamaBaseUrl = this.plugin.settings.ollamaBaseUrl;
        }
        await this.plugin.saveSettings();
      })
    );
    const ollamaOptions = this.plugin.getOllamaModelOptions();
    new import_obsidian4.Setting(containerEl).setName("Ollama detected model picker").setDesc(
      "Choose among detected models. (\uCD94\uCC9C)=recommended, (\uBD88\uAC00)=not suitable for analysis."
    ).addDropdown((dropdown) => {
      if (ollamaOptions.length === 0) {
        dropdown.addOption("", "(No models detected)");
        dropdown.setValue("");
      } else {
        for (const option of ollamaOptions) {
          dropdown.addOption(option.model, this.formatDetectedModelLabel(option));
        }
        const current = this.plugin.settings.ollamaModel;
        if (current && ollamaOptions.some((option) => option.model === current)) {
          dropdown.setValue(current);
        } else {
          dropdown.setValue(ollamaOptions[0].model);
        }
      }
      dropdown.onChange(async (value) => {
        if (!value) {
          return;
        }
        if (!isOllamaModelAnalyzable(value)) {
          new import_obsidian4.Notice(`Selected model is marked as (\uBD88\uAC00): ${value}`, 4500);
          this.display();
          return;
        }
        this.plugin.settings.ollamaModel = value;
        this.plugin.settings.qaOllamaModel = value;
        await this.plugin.saveSettings();
        await this.plugin.refreshOpenQaWorkspaceViews();
        this.display();
      });
    }).addButton(
      (button) => button.setButtonText("Refresh / \uC0C8\uB85C\uACE0\uCE68").onClick(async () => {
        await this.plugin.refreshOllamaDetection({ notify: true, autoApply: true });
        this.display();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Ollama auto-match policy").setDesc("On refresh/detect, recommended model is applied automatically.");
    new import_obsidian4.Setting(containerEl).setName("Ollama detection summary").setDesc(this.plugin.getOllamaDetectionSummary());
    new import_obsidian4.Setting(containerEl).setName("LM Studio base URL").addText(
      (text) => text.setPlaceholder("http://127.0.0.1:1234").setValue(this.plugin.settings.lmStudioBaseUrl).onChange(async (value) => {
        this.plugin.settings.lmStudioBaseUrl = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("LM Studio model").addText(
      (text) => text.setPlaceholder("local-model").setValue(this.plugin.settings.lmStudioModel).onChange(async (value) => {
        this.plugin.settings.lmStudioModel = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("LM Studio API key (optional)").addText(
      (text) => text.setPlaceholder("Leave empty if not required").setValue(this.plugin.settings.lmStudioApiKey).onChange(async (value) => {
        this.plugin.settings.lmStudioApiKey = value.trim();
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Cloud provider config" });
    new import_obsidian4.Setting(containerEl).setName("OpenAI base URL").addText(
      (text) => text.setPlaceholder("https://api.openai.com/v1").setValue(this.plugin.settings.openAIBaseUrl).onChange(async (value) => {
        this.plugin.settings.openAIBaseUrl = value.trim();
        if (this.plugin.getQaChatModelFamilyForQa() === "cloud") {
          this.plugin.settings.qaOllamaBaseUrl = toOpenAICompatibleBase(this.plugin.settings.openAIBaseUrl || DEFAULT_SETTINGS.openAIBaseUrl);
          this.plugin.appendQaAllowedOutboundHostFromUrl(this.plugin.settings.qaOllamaBaseUrl);
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("OpenAI model").addText(
      (text) => text.setPlaceholder("gpt-5.3-codex").setValue(this.plugin.settings.openAIModel).onChange(async (value) => {
        const nextModel = value.trim();
        this.plugin.settings.openAIModel = nextModel;
        if (this.plugin.getQaChatModelFamilyForQa() === "cloud" && this.plugin.getQaChatModelProfileForQa() === "codex") {
          this.plugin.settings.qaOllamaModel = nextModel || DEFAULT_SETTINGS.openAIModel;
        }
        await this.plugin.saveSettings();
        await this.plugin.refreshOpenQaWorkspaceViews();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("OAuth bridge mode (API-key optional)").setDesc(
      "Route cloud analysis/chat to local OpenAI-compatible /v1 bridge. API key checks are bypassed in this mode. Recommended for Google OAuth + codex profile."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.oauthBridgeEnabled).onChange(async (value) => {
        this.plugin.settings.oauthBridgeEnabled = value;
        if (value && this.plugin.getQaChatModelFamilyForQa() === "cloud") {
          const bridgeHostUrl = this.plugin.settings.oauthBridgeBaseUrl.trim() || this.plugin.settings.openAIBaseUrl.trim() || DEFAULT_SETTINGS.openAIBaseUrl;
          this.plugin.appendQaAllowedOutboundHostFromUrl(bridgeHostUrl);
        }
        await this.plugin.saveSettings();
        await this.plugin.refreshOpenQaWorkspaceViews();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("OAuth bridge base URL (/v1)").addText(
      (text) => text.setPlaceholder("http://127.0.0.1:8787/v1").setValue(this.plugin.settings.oauthBridgeBaseUrl).onChange(async (value) => {
        this.plugin.settings.oauthBridgeBaseUrl = value.trim();
        if (this.plugin.settings.oauthBridgeEnabled && this.plugin.getQaChatModelFamilyForQa() === "cloud") {
          const bridgeHostUrl = this.plugin.settings.oauthBridgeBaseUrl.trim() || this.plugin.settings.openAIBaseUrl.trim() || DEFAULT_SETTINGS.openAIBaseUrl;
          this.plugin.appendQaAllowedOutboundHostFromUrl(bridgeHostUrl);
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("OAuth bridge model override (optional)").addText(
      (text) => text.setPlaceholder("Leave empty to reuse provider model").setValue(this.plugin.settings.oauthBridgeModel).onChange(async (value) => {
        this.plugin.settings.oauthBridgeModel = value.trim();
        await this.plugin.saveSettings();
        await this.plugin.refreshOpenQaWorkspaceViews();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("OAuth enabled / OAuth 사용").setDesc("Use OAuth Authorization Code flow for cloud requests. / 클라우드 요청에 OAuth 인증코드 방식을 사용합니다.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.oauthEnabled === true).onChange(async (value) => {
        this.plugin.settings.oauthEnabled = value === true;
        await this.plugin.saveSettings();
      })
    );
    let oauthAuthUrlText = null;
    let oauthTokenUrlText = null;
    let oauthScopesText = null;
    let oauthClientIdText = null;
    let oauthRedirectUriText = null;
    const focusOAuthField = (fieldKey) => {
      const targetByKey = {
        oauthAuthUrl: oauthAuthUrlText,
        oauthTokenUrl: oauthTokenUrlText,
        oauthClientId: oauthClientIdText,
        oauthRedirectUri: oauthRedirectUriText
      };
      const target = targetByKey[fieldKey];
      if (target && target.inputEl) {
        target.inputEl.focus();
        try {
          target.inputEl.scrollIntoView({ behavior: "smooth", block: "center" });
        } catch (e) {
        }
      }
    };
    new import_obsidian4.Setting(containerEl).setName("OAuth provider preset").setDesc("google | auth0 | custom (auto-fill helper)").addDropdown(
      (dropdown) => dropdown.addOption("google", "google").addOption("auth0", "auth0").addOption("custom", "custom").setValue(
        this.plugin.normalizeOAuthProviderPresetForQa(this.plugin.settings.oauthProviderPreset)
      ).onChange(async (value) => {
        this.plugin.applyOAuthProviderPresetForQa(value);
        if (oauthAuthUrlText) {
          oauthAuthUrlText.setValue(this.plugin.settings.oauthAuthUrl);
        }
        if (oauthTokenUrlText) {
          oauthTokenUrlText.setValue(this.plugin.settings.oauthTokenUrl);
        }
        if (oauthScopesText) {
          oauthScopesText.setValue(this.plugin.settings.oauthScopes);
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Auth0 domain (preset helper)").setDesc("예: your-tenant.us.auth0.com (Auth0 preset에서 URL 자동완성)").addText(
      (text) => text.setPlaceholder("your-tenant.us.auth0.com").setValue(this.plugin.settings.oauthAuth0Domain).onChange(async (value) => {
        const domain = this.plugin.sanitizeOAuthDomainForQa(value);
        this.plugin.settings.oauthAuth0Domain = domain;
        if (this.plugin.normalizeOAuthProviderPresetForQa(this.plugin.settings.oauthProviderPreset) === "auth0") {
          const auth0Urls = this.plugin.resolveAuth0PresetUrlsForQa(domain);
          if (auth0Urls) {
            this.plugin.settings.oauthAuthUrl = auth0Urls.authUrl;
            this.plugin.settings.oauthTokenUrl = auth0Urls.tokenUrl;
            if (oauthAuthUrlText) {
              oauthAuthUrlText.setValue(this.plugin.settings.oauthAuthUrl);
            }
            if (oauthTokenUrlText) {
              oauthTokenUrlText.setValue(this.plugin.settings.oauthTokenUrl);
            }
          }
        }
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("OAuth provider hint (advanced) / OAuth 공급자 힌트(고급)").setDesc("Optional token payload hint (default: generic). / 토큰 페이로드 힌트(기본: generic)").addText(
      (text) => text.setPlaceholder("generic").setValue(this.plugin.settings.oauthProvider).onChange(async (value) => {
        this.plugin.settings.oauthProvider = value.trim() || "generic";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("OAuth authorization URL / OAuth 인증 URL").addText((text) => {
      oauthAuthUrlText = text;
      return text.setPlaceholder("https://provider.example.com/oauth/authorize").setValue(this.plugin.settings.oauthAuthUrl).onChange(async (value) => {
        this.plugin.settings.oauthAuthUrl = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("OAuth token URL / OAuth 토큰 URL").addText((text) => {
      oauthTokenUrlText = text;
      return text.setPlaceholder("https://provider.example.com/oauth/token").setValue(this.plugin.settings.oauthTokenUrl).onChange(async (value) => {
        this.plugin.settings.oauthTokenUrl = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("OAuth client ID / OAuth 클라이언트 ID").setDesc("Required. Google Cloud Console > Credentials > OAuth 2.0 Client IDs.").addText(
      (text) => {
        oauthClientIdText = text;
        return text.setPlaceholder("xxxxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.apps.googleusercontent.com").setValue(this.plugin.settings.oauthClientId).onChange(async (value) => {
          this.plugin.settings.oauthClientId = value.trim();
          await this.plugin.saveSettings();
        });
      }
    );
    new import_obsidian4.Setting(containerEl).setName("OAuth scopes / OAuth 스코프").setDesc("Comma or space separated scopes. / 쉼표 또는 공백으로 구분").addText((text) => {
      oauthScopesText = text;
      return text.setPlaceholder("openid profile email").setValue(this.plugin.settings.oauthScopes).onChange(async (value) => {
        this.plugin.settings.oauthScopes = value.trim();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("OAuth redirect URI / OAuth 리디렉션 URI").addText(
      (text) => {
        oauthRedirectUriText = text;
        return text.setPlaceholder("http://127.0.0.1:8765/callback").setValue(this.plugin.settings.oauthRedirectUri).onChange(async (value) => {
          this.plugin.settings.oauthRedirectUri = this.plugin.normalizeOAuthRedirectUriForQa(value);
          await this.plugin.saveSettings();
          text.setValue(this.plugin.settings.oauthRedirectUri);
        });
      }
    );
    const oauthRedirectGuide = containerEl.createDiv({ cls: "omni-forge-settings-guide-note" });
    oauthRedirectGuide.createSpan({ text: "Redirect URI example: " });
    oauthRedirectGuide.createEl("code", { text: "http://127.0.0.1:8765/callback" });
    oauthRedirectGuide.createEl("div", { text: "Provider 콘솔에 위 URI를 Redirect URI 허용(whitelist)으로 등록해야 로그인됩니다." });
    oauthRedirectGuide.createEl("div", { text: "입력 순서(초보자 권장): Auth URL → Token URL → Client ID → Redirect URI → Start OAuth Login" });
    oauthRedirectGuide.createEl("div", { text: "Obsidian-plugin-first: 외부 스크립트보다 Omni-Forge 설정창에서 먼저 구성/검증하세요." });
    new import_obsidian4.Setting(containerEl).setName("OAuth use PKCE / OAuth PKCE 사용").setDesc("Enable S256 code challenge. / S256 코드 챌린지 사용").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.oauthUsePkce !== false).onChange(async (value) => {
        this.plugin.settings.oauthUsePkce = value === true;
        await this.plugin.saveSettings();
      })
    );
    const oauthValidation = this.plugin.getOAuthLoginValidationForQa();
    new import_obsidian4.Setting(containerEl).setName("OAuth login validation").setDesc(`${oauthValidation.message} ${oauthValidation.guidance || ""}`.trim());
    const oauthTransport = this.plugin.getOAuthTransportValidationForQa();
    const oauthTransportSetting = new import_obsidian4.Setting(containerEl).setName("OAuth endpoint compatibility").setDesc(
      `${oauthTransport.message} ${oauthTransport.guidance || ""}`.trim()
    );
    if (!oauthTransport.ready || oauthTransport.level === "notice") {
      oauthTransportSetting.addButton((button) => button.setButtonText("Apply bridge defaults").onClick(async () => {
        this.plugin.applyRecommendedOAuthBridgeDefaultsForQa();
        await this.plugin.saveSettings();
        await this.plugin.refreshOpenQaWorkspaceViews();
        this.display();
        new import_obsidian4.Notice("OAuth bridge defaults applied. / OAuth 브리지 기본값 적용 완료", 4e3);
      }));
    }
    const oauthChecklist = this.plugin.getOAuthSetupChecklistForQa();
    new import_obsidian4.Setting(containerEl).setName("OAuth setup checklist").setDesc(oauthChecklist.text).addButton(
      (button) => button.setButtonText("Validate redirect URI").onClick(() => {
        const redirectValidation = this.plugin.getOAuthRedirectValidationForQa();
        const message = redirectValidation.ready ? `Redirect URI OK: ${redirectValidation.normalized}` : `Redirect URI fix needed. ${redirectValidation.guidance}`;
        new import_obsidian4.Notice(message, 6e3);
        if (!redirectValidation.ready) {
          focusOAuthField("oauthRedirectUri");
        }
      })
    );
    new import_obsidian4.Setting(containerEl).setName("OAuth session actions / OAuth 세션 동작").setDesc(this.plugin.getOAuthStatusSummaryForQa()).addButton(
      (button) => button.setButtonText("Google quick preset / Google 빠른 설정").onClick(async () => {
        this.plugin.applyGoogleOAuthQuickSetupForQa();
        await this.plugin.saveSettings();
        this.display();
        new import_obsidian4.Notice("Google OAuth preset applied. / Google OAuth 프리셋 적용 완료", 4e3);
      })
    ).addButton(
      (button) => button.setButtonText("Start OAuth Login / OAuth 로그인 시작").onClick(async () => {
        this.plugin.settings.oauthEnabled = true;
        await this.plugin.saveSettings();
        const validation = this.plugin.getOAuthLoginValidationForQa();
        if (!validation.ready) {
          new import_obsidian4.Notice(`${validation.message} ${validation.guidance || ""}`.trim(), 8e3);
          focusOAuthField(validation.focusField);
          this.display();
          return;
        }
        new import_obsidian4.Notice("\uBE0C\uB77C\uC6B0\uC800\uB97C \uC5EC\uB294 \uC911... / Opening browser...", 3500);
        try {
          await this.plugin.startOAuthLoginForQa();
          new import_obsidian4.Notice("OAuth login completed. / OAuth 로그인 완료");
        } catch (error) {
          new import_obsidian4.Notice(this.plugin.formatOAuthLoginFailureForQa(error), 8e3);
        }
        this.display();
      })
    ).addButton(
      (button) => button.setButtonText("Logout / 로그아웃").onClick(async () => {
        await this.plugin.clearOAuthTokensForQa();
        new import_obsidian4.Notice("OAuth tokens cleared. / OAuth 토큰 삭제 완료");
        this.display();
      })
    ).addButton(
      (button) => button.setButtonText("Check OAuth Status / OAuth 상태 확인").onClick(async () => {
        new import_obsidian4.Notice(this.plugin.getOAuthStatusSummaryForQa(), 8e3);
      })
    );
    new import_obsidian4.Setting(containerEl).setName("OpenAI API key").addText(
      (text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openAIApiKey).onChange(async (value) => {
        this.plugin.settings.openAIApiKey = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Anthropic model").addText(
      (text) => text.setPlaceholder("claude-3-7-sonnet-latest").setValue(this.plugin.settings.anthropicModel).onChange(async (value) => {
        const nextModel = value.trim();
        this.plugin.settings.anthropicModel = nextModel;
        if (this.plugin.getQaChatModelFamilyForQa() === "cloud" && this.plugin.getQaChatModelProfileForQa() === "claude") {
          this.plugin.settings.qaOllamaModel = nextModel || DEFAULT_SETTINGS.anthropicModel;
        }
        await this.plugin.saveSettings();
        await this.plugin.refreshOpenQaWorkspaceViews();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Anthropic API key").addText(
      (text) => text.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.anthropicApiKey).onChange(async (value) => {
        this.plugin.settings.anthropicApiKey = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Gemini model").addText(
      (text) => text.setPlaceholder("gemini-2.5-pro").setValue(this.plugin.settings.geminiModel).onChange(async (value) => {
        const nextModel = value.trim();
        this.plugin.settings.geminiModel = nextModel;
        if (this.plugin.getQaChatModelFamilyForQa() === "cloud" && this.plugin.getQaChatModelProfileForQa() === "gemini") {
          this.plugin.settings.qaOllamaModel = nextModel || DEFAULT_SETTINGS.geminiModel;
        }
        await this.plugin.saveSettings();
        await this.plugin.refreshOpenQaWorkspaceViews();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Gemini API key").addText(
      (text) => text.setPlaceholder("AIza...").setValue(this.plugin.settings.geminiApiKey).onChange(async (value) => {
        this.plugin.settings.geminiApiKey = value.trim();
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Behavior" });
    const analyzedDepthMode = this.plugin.settings.semanticLinkingEnabled || !this.plugin.settings.analysisOnlyChangedNotes ? "detailed" : "quick";
    new import_obsidian4.Setting(containerEl).setName("Analyzed depth mode").setDesc(
      "Quick: changed-notes centric + semantic off. Detailed: semantic on + full-scope analysis. Embedding model is auto-matched by profile when depth changes."
    ).addDropdown(
      (dropdown) => dropdown.addOption("quick", "Quick / \uBE60\uB978 \uBD84\uC11D").addOption("detailed", "Detailed / \uC0C1\uC138 \uBD84\uC11D").setValue(analyzedDepthMode).onChange(async (value) => {
        const quickMode = value === "quick";
        this.plugin.settings.analysisOnlyChangedNotes = quickMode;
        this.plugin.settings.semanticLinkingEnabled = !quickMode;
        this.plugin.settings.includeReasons = !quickMode;
        this.plugin.settings.qaTopK = quickMode ? Math.min(this.plugin.settings.qaTopK, 4) : Math.max(this.plugin.settings.qaTopK, 6);
        this.plugin.settings.semanticTopK = quickMode ? Math.min(this.plugin.settings.semanticTopK, 16) : Math.max(this.plugin.settings.semanticTopK, 28);
        const embeddingPreset = quickMode ? "fast_local" : "balanced_local";
        const embeddingModel = this.plugin.getRecommendedPresetOverrideModelForQa(embeddingPreset, "embedding");
        if (embeddingModel) {
          this.plugin.settings.semanticOllamaModel = embeddingModel;
        }
        this.plugin.settings.qaAlwaysDetailedAnswer = !quickMode;
        this.plugin.settings.qaMaxContextChars = quickMode ? Math.min(this.plugin.settings.qaMaxContextChars, 12e3) : Math.max(this.plugin.settings.qaMaxContextChars, 18e3);
        await this.plugin.saveSettings();
        await this.plugin.refreshEmbeddingModelDetection({ notify: false, autoApply: true });
        this.display();
      })
    );
    const analyzedSelectedFiles = this.plugin.getSelectedFilesForQa().length;
    const analyzedEmbeddingModel = this.plugin.settings.semanticOllamaModel.trim() || "(none)";
    const analyzedQuickSec = Math.max(1, analyzedSelectedFiles) * 0.45;
    const analyzedDetailedSec = Math.max(1, analyzedSelectedFiles) * 1.15;
    const settingsUiMode = this.plugin.settings.settingsUiLanguage;
    const quickDepthRuntimeNote = settingsUiMode === "en" ? "Quick mode: semantic retrieval is disabled, so embedding retrieval does not run." : settingsUiMode === "ko" ? "Quick 모드: semantic 비활성화로 임베딩 리트리벌은 실행되지 않음" : "Quick mode: semantic retrieval is disabled, so embedding retrieval does not run. / Quick 모드: semantic 비활성화로 임베딩 리트리벌은 실행되지 않음";
    const detailedDepthRuntimeNote = settingsUiMode === "en" ? "Detailed mode: semantic embedding candidates are expanded." : settingsUiMode === "ko" ? "Detailed 모드: semantic 임베딩 기반 후보 확장 사용" : "Detailed mode: semantic embedding candidates are expanded. / Detailed 모드: semantic 임베딩 기반 후보 확장 사용";
    new import_obsidian4.Setting(containerEl).setName("Analyzed runtime estimate").setDesc(
      [
        `\uC120\uD0DD \uD30C\uC77C: ${analyzedSelectedFiles}\uAC1C`,
        `\uC784\uBCA0\uB529 \uBAA8\uB378: ${analyzedEmbeddingModel}`,
        analyzedDepthMode === "quick" ? quickDepthRuntimeNote : detailedDepthRuntimeNote,
        `Quick \uC608\uC0C1: \uC57D ${analyzedQuickSec.toFixed(1)}\uCD08 + \uBAA8\uB378 \uC751\uB2F5 \uC2DC\uAC04`,
        `Detailed \uC608\uC0C1: \uC57D ${analyzedDetailedSec.toFixed(1)}\uCD08 + \uBAA8\uB378 \uC751\uB2F5 \uC2DC\uAC04`
      ].join(" | ")
    );
    new import_obsidian4.Setting(containerEl).setName("Analyzed scope snapshot").setDesc(this.plugin.getAnalyzedScopeSnapshotSummaryForQa());
    new import_obsidian4.Setting(containerEl).setName("Suggestion mode (recommended)").setDesc("Analyze first, preview changes, and apply only when approved.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.suggestionMode).onChange(async (value) => {
        this.plugin.settings.suggestionMode = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Show reasons for each field").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.includeReasons).onChange(async (value) => {
        this.plugin.settings.includeReasons = value;
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Show AutoLink score details (debug)").setDesc("Read-only debug view in suggestion preview using existing score breakdown metadata only.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showAutoLinkScoreDetails).onChange(async (value) => {
        this.plugin.settings.showAutoLinkScoreDetails = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Show progress notices").setDesc("In addition to persistent progress modal, show short notices.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showProgressNotices).onChange(async (value) => {
        this.plugin.settings.showProgressNotices = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Analyze tags").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.analyzeTags).onChange(async (value) => {
        this.plugin.settings.analyzeTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Analyze topic").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.analyzeTopic).onChange(async (value) => {
        this.plugin.settings.analyzeTopic = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Analyze linked").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.analyzeLinked).onChange(async (value) => {
        this.plugin.settings.analyzeLinked = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Force all-to-all linked (deterministic)").setDesc(
      "When enabled, linked field includes all selected notes for each note (except self). maxLinked is ignored in this mode."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.forceAllToAllLinkedEnabled).onChange(async (value) => {
        this.plugin.settings.forceAllToAllLinkedEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Analyze linked scope mode").setDesc(
      "selected_only: selected notes only. selected_plus_related: include related notes under guardrails. vault_sampled: sampled vault pool with safe fallback."
    ).addDropdown(
      (dropdown) => dropdown.addOption("selected_only", "selected_only").addOption("selected_plus_related", "selected_plus_related").addOption("vault_sampled", "vault_sampled").setValue(
        this.plugin.normalizeAnalyzeLinkedScopeModeSetting(this.plugin.settings.analyzeLinkedScopeMode)
      ).onChange(async (value) => {
        this.plugin.settings.analyzeLinkedScopeMode = this.plugin.normalizeAnalyzeLinkedScopeModeSetting(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Related scope max candidates").setDesc(
      `Guardrail cap for selected_plus_related/vault_sampled (${16}-${LINKED_SCOPE_MAX_CANDIDATES_HARD}).`
    ).addText(
      (text) => text.setPlaceholder(String(DEFAULT_SETTINGS.relatedScopeMaxCandidates)).setValue(String(this.plugin.settings.relatedScopeMaxCandidates)).onChange(async (value) => {
        const parsed = parsePositiveInt(value, this.plugin.settings.relatedScopeMaxCandidates);
        this.plugin.settings.relatedScopeMaxCandidates = this.plugin.normalizeRelatedScopeMaxCandidatesSetting(parsed);
        await this.plugin.saveSettings();
        text.setValue(String(this.plugin.settings.relatedScopeMaxCandidates));
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Related scope time budget (ms)").setDesc(
      `Guardrail time budget for related candidate expansion (${50}-${LINKED_SCOPE_TIME_BUDGET_MS_HARD}ms).`
    ).addText(
      (text) => text.setPlaceholder(String(DEFAULT_SETTINGS.relatedScopeTimeBudgetMs)).setValue(String(this.plugin.settings.relatedScopeTimeBudgetMs)).onChange(async (value) => {
        const parsed = parsePositiveInt(value, this.plugin.settings.relatedScopeTimeBudgetMs);
        this.plugin.settings.relatedScopeTimeBudgetMs = this.plugin.normalizeRelatedScopeTimeBudgetMsSetting(parsed);
        await this.plugin.saveSettings();
        text.setValue(String(this.plugin.settings.relatedScopeTimeBudgetMs));
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Analyze index").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.analyzeIndex).onChange(async (value) => {
        this.plugin.settings.analyzeIndex = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Max tags").addText(
      (text) => text.setPlaceholder("8").setValue(String(this.plugin.settings.maxTags)).onChange(async (value) => {
        this.plugin.settings.maxTags = parsePositiveInt(
          value,
          this.plugin.settings.maxTags
        );
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Max linked").addText(
      (text) => text.setPlaceholder("8").setValue(String(this.plugin.settings.maxLinked)).onChange(async (value) => {
        this.plugin.settings.maxLinked = parsePositiveInt(
          value,
          this.plugin.settings.maxLinked
        );
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Analyze changed notes only / \uBCC0\uACBD\uB41C \uB178\uD2B8\uB9CC \uBD84\uC11D").setDesc(
      "Skip unchanged notes when cache metadata matches. Turn off to include cached notes in every run. / \uCE90\uC2DC\uC640 \uB3D9\uC77C\uD558\uBA74 \uC2A4\uD0B5\uD569\uB2C8\uB2E4."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.analysisOnlyChangedNotes).onChange(async (value) => {
        this.plugin.settings.analysisOnlyChangedNotes = value;
        await this.plugin.saveSettings();
      })
    );
    if (this.plugin.settings.provider !== "ollama") {
      new import_obsidian4.Setting(containerEl).setName("Cloud embedding behavior / \uD074\uB77C\uC6B0\uB4DC \uC784\uBCA0\uB529 \uB3D9\uC791").setDesc("Embedding detected picker is shown only for Ollama provider. In cloud mode, this picker is hidden and semantic linking uses the last saved local embedding model when enabled.");
    }
    containerEl.createEl("h3", { text: "Semantic linking (Ollama embeddings)" });
    new import_obsidian4.Setting(containerEl).setName("Enable semantic candidate ranking").setDesc(
      "Use local Ollama embeddings to rank likely related notes before AI linked suggestion."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.semanticLinkingEnabled).onChange(async (value) => {
        this.plugin.settings.semanticLinkingEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Embedding Ollama base URL").addText(
      (text) => text.setPlaceholder("http://127.0.0.1:11434").setValue(this.plugin.settings.semanticOllamaBaseUrl).onChange(async (value) => {
        this.plugin.settings.semanticOllamaBaseUrl = value.trim();
        await this.plugin.saveSettings();
        await this.plugin.refreshEmbeddingModelDetection({
          notify: false,
          autoApply: true
        });
      })
    );
    const embeddingOptions = this.plugin.getEmbeddingModelOptions().filter((option) => option.status !== "unavailable");
    new import_obsidian4.Setting(containerEl).setName("Embedding detected model picker").setDesc(
      "Choose among embedding-capable detected models. (\uCD94\uCC9C)=recommended."
    ).addDropdown((dropdown) => {
      var _a, _b;
      if (embeddingOptions.length === 0) {
        dropdown.addOption("", "(No embedding models detected)");
        dropdown.setValue("");
      } else {
        for (const option of embeddingOptions) {
          const suffix = option.status === "recommended" ? " (\uCD94\uCC9C)" : "";
          dropdown.addOption(option.model, `${option.model}${suffix}`);
        }
        const current = this.plugin.settings.semanticOllamaModel;
        if (current && embeddingOptions.some((option) => option.model === current)) {
          dropdown.setValue(current);
        } else {
          dropdown.setValue((_b = (_a = embeddingOptions[0]) == null ? void 0 : _a.model) != null ? _b : "");
        }
      }
      dropdown.onChange(async (value) => {
        if (!value) {
          return;
        }
        this.plugin.settings.semanticOllamaModel = value;
        await this.plugin.saveSettings();
        this.display();
      });
    }).addButton(
      (button) => button.setButtonText("Refresh / \uC0C8\uB85C\uACE0\uCE68").onClick(async () => {
        await this.plugin.refreshEmbeddingModelDetection({
          notify: true,
          autoApply: true
        });
        this.display();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Embedding model (manual)").setDesc("Manual override if you want a custom embedding model name.").addText(
      (text) => text.setPlaceholder("nomic-embed-text").setValue(this.plugin.settings.semanticOllamaModel).onChange(async (value) => {
        this.plugin.settings.semanticOllamaModel = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Embedding auto-match policy").setDesc("On refresh/detect, recommended embedding model is applied automatically.");
    new import_obsidian4.Setting(containerEl).setName("Embedding detection summary").setDesc(this.plugin.getEmbeddingDetectionSummary());
    new import_obsidian4.Setting(containerEl).setName("Semantic top-k candidates").setDesc(
      "\uC9C8\uBB38\uACFC \uAD00\uB828 \uC788\uC744 \uAC00\uB2A5\uC131\uC774 \uB192\uC740 \uD6C4\uBCF4 \uBB38\uC11C\uB97C \uBA87 \uAC1C\uAE4C\uC9C0 \uBCFC\uC9C0 \uC815\uD569\uB2C8\uB2E4. \uAC12\uC744 \uC62C\uB9AC\uBA74 \uADFC\uAC70 \uD6C4\uBCF4\uAC00 \uB298\uACE0, \uC18D\uB3C4\uB294 \uB290\uB824\uC9C8 \uC218 \uC788\uC2B5\uB2C8\uB2E4."
    ).addText(
      (text) => text.setPlaceholder("24").setValue(String(this.plugin.settings.semanticTopK)).onChange(async (value) => {
        this.plugin.settings.semanticTopK = parsePositiveInt(
          value,
          this.plugin.settings.semanticTopK
        );
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Semantic min similarity").setDesc(
      "\uAD00\uB828\uB3C4 \uCD5C\uC18C \uAE30\uC900\uC785\uB2C8\uB2E4(0.0~1.0). \uB0AE\uCD94\uBA74 \uB354 \uB9CE\uC740 \uBB38\uC11C\uAC00 \uD3EC\uD568\uB418\uACE0, \uB192\uC774\uBA74 \uB354 \uC5C4\uACA9\uD558\uAC8C \uAC78\uB7EC\uC9D1\uB2C8\uB2E4."
    ).addText(
      (text) => text.setPlaceholder("0.25").setValue(String(this.plugin.settings.semanticMinSimilarity)).onChange(async (value) => {
        const parsed = Number.parseFloat(value);
        if (Number.isFinite(parsed) && parsed >= 0 && parsed <= 1) {
          this.plugin.settings.semanticMinSimilarity = parsed;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Semantic source max chars").setDesc(
      "\uC784\uBCA0\uB529 \uC804\uC5D0 \uAC01 \uBB38\uC11C\uC5D0\uC11C \uC0AC\uC6A9\uD560 \uCD5C\uB300 \uAE00\uC790 \uC218\uC785\uB2C8\uB2E4. \uC904\uC774\uBA74 \uBE60\uB974\uACE0, \uB298\uB9AC\uBA74 \uBB38\uB9E5 \uC815\uBCF4\uAC00 \uB9CE\uC544\uC9D1\uB2C8\uB2E4."
    ).addText(
      (text) => text.setPlaceholder("5000").setValue(String(this.plugin.settings.semanticMaxChars)).onChange(async (value) => {
        this.plugin.settings.semanticMaxChars = parsePositiveInt(
          value,
          this.plugin.settings.semanticMaxChars
        );
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Local Q&A (security-first) / \uB85C\uCEEC Q&A (\uBCF4\uC548 \uC6B0\uC120)" });
    new import_obsidian4.Setting(containerEl).setName("Q&A model").setDesc("Leave empty to use main analysis model.").addText(
      (text) => text.setPlaceholder("qwen2.5:7b").setValue(this.plugin.settings.qaOllamaModel).onChange(async (value) => {
        await this.plugin.setQaModelOverrideForQa(value.trim());
      })
    );
    const qaLocalHealth = this.plugin.getQaLocalModelValidationForQa(this.plugin.getQaRolePresetForQa());
    const localModelReadiness = new import_obsidian4.Setting(containerEl).setName("Local model readiness / \uB85C\uCEEC \uBAA8\uB378 \uC810\uAC80").setDesc(
      `${qaLocalHealth.summary}
Detected local models: ${qaLocalHealth.detectedCount}`
    ).addButton(
      (button) => button.setButtonText("Apply recommendation / \uAD8C\uC7A5\uAC12 \uC801\uC6A9").onClick(async () => {
        const summary = await this.plugin.applyRecommendedQaModelForRole(this.plugin.getQaRolePresetForQa());
        new import_obsidian4.Notice(summary, 6500);
        this.display();
      })
    ).addButton(
      (button) => button.setButtonText("Refresh detect / \uAC10\uC9C0 \uC0C8\uB85C\uACE0\uCE68").onClick(async () => {
        await this.plugin.refreshOllamaDetection({ notify: true, autoApply: true });
        this.display();
      })
    );
    if (qaLocalHealth.status === "warn" || qaLocalHealth.status === "blocked") {
      localModelReadiness.settingEl.addClass("omni-forge-setting-unavailable-model");
    }
    new import_obsidian4.Setting(containerEl).setName("Prefer Ollama /api/chat (with fallback)").setDesc("Use role-based chat first, then fallback to /api/generate when unavailable.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.qaPreferChatApi).onChange(async (value) => {
        this.plugin.settings.qaPreferChatApi = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Q&A retrieval top-k / \uAC80\uC0C9 \uC18C\uC2A4 \uC218").addText(
      (text) => text.setPlaceholder("5").setValue(String(this.plugin.settings.qaTopK)).onChange(async (value) => {
        this.plugin.settings.qaTopK = parsePositiveInt(
          value,
          this.plugin.settings.qaTopK
        );
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Q&A max context chars / \uCD5C\uB300 \uCEE8\uD14D\uC2A4\uD2B8 \uAE38\uC774").setDesc("Maximum total note characters to send to local LLM. / \uB85C\uCEEC LLM\uC5D0 \uC804\uB2EC\uD560 \uCD5C\uB300 \uBB38\uC790 \uC218").addText(
      (text) => text.setPlaceholder("12000").setValue(String(this.plugin.settings.qaMaxContextChars)).onChange(async (value) => {
        this.plugin.settings.qaMaxContextChars = parsePositiveInt(
          value,
          this.plugin.settings.qaMaxContextChars
        );
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Structured answer guard / \uAD6C\uC870\uD654 \uCD9C\uB825 \uAC00\uB4DC").setDesc("Enforce table/checklist/link structure for comparison/plan/source questions. / \uD45C\xB7\uCCB4\uD06C\uB9AC\uC2A4\uD2B8\xB7\uB9C1\uD06C \uD615\uC2DD\uC744 \uAC15\uC81C\uD569\uB2C8\uB2E4.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.qaStructureGuardEnabled).onChange(async (value) => {
        this.plugin.settings.qaStructureGuardEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Always detailed answers / \uD56D\uC0C1 \uC790\uC138\uD55C \uB2F5\uBCC0").setDesc("Prefer long, structured answers unless user explicitly asks for brief output. / \uC0AC\uC6A9\uC790\uAC00 \uC9E7\uAC8C \uC694\uCCAD\uD558\uC9C0 \uC54A\uC73C\uBA74 \uC0C1\uC138 \uB2F5\uBCC0\uC744 \uC6B0\uC120\uD569\uB2C8\uB2E4.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.qaAlwaysDetailedAnswer).onChange(async (value) => {
        this.plugin.settings.qaAlwaysDetailedAnswer = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Minimum answer chars / \uCD5C\uC18C \uB2F5\uBCC0 \uAE38\uC774").setDesc("Used by structured guard depth repair. / \uAD6C\uC870\uD654 \uAC00\uB4DC\uC758 \uAE38\uC774 \uBCF4\uC815 \uAE30\uC900").addText(
      (text) => text.setPlaceholder("320").setValue(String(this.plugin.settings.qaMinAnswerChars)).onChange(async (value) => {
        this.plugin.settings.qaMinAnswerChars = parsePositiveInt(
          value,
          this.plugin.settings.qaMinAnswerChars
        );
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Chat font size / \uCC44\uD305 \uAE00\uC790 \uD06C\uAE30").setDesc("Chat workspace font size in px (11-22).").addText(
      (text) => text.setPlaceholder("14").setValue(String(this.plugin.settings.qaChatFontSize)).onChange(async (value) => {
        const parsed = Number.parseInt(value, 10);
        if (!Number.isFinite(parsed)) {
          return;
        }
        this.plugin.settings.qaChatFontSize = Math.max(11, Math.min(22, parsed));
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Show system messages in chat / \uCC44\uD305 \uC2DC\uC2A4\uD15C \uBA54\uC2DC\uC9C0 \uD45C\uC2DC").setDesc("Off by default. When OFF, system logs are hidden and omitted from saved chat transcript.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.qaShowSystemMessages).onChange(async (value) => {
        this.plugin.settings.qaShowSystemMessages = value;
        await this.plugin.saveSettings();
        await this.plugin.refreshOpenQaWorkspaceViews();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Preferred response language / \uB2F5\uBCC0 \uC5B8\uC5B4 \uC6B0\uC120").setDesc("Applies to local Q&A prompt. / \uB85C\uCEEC Q&A \uD504\uB86C\uD504\uD2B8\uC5D0 \uC801\uC6A9").addDropdown(
      (dropdown) => dropdown.addOption("auto", "Auto / \uC790\uB3D9").addOption("korean", "Korean / \uD55C\uAD6D\uC5B4").addOption("english", "English / \uC601\uC5B4").setValue(this.plugin.settings.qaPreferredResponseLanguage).onChange(async (value) => {
        this.plugin.settings.qaPreferredResponseLanguage = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Q&A pipeline preset").setDesc("In Orchestration mode, default pipeline is auto-route and applied automatically. / 오케스트레이션 모드에서는 기본 파이프라인(auto-route)이 자동 적용됩니다.").addDropdown((dropdown) => {
      const pipelineOptions = this.plugin.getQaPipelinePresetOptionsForQa();
      for (const option of pipelineOptions) {
        dropdown.addOption(option.value, option.label);
      }
      const fallback = pipelineOptions.length > 0 ? pipelineOptions[0].value : this.plugin.settings.qaPipelinePreset;
      dropdown.setValue(pipelineOptions.some((option) => option.value === this.plugin.settings.qaPipelinePreset) ? this.plugin.settings.qaPipelinePreset : fallback).onChange(async (value) => {
        await this.plugin.setQaPipelinePresetForQa(value);
        this.display();
      });
      if (pipelineOptions.length <= 1) {
        dropdown.setDisabled(true);
      }
    });
    this.addPresetProfileModelSetting(containerEl, {
      name: "Pro preset base model",
      description: "Optional manual base-model override for Pro preset.",
      key: "qaBalancedPresetBaseModel",
      kind: "text",
      placeholder: "qwen3:14b",
      preset: "balanced_local"
    });
    this.addPresetProfileModelSetting(containerEl, {
      name: "Pro preset vision model",
      description: "Optional manual vision-model override for Pro preset.",
      key: "qaBalancedPresetVisionModel",
      kind: "vision",
      placeholder: "qwen2.5vl:7b",
      preset: "balanced_local"
    });
    this.addPresetProfileModelSetting(containerEl, {
      name: "Pro preset embedding model",
      description: "Optional manual embedding-model override for Pro preset.",
      key: "qaBalancedPresetEmbeddingModel",
      kind: "embedding",
      placeholder: "nomic-embed-text",
      preset: "balanced_local"
    });
    const presetWarnings = this.collectPresetOverrideWarnings();
    new import_obsidian4.Setting(containerEl).setName("Preset override warning summary").setDesc(
      presetWarnings.length > 0 ? presetWarnings.map((item) => `- ${item.name}: ${item.note}`).join("\n") : "\uD604\uC7AC \uAC10\uC9C0\uB41C \uD504\uB9AC\uC14B \uC624\uBC84\uB77C\uC774\uB4DC \uACBD\uACE0(\u26A0)\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4."
    ).addButton(
      (button) => button.setButtonText("Guide\uC5D0\uC11C \uBCF4\uAE30").onClick(async () => {
        this.plugin.settings.settingsActiveTab = "guide";
        await this.plugin.saveSettings();
        this.display();
      })
    );
    for (const config of ROLE_MODEL_SETTING_CONFIGS) {
      const roleOptions = this.plugin.getRoleModelOptionsForQa(config.role);
      this.addRoleModelPickerSetting(containerEl, config, roleOptions);
    }
    if (this.plugin.settings.qaPipelinePreset === "legacy_auto") {
      new import_obsidian4.Setting(containerEl).setName("Enable orchestrator pipeline / \uC624\uCF00\uC2A4\uD2B8\uB808\uC774\uD130 \uD30C\uC774\uD504\uB77C\uC778").setDesc("Use an orchestration rewrite pass for planning/report/PPT/game-style tasks. / \uACC4\uD68D\uC11C\xB7\uBCF4\uACE0\uC11C\xB7PPT\xB7\uAC8C\uC784 \uACFC\uC81C\uC5D0 \uCD94\uAC00 \uC815\uB9AC \uD328\uC2A4\uB97C \uC801\uC6A9").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.qaOrchestratorEnabled).onChange(async (value) => {
          this.plugin.settings.qaOrchestratorEnabled = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian4.Setting(containerEl).setName("Enable safeguard verification / \uC138\uC774\uD504\uAC00\uB4DC \uAC80\uC99D").setDesc("Run a final factual/safety consistency pass against sources before returning answer. / \uCD9C\uCC98 \uAE30\uC900 \uC0AC\uC2E4\xB7\uBCF4\uC548 \uC77C\uAD00\uC131 \uCD5C\uC885 \uC810\uAC80").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.qaSafeguardPassEnabled).onChange(async (value) => {
          this.plugin.settings.qaSafeguardPassEnabled = value;
          await this.plugin.saveSettings();
        })
      );
    }
    const customPromptSetting = new import_obsidian4.Setting(containerEl).setName("Custom system prompt / \uC0AC\uC6A9\uC790 \uC2DC\uC2A4\uD15C \uD504\uB86C\uD504\uD2B8").setDesc(
      "Optional global policy/style instructions. Beginner default is prefilled and can be restored anytime. / \uC804\uCCB4 \uC5ED\uD560\uC5D0 \uACF5\uD1B5 \uC801\uC6A9\uB418\uB294 \uC9C0\uC2DC\uC785\uB2C8\uB2E4."
    ).addTextArea((text) => {
      text.inputEl.addClass("omni-forge-setting-prompt-textarea");
      text.inputEl.rows = 10;
      return text.setPlaceholder(DEFAULT_SETTINGS.qaCustomSystemPrompt).setValue(this.plugin.settings.qaCustomSystemPrompt).onChange(async (value) => {
        this.plugin.settings.qaCustomSystemPrompt = value;
        await this.plugin.saveSettings();
      });
    }).addButton(
      (button) => button.setButtonText("Use default / \uAE30\uBCF8\uAC12").onClick(async () => {
        this.plugin.settings.qaCustomSystemPrompt = DEFAULT_SETTINGS.qaCustomSystemPrompt;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    customPromptSetting.settingEl.addClass("omni-forge-setting-prompt-editor");
    const rolePromptSetting = new import_obsidian4.Setting(containerEl).setName("Role system prompt editor").setDesc(
      "Add extra system instructions per role agent. Empty keeps built-in role prompt only."
    ).addDropdown((dropdown) => {
      for (const option of QA_ROLE_PRESET_OPTIONS) {
        dropdown.addOption(option.value, option.label);
      }
      dropdown.setValue(this.rolePromptEditorTarget).onChange((value) => {
        this.rolePromptEditorTarget = value;
        this.display();
      });
    }).addTextArea((text) => {
      text.inputEl.addClass("omni-forge-setting-prompt-textarea");
      text.inputEl.rows = 12;
      const roleDefault = this.plugin.getDefaultQaRoleSystemPromptForQa(this.rolePromptEditorTarget);
      const roleCurrent = this.plugin.getQaRoleSystemPromptForQa(this.rolePromptEditorTarget);
      const roleEditorValue = roleCurrent.trim() === roleDefault.trim() ? "" : roleCurrent;
      return text.setPlaceholder(
        roleDefault
      ).setValue(roleEditorValue).onChange(async (value) => {
        await this.plugin.setQaRoleSystemPromptForQa(
          this.rolePromptEditorTarget,
          value
        );
      });
    }).addButton(
      (button) => button.setButtonText("Use role default / \uC5ED\uD560 \uAE30\uBCF8\uAC12").onClick(async () => {
        await this.plugin.setQaRoleSystemPromptForQa(
          this.rolePromptEditorTarget,
          this.plugin.getDefaultQaRoleSystemPromptForQa(this.rolePromptEditorTarget)
        );
        this.display();
      })
    );
    rolePromptSetting.settingEl.addClass("omni-forge-setting-prompt-editor");
    containerEl.createEl("h3", { text: "Pipeline prompt tips / \uD30C\uC774\uD504\uB77C\uC778 \uD504\uB86C\uD504\uD2B8 \uD301" });
    const pipelineTips = containerEl.createEl("ul", { cls: "omni-forge-settings-guide-list" });
    const tipPlanning = pipelineTips.createEl("li");
    tipPlanning.createDiv({ text: "Planning / \uACC4\uD68D" });
    tipPlanning.createEl("small", {
      text: "\uD504\uB86C\uD504\uD2B8 \uC608\uC2DC: \uBAA9\uD45C, \uBC94\uC704, \uC81C\uC57D, \uC644\uB8CC \uC870\uAC74\uC744 \uBA3C\uC800 \uC8FC\uACE0 '\uB2E8\uACC4\uBCC4 \uC2E4\uD589 \uACC4\uD68D + \uD575\uC2EC \uB9AC\uC2A4\uD06C + \uAC80\uC99D \uCCB4\uD06C\uB9AC\uC2A4\uD2B8' \uD615\uC2DD\uC73C\uB85C \uC694\uCCAD"
    });
    const tipCoding = pipelineTips.createEl("li");
    tipCoding.createDiv({ text: "Implementation / \uAD6C\uD604" });
    tipCoding.createEl("small", {
      text: "\uD504\uB86C\uD504\uD2B8 \uC608\uC2DC: \uB300\uC0C1 \uD30C\uC77C, \uAE30\uB300 \uD589\uB3D9, \uAE08\uC9C0 \uD589\uB3D9(\uD30C\uAD34/\uC678\uBD80\uC804\uC1A1)\uC744 \uBA85\uC2DC\uD558\uACE0 '\uBCF4\uC218\uC801 \uBCC0\uACBD + \uC790\uB3D9 \uAC80\uC99D \uBA85\uB839 + \uB864\uBC31 \uD3EC\uC778\uD2B8' \uD3EC\uD568 \uC694\uCCAD"
    });
    const tipReview = pipelineTips.createEl("li");
    tipReview.createDiv({ text: "Review / \uAC80\uD1A0" });
    tipReview.createEl("small", {
      text: "\uD504\uB86C\uD504\uD2B8 \uC608\uC2DC: 'P1->P2->P3 \uC21C\uC11C\uB85C \uBC84\uADF8/\uD68C\uADC0/\uAC80\uC99D\uB204\uB77D\uB9CC \uC9DA\uACE0, \uAC01 \uD56D\uBAA9\uC5D0 \uC99D\uAC70 \uD30C\uC77C/\uC904\uBC88\uD638\uB97C \uD45C\uAE30' \uC694\uCCAD"
    });
    new import_obsidian4.Setting(containerEl).setName("Include selection inventory / \uC120\uD0DD \uD30C\uC77C \uC778\uBCA4\uD1A0\uB9AC \uD3EC\uD568").setDesc("For large scopes, include selected-file metadata list to reduce 'insufficient evidence' answers. / \uB300\uADDC\uBAA8 \uC120\uD0DD \uC2DC \uC804\uCCB4 \uD30C\uC77C \uBA54\uD0C0 \uBAA9\uB85D\uC744 \uCEE8\uD14D\uC2A4\uD2B8\uC5D0 \uCD94\uAC00").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.qaIncludeSelectionInventory).onChange(async (value) => {
        this.plugin.settings.qaIncludeSelectionInventory = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Inventory max files / \uC778\uBCA4\uD1A0\uB9AC \uCD5C\uB300 \uD30C\uC77C \uC218").setDesc("Upper bound for selected-file metadata snapshot in Q&A context. / Q&A \uCEE8\uD14D\uC2A4\uD2B8\uC5D0 \uB123\uC744 \uCD5C\uB300 \uD30C\uC77C \uC218").addText(
      (text) => text.setPlaceholder("200").setValue(String(this.plugin.settings.qaSelectionInventoryMaxFiles)).onChange(async (value) => {
        this.plugin.settings.qaSelectionInventoryMaxFiles = parsePositiveInt(
          value,
          this.plugin.settings.qaSelectionInventoryMaxFiles
        );
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Chat transcript folder path").setDesc("Vault-relative path for saving chat transcripts.").addText(
      (text) => text.setPlaceholder("Omni Forge Chats").setValue(this.plugin.settings.chatTranscriptRootPath).onChange(async (value) => {
        this.plugin.settings.chatTranscriptRootPath = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Attachment ingest folder path").setDesc("Vault-relative folder where external attachments are mirrored for stable source links.").addText(
      (text) => text.setPlaceholder("Omni Forge Ingest").setValue(this.plugin.settings.qaAttachmentIngestRootPath).onChange(async (value) => {
        this.plugin.settings.qaAttachmentIngestRootPath = (0, import_obsidian4.normalizePath)(
          value.trim() || DEFAULT_SETTINGS.qaAttachmentIngestRootPath
        );
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Auto-sync chat thread").setDesc(
      "When enabled, the current chat thread is continuously saved and updated as messages change."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.qaThreadAutoSyncEnabled).onChange(async (value) => {
        this.plugin.settings.qaThreadAutoSyncEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("PDF attachments in chat").setDesc("\uAE30\uBCF8 ON\uC785\uB2C8\uB2E4. \uD30C\uC11C \uAD00\uB828 \uC0C1\uC138 \uC124\uC815\uC740 Chat \uD0ED\uC5D0\uC11C \uAD00\uB9AC\uD569\uB2C8\uB2E4.");
    new import_obsidian4.Setting(containerEl).setName("Parser mode").setDesc("Fast는 경량 파서, Detailed는 OCR 페이지 확장과 긴 텍스트 추출을 사용합니다.").addDropdown(
      (dropdown) => dropdown.addOption("fast", "Fast / 빠른 파서").addOption("detailed", "Detailed / 상세 파서").setValue(this.plugin.settings.qaParserMode).onChange(async (value) => {
        this.plugin.settings.qaParserMode = value === "detailed" ? "detailed" : "fast";
        await this.plugin.saveSettings();
        await this.plugin.refreshOpenQaWorkspaceViews();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Parser inbox default collapsed").setDesc("If enabled, parser inbox control section is collapsed by default in chat view.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.qaParserInboxCollapsedDefault).onChange(async (value) => {
        this.plugin.settings.qaParserInboxCollapsedDefault = value;
        await this.plugin.saveSettings();
        await this.plugin.refreshOpenQaWorkspaceViews();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Selected-notes ask: require selection").setDesc("When command 'Ask local AI from selected notes' is used, block send if selection is empty.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.qaRequireSelectionForSelectedAsk).onChange(async (value) => {
        this.plugin.settings.qaRequireSelectionForSelectedAsk = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Parser inbox watch").setDesc("Watch inbox folder for PDF/DOCX/XLSX/HWP/HWPX uploads and auto-convert to parser output. Multiple files are processed in sequential/safe order. HWPX supports first-pass text extraction; HWP requires LibreOffice soffice for auto (hwp->pdf) and falls back to guide if unavailable/failed.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.qaParserInboxWatchEnabled).onChange(async (value) => {
        this.plugin.settings.qaParserInboxWatchEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Parser inbox folder").setDesc("Vault-relative folder watched by parser inbox pipeline.").addText(
      (text) => text.setPlaceholder("inbox").setValue(this.plugin.settings.qaParserInboxFolder).onChange(async (value) => {
        this.plugin.settings.qaParserInboxFolder = (0, import_obsidian4.normalizePath)(value.trim() || "inbox");
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Parser ingest output format").setDesc("Output format for inbox conversion result: md (chat-ready markdown) or xml (structured metadata + content).").addDropdown(
      (dropdown) => dropdown.addOption("md", "md").addOption("xml", "xml").setValue(this.plugin.settings.qaParserIngestOutputFormat).onChange(async (value) => {
        this.plugin.settings.qaParserIngestOutputFormat = value === "xml" ? "xml" : "md";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Enable agent tool mode (experimental)").setDesc(
      "Allow model-proposed actions (read/write/list/shell) from chat responses via omni-forge-actions JSON block."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.qaAgentToolModeEnabled).onChange(async (value) => {
        this.plugin.settings.qaAgentToolModeEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Require approval before tool execution").setDesc(
      "Recommended. If enabled, proposed actions are queued and run only after user sends '\uC2B9\uC778' or '/approve'."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.qaAgentRequireApproval).onChange(async (value) => {
        this.plugin.settings.qaAgentRequireApproval = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Allow shell tool (danger)").setDesc(
      "Allows run_shell actions via local terminal command execution. Keep off unless absolutely needed."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.qaAgentAllowShellTool).onChange(async (value) => {
        this.plugin.settings.qaAgentAllowShellTool = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Agent shell full access (danger)").setDesc(
      "If enabled, run_shell and agent file actions(read/write/list) can use any absolute path (allowlist bypass)."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.qaAgentShellFullAccess).onChange(async (value) => {
        this.plugin.settings.qaAgentShellFullAccess = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Shell tool timeout (seconds)").setDesc("run_shell \uBA85\uB839 1\uD68C\uB2F9 \uCD5C\uB300 \uC2E4\uD589 \uC2DC\uAC04(\uCD08)\uC785\uB2C8\uB2E4. \uBB34\uD55C \uB300\uAE30 \uBC29\uC9C0\uC6A9 \uC548\uC804\uC7A5\uCE58\uC785\uB2C8\uB2E4.").addText(
      (text) => text.setPlaceholder("20").setValue(String(this.plugin.settings.qaAgentShellTimeoutSec)).onChange(async (value) => {
        this.plugin.settings.qaAgentShellTimeoutSec = Math.max(
          3,
          Math.min(
            300,
            parsePositiveInt(value, this.plugin.settings.qaAgentShellTimeoutSec)
          )
        );
        await this.plugin.saveSettings();
        text.setValue(String(this.plugin.settings.qaAgentShellTimeoutSec));
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Shell tool default cwd (vault-relative, optional)").setDesc(
      "Pick a vault folder from dropdown for run_shell default start location. This is separate from absolute allowlist rules. / run_shell \uAE30\uBCF8 \uC2DC\uC791 \uD3F4\uB354\uB97C vault \uB4DC\uB86D\uB2E4\uC6B4\uC5D0\uC11C \uC120\uD0DD\uD569\uB2C8\uB2E4. \uC808\uB300\uACBD\uB85C allowlist\uC640\uB294 \uBCC4\uAC1C\uC785\uB2C8\uB2E4."
    ).addDropdown((dropdown) => {
      const folderOptions = this.getVaultFolderOptionsForShellCwd();
      const optionValues = /* @__PURE__ */ new Set();
      dropdown.addOption("", ". (Vault root / vault \uB8E8\uD2B8)");
      optionValues.add("");
      for (const folder of folderOptions) {
        dropdown.addOption(folder, folder);
        optionValues.add(folder);
      }
      const current = this.plugin.settings.qaAgentShellCwdPath.trim();
      const isAbsoluteCurrent = current.startsWith("/") || /^[A-Za-z]:/.test(current);
      if (current && !optionValues.has(current)) {
        const customLabel = isAbsoluteCurrent ? `${current} (absolute custom / \uC808\uB300\uACBD\uB85C \uC0AC\uC6A9\uC790\uAC12)` : `${current} (custom / \uC0AC\uC6A9\uC790\uAC12)`;
        dropdown.addOption(current, customLabel);
      }
      dropdown.setValue(current);
      dropdown.onChange(async (value) => {
        const trimmed = value.trim();
        try {
          if (!trimmed) {
            this.plugin.settings.qaAgentShellCwdPath = "";
          } else {
            this.plugin.settings.qaAgentShellCwdPath = this.plugin.sanitizeQaShellCwdPath(trimmed);
          }
          await this.plugin.saveSettings();
        } catch (error) {
          const message = error instanceof Error ? error.message : "Invalid shell cwd path";
          new import_obsidian4.Notice(message, 7e3);
          this.display();
        }
      });
    }).addButton(
      (button) => button.setButtonText("Refresh folders / \uD3F4\uB354 \uC0C8\uB85C\uACE0\uCE68").onClick(() => {
        this.display();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Agent path allowlist (absolute, comma/newline)").setDesc("Absolute path allowlist for run_shell cwd and agent file actions(read/write/list) when full access is OFF. Default: (empty, vault-only)").addTextArea(
      (text) => text.setPlaceholder("/absolute/path/project,/absolute/path/vault").setValue(this.plugin.settings.qaAgentPathAllowlist).onChange(async (value) => {
        this.plugin.settings.qaAgentPathAllowlist = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Allow non-local Q&A endpoint (danger)").setDesc("Off by default. Keep disabled to prevent note data leaving localhost.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.qaAllowNonLocalEndpoint).onChange(async (value) => {
        this.plugin.settings.qaAllowNonLocalEndpoint = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Allowed outbound hosts (non-local Q&A)").setDesc(
      "Comma/newline-separated host allowlist used when non-local endpoint is enabled. Example: api.openai.com, api.anthropic.com"
    ).addTextArea(
      (text) => text.setPlaceholder("api.openai.com,api.anthropic.com,generativelanguage.googleapis.com").setValue(this.plugin.settings.qaAllowedOutboundHosts).onChange(async (value) => {
        this.plugin.settings.qaAllowedOutboundHosts = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Remove legacy AI-prefixed keys").setDesc(
      "If enabled, removes only legacy keys like ai_*/autolinker_* while preserving other existing keys (including linter date fields)."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.cleanUnknownFrontmatter).onChange(async (value) => {
        this.plugin.settings.cleanUnknownFrontmatter = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Property cleanup" });
    new import_obsidian4.Setting(containerEl).setName("Enable cleanup rules during apply").setDesc(
      "AI \uC81C\uC548\uC744 \uC801\uC6A9\uD560 \uB54C, \uC544\uB798 \uADDC\uCE59\uC73C\uB85C frontmatter \uD0A4\uB97C \uC790\uB3D9 \uC815\uB9AC\uD569\uB2C8\uB2E4. \uCD08\uBCF4\uC790\uB294 \uBA3C\uC800 dry-run\uC73C\uB85C \uD655\uC778\uC744 \uAD8C\uC7A5\uD569\uB2C8\uB2E4."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.propertyCleanupEnabled).onChange(async (value) => {
        this.plugin.settings.propertyCleanupEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Cleanup exact keys").setDesc("Comma/newline separated keys. Example: related, linked_context").addTextArea(
      (text) => text.setPlaceholder("related").setValue(this.plugin.settings.propertyCleanupKeys).onChange(async (value) => {
        this.plugin.settings.propertyCleanupKeys = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Pick cleanup keys from selected notes").setDesc("Scan selected notes and choose keys by checkbox.").addButton(
      (button) => button.setButtonText("Open picker / \uC120\uD0DD\uAE30 \uC5F4\uAE30").onClick(async () => {
        await this.plugin.openCleanupKeyPicker();
        this.display();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Cleanup key prefixes").setDesc("Comma/newline separated prefixes. Example: temp_, draft_").addTextArea(
      (text) => text.setPlaceholder("temp_,draft_").setValue(this.plugin.settings.propertyCleanupPrefixes).onChange(async (value) => {
        this.plugin.settings.propertyCleanupPrefixes = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Never remove these keys").setDesc("Comma/newline separated keys that override cleanup rules.").addTextArea(
      (text) => text.setPlaceholder("date created,date updated").setValue(this.plugin.settings.propertyCleanupKeepKeys).onChange(async (value) => {
        this.plugin.settings.propertyCleanupKeepKeys = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Run cleanup command").setDesc(
      "\uC2E4\uC81C \uC801\uC6A9 \uC804 `Dry-run cleanup...`\uC73C\uB85C \uACB0\uACFC\uB97C \uBA3C\uC800 \uD655\uC778\uD558\uACE0, \uBB38\uC81C \uC5C6\uC744 \uB54C `Cleanup...`\uC744 \uC2E4\uD589\uD558\uC138\uC694."
    );
    new import_obsidian4.Setting(containerEl).setName("Cleanup dry-run report folder").setDesc(
      "dry-run \uACB0\uACFC \uB9AC\uD3EC\uD2B8\uB97C \uC800\uC7A5\uD560 \uD3F4\uB354\uC785\uB2C8\uB2E4. \uC2E4\uC81C \uD30C\uC77C \uC218\uC815 \uC5C6\uC774 \uBCC0\uACBD \uC608\uC815 \uD56D\uBAA9\uB9CC \uD655\uC778\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4."
    ).addText(
      (text) => text.setPlaceholder("Omni Forge Reports").setValue(this.plugin.settings.cleanupReportRootPath).onChange(async (value) => {
        this.plugin.settings.cleanupReportRootPath = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Sort tags and linked arrays").setDesc("Helps keep stable output and reduce linter churn.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.sortArrays).onChange(async (value) => {
        this.plugin.settings.sortArrays = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Selection and backup" });
    new import_obsidian4.Setting(containerEl).setName("Include subfolders for selected folders").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.includeSubfoldersInFolderSelection).onChange(async (value) => {
        this.plugin.settings.includeSubfoldersInFolderSelection = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Folder reclass move apply" });
    new import_obsidian4.Setting(containerEl).setName("Auto-create target folders").setDesc(
      "When move apply runs, create missing suggested folders automatically."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoCreateTargetFolders === true).onChange(async (value) => {
        this.plugin.settings.autoCreateTargetFolders = value === true;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Folder reclass apply mode").setDesc(
      "metadata_only: no move. move_only: move files only. metadata_and_move: allow both."
    ).addDropdown(
      (dropdown) => dropdown.addOption("metadata_only", "metadata_only").addOption("move_only", "move_only").addOption("metadata_and_move", "metadata_and_move").setValue(
        normalizeFolderReclassApplyMode(this.plugin.settings.applyMode)
      ).onChange(async (value) => {
        this.plugin.settings.applyMode = normalizeFolderReclassApplyMode(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Move conflict policy").setDesc(
      "suffix: append (n) to resolve conflicts. skip: keep existing and skip move."
    ).addDropdown(
      (dropdown) => dropdown.addOption("suffix", "suffix").addOption("skip", "skip").setValue(
        normalizeFolderReclassMoveConflictPolicy(this.plugin.settings.moveConflictPolicy)
      ).onChange(async (value) => {
        this.plugin.settings.moveConflictPolicy = normalizeFolderReclassMoveConflictPolicy(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Watch folders for new notes / \uC2E0\uADDC \uB178\uD2B8 \uD3F4\uB354 \uAC10\uC2DC").setDesc(
      "When a new markdown file appears in watched folders, prompt to add/analyze it. / \uC2E0\uADDC \uBB38\uC11C \uC0DD\uC131 \uC2DC \uC120\uD0DD/\uBD84\uC11D \uC5EC\uBD80\uB97C \uBB3B\uC2B5\uB2C8\uB2E4."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.watchNewNotesEnabled).onChange(async (value) => {
        this.plugin.settings.watchNewNotesEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Watched folders / \uAC10\uC2DC \uD3F4\uB354").setDesc("Comma/newline separated vault-relative folder paths. Example: Inbox,Clippings / \uC608: Inbox,Clippings").addTextArea(
      (text) => text.setPlaceholder("Inbox,Clippings").setValue(this.plugin.settings.watchNewNotesFolders).onChange(async (value) => {
        this.plugin.settings.watchNewNotesFolders = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("PR3 Scope Roots (vault-relative)").setDesc(
      "Vault-relative paths only (use / separators)\nNo .. traversal, no absolute paths\nOne root per line\nMax 20 roots (extras ignored)\nWarn-only informational; no enforcement"
    ).addTextArea((text) => text.setPlaceholder("Inbox\nProjects/Active").setValue(this.plugin.settings.pr3ScopeRoots).onChange(async (value) => {
      this.plugin.settings.pr3ScopeRoots = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Show PR3 scope fingerprint (debug)").setDesc("Debug-only. Fingerprint derived from resolved roots/status (warn-only). Avoid sharing screenshots/logs if this may reveal structure.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showPr3ScopeFingerprint).onChange(async (value) => {
        this.plugin.settings.showPr3ScopeFingerprint = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Auto-tag active note / \uD604\uC7AC \uBB38\uC11C \uC790\uB3D9 \uD0DC\uAE45").setDesc("On file-open, auto-analyze and merge tags for the active markdown note. / \uBB38\uC11C \uC5F4\uAE30 \uC2DC \uD0DC\uADF8\uB9CC \uC790\uB3D9 \uBD84\uC11D\xB7\uBCD1\uD569").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoTagActiveNoteEnabled).onChange(async (value) => {
        this.plugin.settings.autoTagActiveNoteEnabled = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Auto-tag cooldown seconds / \uC790\uB3D9 \uD0DC\uAE45 \uCFE8\uB2E4\uC6B4(\uCD08)").setDesc("Minimum interval before re-tagging the same note. / \uAC19\uC740 \uB178\uD2B8 \uC7AC\uD0DC\uAE45 \uCD5C\uC18C \uAC04\uACA9").addText(
      (text) => text.setPlaceholder("90").setValue(String(this.plugin.settings.autoTagActiveNoteCooldownSec)).onChange(async (value) => {
        this.plugin.settings.autoTagActiveNoteCooldownSec = parsePositiveInt(
          value,
          this.plugin.settings.autoTagActiveNoteCooldownSec
        );
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Selection path width percent").setDesc("Controls path width in Select target notes/folders modal (45-100).").addText(
      (text) => text.setPlaceholder("72").setValue(String(this.plugin.settings.selectionPathWidthPercent)).onChange(async (value) => {
        const parsed = Number.parseInt(value, 10);
        if (Number.isFinite(parsed) && parsed >= 45 && parsed <= 100) {
          this.plugin.settings.selectionPathWidthPercent = parsed;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Excluded folder patterns").setDesc("Comma-separated substrings. Matched folders are ignored during selection/analysis.").addText(
      (text) => text.setPlaceholder(".obsidian,Omni Forge Backups").setValue(this.plugin.settings.excludedFolderPatterns).onChange(async (value) => {
        this.plugin.settings.excludedFolderPatterns = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Backup selected notes before apply").setDesc("You can also override this every run from the backup confirmation dialog.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.backupBeforeApply).onChange(async (value) => {
        this.plugin.settings.backupBeforeApply = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Backup root path").setDesc("Vault-relative folder path used for versioned backups.").addText(
      (text) => text.setPlaceholder("Omni Forge Backups").setValue(this.plugin.settings.backupRootPath).onChange(async (value) => {
        try {
          await this.plugin.setBackupRootPathForQa(value);
        } catch (error) {
          const message = error instanceof Error ? error.message : "Invalid backup root path.";
          new import_obsidian4.Notice(message, 6e3);
          text.setValue(this.plugin.settings.backupRootPath);
        }
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Backup retention count").setDesc("Keep only latest N backups (old backups are deleted automatically).").addText(
      (text) => text.setPlaceholder("10").setValue(String(this.plugin.settings.backupRetentionCount)).onChange(async (value) => {
        this.plugin.settings.backupRetentionCount = parsePositiveInt(
          value,
          this.plugin.settings.backupRetentionCount
        );
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "MOC" });
    new import_obsidian4.Setting(containerEl).setName("Generate MOC after apply").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.generateMoc).onChange(async (value) => {
        this.plugin.settings.generateMoc = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("MOC file path").setDesc("Vault-relative markdown path.").addText(
      (text) => text.setPlaceholder("MOC/Selected Knowledge MOC.md").setValue(this.plugin.settings.mocPath).onChange(async (value) => {
        try {
          await this.plugin.setMocPathForQa(value);
        } catch (error) {
          const message = error instanceof Error ? error.message : "Invalid MOC path.";
          new import_obsidian4.Notice(message, 6e3);
          text.setValue(this.plugin.settings.mocPath);
        }
      })
    );
    if (activeTab === "analyzed") {
      this.prioritizeAnalyzedEmbeddingSection(containerEl);
    }
    this.applySettingsTabVisibility(containerEl);
    this.applyCompactSettingsVisibility(containerEl);
    this.hideEmptySettingSections(containerEl);
    this.applyBilingualSettingsLabels(containerEl);
  }
  applyBilingualSettingsLabels(containerEl) {
    const mode = this.plugin.settings.settingsUiLanguage;
    if (mode === "en") {
      const nameEls2 = containerEl.querySelectorAll(".setting-item-name");
      for (const nameEl of Array.from(nameEls2)) {
        const inline = splitInlineBilingualText(nameEl.textContent);
        if (!inline) {
          continue;
        }
        nameEl.removeClass("omni-forge-bilingual-field");
        nameEl.textContent = inline.en;
      }
      const descEls2 = containerEl.querySelectorAll(".setting-item-description");
      for (const descEl of Array.from(descEls2)) {
        const inline = splitInlineBilingualText(descEl.textContent);
        if (!inline) {
          continue;
        }
        descEl.removeClass("omni-forge-bilingual-field");
        descEl.textContent = inline.en;
      }
      const headerEls2 = containerEl.querySelectorAll("h2, h3");
      for (const headerEl of Array.from(headerEls2)) {
        const inline = splitInlineBilingualText(headerEl.textContent);
        if (!inline) {
          continue;
        }
        headerEl.textContent = inline.en;
      }
      return;
    }
    const headerEls = containerEl.querySelectorAll("h2, h3");
    for (const headerEl of Array.from(headerEls)) {
      const inline = splitInlineBilingualText(headerEl.textContent);
      if (inline) {
        headerEl.textContent = mode === "ko" ? inline.ko : `${inline.en} / ${inline.ko}`;
        continue;
      }
      const localized = toKoreanBilingualParts(headerEl.textContent, SETTINGS_HEADER_KO_MAP);
      if (localized && mode === "ko") {
        headerEl.textContent = localized.ko;
      } else if (localized && mode === "bilingual") {
        headerEl.textContent = `${localized.en} / ${localized.ko}`;
      }
    }
    const nameEls = containerEl.querySelectorAll(".setting-item-name");
    for (const nameEl of Array.from(nameEls)) {
      const inline = splitInlineBilingualText(nameEl.textContent);
      if (inline) {
        nameEl.removeClass("omni-forge-bilingual-field");
        nameEl.textContent = mode === "ko" ? inline.ko : `${inline.en} / ${inline.ko}`;
        continue;
      }
      const localized = toKoreanBilingualParts(nameEl.textContent, SETTINGS_NAME_KO_MAP);
      if (localized && mode === "ko") {
        nameEl.removeClass("omni-forge-bilingual-field");
        nameEl.textContent = localized.ko;
      } else if (localized && mode === "bilingual") {
        nameEl.empty();
        nameEl.addClass("omni-forge-bilingual-field");
        nameEl.createSpan({
          text: localized.en,
          cls: "omni-forge-bilingual-en"
        });
        nameEl.createSpan({
          text: localized.ko,
          cls: "omni-forge-bilingual-ko"
        });
      }
    }
    const descEls = containerEl.querySelectorAll(".setting-item-description");
    for (const descEl of Array.from(descEls)) {
      const inline = splitInlineBilingualText(descEl.textContent);
      if (inline) {
        descEl.removeClass("omni-forge-bilingual-field");
        descEl.textContent = mode === "ko" ? inline.ko : `${inline.en} / ${inline.ko}`;
        continue;
      }
      const localized = toKoreanBilingualParts(descEl.textContent, SETTINGS_DESC_KO_MAP);
      if (localized && mode === "ko") {
        descEl.removeClass("omni-forge-bilingual-field");
        descEl.textContent = localized.ko;
      } else if (localized && mode === "bilingual") {
        descEl.empty();
        descEl.addClass("omni-forge-bilingual-field");
        descEl.createSpan({
          text: localized.en,
          cls: "omni-forge-bilingual-en"
        });
        descEl.createSpan({
          text: localized.ko,
          cls: "omni-forge-bilingual-ko"
        });
      }
    }
  }
};
_KnowledgeWeaverSettingTab.TAB_OPTIONS = [
  { key: "quick", en: "General", ko: "\uC77C\uBC18" },
  { key: "analyzed", en: "Analyzed", ko: "\uBD84\uC11D" },
  { key: "chat", en: "Chat", ko: "\uCC44\uD305" },
  { key: "orchestration", en: "Orchestration", ko: "\uC624\uCF00\uC2A4\uD2B8\uB808\uC774\uC158" },
  { key: "skills", en: "Skills", ko: "\uC2A4\uD0AC\uC2A4" },
  { key: "guide", en: "Description", ko: "\uC124\uBA85" }
];
_KnowledgeWeaverSettingTab.QUICK_TAB_VISIBLE_NAME_PREFIXES = [
  "Settings UI language",
  "Quick provider",
  "Codex bridge note",
  "Ollama base URL",
  "LM Studio base URL",
  "LM Studio model",
  "LM Studio API key (optional)",
  "Ollama auto-match policy",
  "OpenAI base URL",
  "OpenAI model",
  "OpenAI API key",
  "Anthropic model",
  "Anthropic API key",
  "Gemini model",
  "Gemini API key",
  "Custom system prompt"
];
_KnowledgeWeaverSettingTab.ANALYZED_TAB_VISIBLE_NAME_PREFIXES = [
  "Analyzed depth mode",
  "Analyzed runtime estimate",
  "Analyzed scope snapshot",
  "Suggestion mode (recommended)",
  "Show reasons for each field",
  "Show progress notices",
  "Analyze tags",
  "Analyze topic",
  "Analyze linked",
  "Force all-to-all linked (deterministic)",
  "Analyze index",
  "Max tags",
  "Max linked",
  "Analyze changed notes only",
  "Enable semantic candidate ranking",
  "Embedding Ollama base URL",
  "Embedding detected model picker",
  "Embedding model (manual)",
  "Embedding auto-match policy",
  "Cloud embedding behavior",
  "Embedding detection summary",
  "Semantic top-k candidates",
  "Semantic min similarity",
  "Semantic source max chars",
  "Remove legacy AI-prefixed keys",
  "Enable cleanup rules during apply",
  "Cleanup exact keys",
  "Pick cleanup keys from selected notes",
  "Cleanup key prefixes",
  "Never remove these keys",
  "Run cleanup command",
  "Cleanup dry-run report folder",
  "Sort tags and linked arrays",
  "Include subfolders for selected folders",
  "Selection path width percent",
  "Excluded folder patterns",
  "Watch folders for new notes",
  "Watched folders",
  "Auto-tag active note",
  "Auto-tag cooldown seconds",
  "Backup selected notes before apply",
  "Backup root path",
  "Backup retention count",
  "Generate MOC after apply",
  "MOC file path"
];
_KnowledgeWeaverSettingTab.CHAT_TAB_VISIBLE_NAME_PREFIXES = [
  "Chat model profile",
  "Model inventory refresh",
  "Q&A model",
  "Local model readiness",
  "Ollama detected model picker",
  "Ollama detection summary",
  "Flash profile",
  "Pro profile",
  "Prefer Ollama /api/chat (with fallback)",
  "Q&A retrieval top-k",
  "Q&A max context chars",
  "Structured answer guard",
  "Always detailed answers",
  "Minimum answer chars",
  "Preferred response language",
  "Chat font size",
  "Show system messages in chat",
  "Include selection inventory",
  "Inventory max files",
  "Allow non-local Q&A endpoint (danger)",
  "Allowed outbound hosts (non-local Q&A)",
  "Chat transcript folder path",
  "Attachment ingest folder path",
  "Auto-sync chat thread",
  "PDF attachments in chat",
  "Parser mode",
  "Parser inbox default collapsed",
  "Parser inbox watch",
  "Parser inbox folder",
  "Parser ingest output format",
  "Enable agent tool mode (experimental)",
  "Require approval before tool execution",
  "Allow shell tool (danger)",
  "Agent shell full access (danger)",
  "Shell tool timeout (seconds)",
  "Shell tool default cwd (vault-relative, optional)",
  "Agent path allowlist (absolute, comma/newline)"
];
_KnowledgeWeaverSettingTab.ANALYZED_OLLAMA_ONLY_PREFIXES = [
  "Enable semantic candidate ranking",
  "Embedding Ollama base URL",
  "Embedding detected model picker",
  "Embedding model (manual)",
  "Embedding auto-match policy",
  "Embedding detection summary",
  "Semantic top-k candidates",
  "Semantic min similarity",
  "Semantic source max chars"
];
_KnowledgeWeaverSettingTab.CHAT_OLLAMA_ONLY_PREFIXES = [
  "Model inventory refresh",
  "Ollama detected model picker",
  "Ollama detection summary"
];
_KnowledgeWeaverSettingTab.CHAT_LOCAL_PROFILE_PREFIXES = [
  "Flash profile",
  "Pro profile"
];
_KnowledgeWeaverSettingTab.ORCHESTRATION_TAB_VISIBLE_NAME_PREFIXES = [
  "Conversation mode (chat runtime)",
  "Q&A pipeline preset",
  "Orchestration agent readiness",
  "Ask model (text)",
  "Ask model (vision)",
  "Image generator model",
  "Coder model",
  "Debugger model",
  "Architect model",
  "Orchestrator model",
  "Safeguard model",
  "Debugger agent",
  "Role system prompt editor"
];
_KnowledgeWeaverSettingTab.ADVANCED_TAB_VISIBLE_NAME_PREFIXES = [];
_KnowledgeWeaverSettingTab.SIMPLE_HIDDEN_SECTION_TITLES = /* @__PURE__ */ new Set([
  "Cloud provider config",
  "Semantic linking (Ollama embeddings)",
  "Property cleanup",
  "Selection and backup",
  "MOC"
]);
_KnowledgeWeaverSettingTab.SIMPLE_VISIBLE_NAME_PREFIXES = [
  "Settings UI language",
  "Plugin mission",
  "Quick one-click setup",
  "Conversation mode (chat runtime)",
  "Flash profile",
  "Open preset guide"
];
_KnowledgeWeaverSettingTab.SIMPLE_HIDDEN_NAME_KEYWORDS = [
  "Role model detection",
  "Role recommendation",
  "Ask model",
  "Image generator model",
  "Coder model",
  "Architect model",
  "Orchestrator model",
  "Safeguard model",
  "Role system prompt editor",
  "Custom system prompt",
  "Inventory max files"
];
var KnowledgeWeaverSettingTab = _KnowledgeWeaverSettingTab;
var PatchParser = class {
  normalizeUnifiedDiffText(rawDiff) {
    const trimmed = (rawDiff != null ? rawDiff : "").trim();
    if (!trimmed) {
      return "";
    }
    const fenced = /^```(?:diff)?\s*([\s\S]*?)```$/i.exec(trimmed);
    const body = fenced ? fenced[1] : trimmed;
    return body.replace(/\r\n/g, "\n").trim();
  }
  parse(diffText) {
    const normalized = this.normalizeUnifiedDiffText(diffText);
    if (!normalized) {
      return {
        hunks: [],
        error: "Unified diff is empty."
      };
    }
    const lines = normalized.split("\n");
    const pathHeaderPattern = /^(diff --git\s|index\s+[0-9a-f]+\.\.[0-9a-f]+|---\s+\S|\+\+\+\s+\S)/i;
    const hunks = [];
    let index = 0;
    while (index < lines.length && !lines[index].startsWith("@@")) {
      if (pathHeaderPattern.test(lines[index].trim())) {
        return {
          hunks: [],
          error: "Path-based diff headers are not allowed for selection patch."
        };
      }
      index += 1;
    }
    while (index < lines.length) {
      const header = lines[index];
      if (!header.startsWith("@@")) {
        if (pathHeaderPattern.test(header.trim())) {
          return {
            hunks: [],
            error: "Path-based multi-file diff is not allowed."
          };
        }
        index += 1;
        continue;
      }
      const match = /^@@\s*-(\d+)(?:,(\d+))?\s+\+(\d+)(?:,(\d+))?\s*@@/.exec(header);
      if (!match) {
        return {
          hunks: [],
          error: `Invalid hunk header: ${header}`
        };
      }
      const oldStart = Number.parseInt(match[1], 10);
      const oldCount = Number.parseInt(match[2] != null ? match[2] : "1", 10);
      const newStart = Number.parseInt(match[3], 10);
      const newCount = Number.parseInt(match[4] != null ? match[4] : "1", 10);
      if (!Number.isFinite(oldStart) || !Number.isFinite(oldCount) || !Number.isFinite(newStart) || !Number.isFinite(newCount) || oldStart < 1 || newStart < 1 || oldCount < 0 || newCount < 0) {
        return {
          hunks: [],
          error: `Invalid hunk range: ${header}`
        };
      }
      const hunkLines = [];
      let actualOldCount = 0;
      let actualNewCount = 0;
      index += 1;
      while (index < lines.length && !lines[index].startsWith("@@")) {
        const line = lines[index];
        if (line.startsWith("\\ No newline at end of file")) {
          index += 1;
          continue;
        }
        const prefix = line.slice(0, 1);
        if (prefix !== " " && prefix !== "+" && prefix !== "-") {
          return {
            hunks: [],
            error: `Invalid diff line prefix: ${line}`
          };
        }
        hunkLines.push({
          prefix,
          text: line.slice(1)
        });
        if (prefix === " " || prefix === "-") {
          actualOldCount += 1;
        }
        if (prefix === " " || prefix === "+") {
          actualNewCount += 1;
        }
        index += 1;
      }
      if (actualOldCount !== oldCount || actualNewCount !== newCount) {
        return {
          hunks: [],
          error: `Hunk line count mismatch: ${header}`
        };
      }
      hunks.push({
        oldStart,
        oldCount,
        newStart,
        newCount,
        lines: hunkLines
      });
    }
    if (hunks.length === 0) {
      return {
        hunks: [],
        error: "No @@ hunk found in unified diff."
      };
    }
    return {
      hunks,
      error: null
    };
  }
  countChangedLines(parsedDiff) {
    if (!parsedDiff || parsedDiff.error) {
      return 0;
    }
    let changed = 0;
    for (const hunk of parsedDiff.hunks) {
      for (const line of hunk.lines) {
        if (line.prefix === "+" || line.prefix === "-") {
          changed += 1;
        }
      }
    }
    return changed;
  }
  validateSelectionRange(parsedDiff, selectionText) {
    if (!parsedDiff || parsedDiff.error) {
      return {
        ok: false,
        error: "Unified diff parse failed."
      };
    }
    const normalizedSelection = (selectionText != null ? selectionText : "").replace(/\r\n/g, "\n");
    const selectionLineCount = normalizedSelection.length > 0 ? normalizedSelection.split("\n").length : 0;
    for (const hunk of parsedDiff.hunks) {
      const start = hunk.oldStart;
      const count = hunk.oldCount;
      if (start > selectionLineCount + 1) {
        return {
          ok: false,
          error: `Diff hunk starts outside selection range (line ${start} > ${selectionLineCount + 1}).`,
          selectionLineCount
        };
      }
      const end = count === 0 ? start - 1 : start + count - 1;
      if (end > selectionLineCount) {
        return {
          ok: false,
          error: `Diff hunk exceeds selection range (line ${end} > ${selectionLineCount}).`,
          selectionLineCount
        };
      }
    }
    return {
      ok: true,
      selectionLineCount
    };
  }
  validateLimits(parsedDiff, limits) {
    if (!parsedDiff || parsedDiff.error) {
      return {
        ok: false,
        error: (parsedDiff == null ? void 0 : parsedDiff.error) || "Unified diff parse failed.",
        changedLines: 0,
        hunks: 0,
        maxChangedLines: limits.maxChangedLines,
        maxHunks: limits.maxHunks
      };
    }
    const changedLines = this.countChangedLines(parsedDiff);
    const hunks = parsedDiff.hunks.length;
    if (changedLines === 0) {
      return {
        ok: false,
        error: "diff is not a valid unified diff.",
        changedLines,
        hunks,
        maxChangedLines: limits.maxChangedLines,
        maxHunks: limits.maxHunks
      };
    }
    if (hunks > limits.maxHunks) {
      return {
        ok: false,
        error: `Hunk count ${hunks} exceeds allowed limit ${limits.maxHunks}.`,
        changedLines,
        hunks,
        maxChangedLines: limits.maxChangedLines,
        maxHunks: limits.maxHunks
      };
    }
    if (changedLines > limits.maxChangedLines) {
      return {
        ok: false,
        error: `Changed lines ${changedLines} exceed allowed limit ${limits.maxChangedLines}.`,
        changedLines,
        hunks,
        maxChangedLines: limits.maxChangedLines,
        maxHunks: limits.maxHunks
      };
    }
    return {
      ok: true,
      changedLines,
      hunks,
      maxChangedLines: limits.maxChangedLines,
      maxHunks: limits.maxHunks
    };
  }
};
var PatchApplier = class {
  constructor(parser) {
    this.parser = parser;
  }
  linesEqual(left, right, trimRightWhitespace) {
    if (!trimRightWhitespace) {
      return left === right;
    }
    return left.replace(/\s+$/g, "") === right.replace(/\s+$/g, "");
  }
  blockEquals(lines, start, block, trimRightWhitespace) {
    if (start < 0 || start + block.length > lines.length) {
      return false;
    }
    for (let index = 0; index < block.length; index += 1) {
      if (!this.linesEqual(lines[start + index], block[index], trimRightWhitespace)) {
        return false;
      }
    }
    return true;
  }
  buildFuzzyAnchor(oldLines, contextEntries) {
    if (oldLines.length === 0 || contextEntries.length === 0) {
      return null;
    }
    let bestStartIndex = 0;
    let bestLength = 1;
    let currentStartIndex = 0;
    let currentLength = 1;
    for (let index = 1; index < contextEntries.length; index += 1) {
      if (contextEntries[index].oldIndex === contextEntries[index - 1].oldIndex + 1) {
        currentLength += 1;
      } else {
        if (currentLength > bestLength) {
          bestLength = currentLength;
          bestStartIndex = currentStartIndex;
        }
        currentStartIndex = index;
        currentLength = 1;
      }
    }
    if (currentLength > bestLength) {
      bestLength = currentLength;
      bestStartIndex = currentStartIndex;
    }
    const anchorStart = contextEntries[bestStartIndex].oldIndex;
    const anchorLength = Math.max(1, Math.min(3, bestLength));
    return {
      anchorStart,
      anchorLines: oldLines.slice(anchorStart, anchorStart + anchorLength)
    };
  }
  collectFuzzyCandidates(working, oldLines, anchor, trimRightWhitespace) {
    const candidateStarts = [];
    if (!anchor || anchor.anchorLines.length === 0) {
      return candidateStarts;
    }
    const maxAnchorStart = working.length - anchor.anchorLines.length;
    for (let anchorStart = 0; anchorStart <= maxAnchorStart; anchorStart += 1) {
      if (!this.blockEquals(working, anchorStart, anchor.anchorLines, trimRightWhitespace)) {
        continue;
      }
      const matchStart = anchorStart - anchor.anchorStart;
      if (matchStart < 0 || matchStart + oldLines.length > working.length) {
        continue;
      }
      if (!this.blockEquals(working, matchStart, oldLines, trimRightWhitespace)) {
        continue;
      }
      candidateStarts.push(matchStart);
    }
    return [...new Set(candidateStarts)];
  }
  applyStrict(sourceText, parsedDiff) {
    if (!parsedDiff || parsedDiff.error) {
      return {
        ok: false,
        error: (parsedDiff == null ? void 0 : parsedDiff.error) || "Unified diff parse failed.",
        text: sourceText,
        changedLines: 0
      };
    }
    const base = sourceText.replace(/\r\n/g, "\n");
    const working = base.split("\n");
    let delta = 0;
    for (const hunk of parsedDiff.hunks) {
      let cursor = hunk.oldStart - 1 + delta;
      if (cursor < 0 || cursor > working.length) {
        return {
          ok: false,
          error: `Hunk start is out of range (line ${hunk.oldStart}).`,
          text: sourceText,
          changedLines: 0
        };
      }
      for (const line of hunk.lines) {
        if (line.prefix === " ") {
          if (working[cursor] !== line.text) {
            return {
              ok: false,
              error: `Context mismatch at line ${cursor + 1}.`,
              text: sourceText,
              changedLines: 0
            };
          }
          cursor += 1;
          continue;
        }
        if (line.prefix === "-") {
          if (working[cursor] !== line.text) {
            return {
              ok: false,
              error: `Delete mismatch at line ${cursor + 1}.`,
              text: sourceText,
              changedLines: 0
            };
          }
          working.splice(cursor, 1);
          delta -= 1;
          continue;
        }
        if (line.prefix === "+") {
          working.splice(cursor, 0, line.text);
          cursor += 1;
          delta += 1;
        }
      }
    }
    return {
      ok: true,
      text: working.join("\n"),
      changedLines: this.parser.countChangedLines(parsedDiff)
    };
  }
  applyFuzzy(sourceText, parsedDiff) {
    if (!parsedDiff || parsedDiff.error) {
      return {
        ok: false,
        error: (parsedDiff == null ? void 0 : parsedDiff.error) || "Unified diff parse failed.",
        text: sourceText,
        changedLines: 0,
        usedTrimmedMatch: false
      };
    }
    const base = sourceText.replace(/\r\n/g, "\n");
    const working = base.split("\n");
    let usedTrimmedMatch = false;
    for (const hunk of parsedDiff.hunks) {
      const oldLines = [];
      const newLines = [];
      const contextEntries = [];
      let oldCursor = 0;
      for (const line of hunk.lines) {
        if (line.prefix !== "+") {
          if (line.prefix === " ") {
            contextEntries.push({ oldIndex: oldCursor, text: line.text });
          }
          oldLines.push(line.text);
          oldCursor += 1;
        }
        if (line.prefix !== "-") {
          newLines.push(line.text);
        }
      }
      const anchor = this.buildFuzzyAnchor(oldLines, contextEntries);
      if (!anchor) {
        return {
          ok: false,
          error: `Fuzzy match needs stable context anchor near hunk start line ${hunk.oldStart}. Regenerate unified diff with more context lines.`,
          text: sourceText,
          changedLines: 0,
          usedTrimmedMatch
        };
      }
      let candidates = this.collectFuzzyCandidates(working, oldLines, anchor, false);
      if (candidates.length === 0) {
        candidates = this.collectFuzzyCandidates(working, oldLines, anchor, true);
        if (candidates.length > 0) {
          usedTrimmedMatch = true;
        }
      }
      if (candidates.length !== 1) {
        const detail = candidates.length === 0 ? "no candidate" : `${candidates.length} candidates`;
        return {
          ok: false,
          error: `Fuzzy match is uncertain (${detail}) near hunk start line ${hunk.oldStart}. Regenerate unified diff.`,
          text: sourceText,
          changedLines: 0,
          usedTrimmedMatch
        };
      }
      const matchStart = candidates[0];
      working.splice(matchStart, oldLines.length, ...newLines);
    }
    return {
      ok: true,
      text: working.join("\n"),
      changedLines: this.parser.countChangedLines(parsedDiff),
      usedTrimmedMatch
    };
  }
  apply(sourceText, diffText, parsedDiff = null) {
    const parsed = parsedDiff || this.parser.parse(diffText);
    if (parsed.error) {
      return {
        ok: false,
        mode: "none",
        error: parsed.error,
        changedLines: 0,
        strictError: parsed.error,
        fuzzyError: ""
      };
    }
    const strictResult = this.applyStrict(sourceText, parsed);
    if (strictResult.ok) {
      return {
        ...strictResult,
        mode: "strict",
        strictError: "",
        fuzzyError: ""
      };
    }
    const fuzzyResult = this.applyFuzzy(sourceText, parsed);
    if (fuzzyResult.ok) {
      return {
        ...fuzzyResult,
        mode: "fuzzy",
        strictError: strictResult.error || "",
        fuzzyError: ""
      };
    }
    return {
      ok: false,
      mode: "none",
      error: `Strict apply failed: ${strictResult.error || "unknown"} | Fuzzy apply failed: ${fuzzyResult.error || "unknown"}`,
      changedLines: this.parser.countChangedLines(parsed),
      strictError: strictResult.error || "",
      fuzzyError: fuzzyResult.error || ""
    };
  }
};
var ScopedVault = class {
  constructor(allowRoots) {
    const roots = Array.isArray(allowRoots) ? allowRoots : [];
    this.allowRoots = roots.map((root) => this.normalizeVaultRelativePath(root, "scopeRoot")).filter((root, index, arr) => root.length > 0 && arr.indexOf(root) === index);
  }
  buildScopeError(code, message, pathValue) {
    const detail = pathValue ? `${message} (${pathValue})` : message;
    const error = new Error(`${code}: ${detail}`);
    error.code = code;
    error.path = pathValue || "";
    return error;
  }
  normalizeVaultRelativePath(rawPath, label = "path") {
    const source = (rawPath != null ? String(rawPath) : "").replace(/\\/g, "/").trim();
    if (label === "scopeRoot" && (source === "." || source === "./")) {
      return ".";
    }
    if (!source) {
      throw this.buildScopeError(CONTRACT_INVALID_PATH, `${label} is empty.`, source);
    }
    if (source.includes("\0")) {
      throw this.buildScopeError(CONTRACT_INVALID_PATH, `${label} contains null byte.`, source);
    }
    if (source.startsWith("/") || /^[A-Za-z]:/.test(source)) {
      throw this.buildScopeError(CONTRACT_INVALID_PATH, `${label} must be vault-relative.`, source);
    }
    const normalized = (0, import_obsidian4.normalizePath)(source);
    if (!normalized || normalized === "." || normalized === ".." || normalized.startsWith("../") || normalized.includes("/../")) {
      throw this.buildScopeError(CONTRACT_INVALID_PATH, `${label} contains invalid traversal.`, source);
    }
    return normalized;
  }
  isInsideAllowedRoots(pathValue) {
    if (this.allowRoots.length === 0) {
      return false;
    }
    return this.allowRoots.some((root) => {
      if (root === ".") {
        return true;
      }
      return pathValue === root || pathValue.startsWith(`${root}/`);
    });
  }
  assertPathInScope(rawPath, label = "path") {
    const normalized = this.normalizeVaultRelativePath(rawPath, label);
    if (!this.isInsideAllowedRoots(normalized)) {
      throw this.buildScopeError(
        DEFAULT_DENY_SCOPE_VIOLATION,
        `${label} is outside scoped roots: ${this.allowRoots.join(", ") || "(none)"}.`,
        normalized
      );
    }
    return normalized;
  }
};
var KnowledgeWeaverPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.statusBarEl = null;
    this.ollamaDetectionCache = null;
    this.ollamaDetectionOptions = [];
    this.ollamaDetectionSummary = "Model detection has not run yet. Click refresh to detect installed Ollama models.";
    this.embeddingDetectionCache = null;
    this.embeddingDetectionOptions = [];
    this.embeddingDetectionSummary = "Embedding model detection has not run yet. Click refresh to detect installed Ollama models.";
    this.analysisCache = null;
    this.analysisCacheDirty = false;
    this.pendingQaActionPlan = null;
    this.qaSelectedAskIntent = false;
    this.lastQaRoutingLog = null;
    this.oauthAutoLoginCooldownUntil = 0;
    this.oauthAutoLoginMissingConfigNotified = false;
    this.pendingNewNoteWatchPrompts = /* @__PURE__ */ new Set();
    this.parserInboxInFlightPaths = /* @__PURE__ */ new Set();
    this.parserInboxQueue = Promise.resolve();
    this.autoTagInFlightPaths = /* @__PURE__ */ new Set();
    this.autoTagLastRunByPath = /* @__PURE__ */ new Map();
    this.parserToolStatus = {
      pdftotext: false,
      pdftoppm: false,
      tesseract: false,
      soffice: false
    };
    this.parserToolSummary = "Parser tool check has not run yet.";
    this.parserInboxLastEvent = {
      fileName: "(none)",
      result: "idle",
      message: "Parser inbox idle"
    };
    this.parserInboxMetrics = {
      stage: "idle",
      queueLength: 0,
      processed: 0,
      total: 0,
      success: 0,
      skip: 0,
      error: 0,
      startedAt: 0,
      elapsedMs: 0,
      etaMs: 0,
      lastFile: "(none)",
      lastResult: "idle"
    };
  }
  async onload() {
    await this.loadSettings();
    this.statusBarEl = this.addStatusBarItem();
    this.setStatus("idle");
    this.registerView(
      LOCAL_QA_VIEW_TYPE,
      (leaf) => new LocalQAWorkspaceView(leaf, this)
    );
    await this.cleanupLegacyCacheArtifacts();
    void this.refreshParserToolReadinessForQa(false);
    this.addRibbonIcon("message-square", "Open Omni Forge", () => {
      void this.openLocalQaWorkspaceView();
    });
    this.registerEvent(
      this.app.vault.on("create", (entry) => {
        if (!(entry instanceof import_obsidian4.TFile)) {
          return;
        }
        if (entry.extension === "md") {
          void this.handleWatchedNewFile(entry);
          return;
        }
        void this.handleParserInboxFileCreate(entry);
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        if (!(file instanceof import_obsidian4.TFile) || file.extension !== "md") {
          return;
        }
        void this.handleAutoTagOnFileOpen(file);
      })
    );
    this.addCommand({
      id: "select-target-notes",
      name: "Select target notes/folders",
      callback: async () => this.openSelectionModal()
    });
    this.addCommand({
      id: "open-analyzed-track",
      name: "Open analyzed track snapshot (selection focus)",
      callback: async () => this.openAnalyzedTrack()
    });
    this.addCommand({
      id: "analyze-target-notes",
      name: "Analyze selected notes (suggestions by default)",
      callback: async () => this.runAnalysis()
    });
    this.addCommand({
      id: "apply-linked-edges-graph-view",
      name: "Apply linked edges to selected notes (Graph View)",
      callback: async () => this.applyLinkedEdgesForGraphView()
    });
    this.addCommand({
      id: "workflow-select-target-notes",
      name: "Workflow 1/3: Select target notes/folders",
      callback: async () => this.openSelectionModal()
    });
    this.addCommand({
      id: "workflow-analyze-target-notes",
      name: "Workflow 2/3: Analyze selected notes (suggestions by default)",
      callback: async () => this.runAnalysis()
    });
    this.addCommand({
      id: "workflow-apply-linked-edges-graph-view",
      name: "Workflow 3/3: Apply linked edges to selected notes (Graph View)",
      callback: async () => this.applyLinkedEdgesForGraphView()
    });
    this.addCommand({
      id: "workflow-ko-select-target-notes",
      name: "워크플로우 1/3: 선택(Select target notes/folders)",
      callback: async () => this.openSelectionModal()
    });
    this.addCommand({
      id: "workflow-ko-analyze-target-notes",
      name: "워크플로우 2/3: 분석/적용(Analyze selected notes)",
      callback: async () => this.runAnalysis()
    });
    this.addCommand({
      id: "workflow-ko-apply-linked-edges-graph-view",
      name: "워크플로우 3/3: 그래프 확인용 linked 반영(Apply linked edges to selected notes)",
      callback: async () => this.applyLinkedEdgesForGraphView()
    });
    this.addCommand({
      id: "graph-linked-flow-1-select",
      name: "Graph Linked 1/3: Select target notes/folders",
      callback: async () => this.openSelectionModal()
    });
    this.addCommand({
      id: "graph-linked-flow-2-analyze",
      name: "Graph Linked 2/3: Analyze selected notes (suggestions by default)",
      callback: async () => this.runAnalysis()
    });
    this.addCommand({
      id: "graph-linked-flow-3-apply",
      name: "Graph Linked 3/3: Apply linked edges to selected notes",
      callback: async () => this.applyLinkedEdgesForGraphView()
    });
    this.addCommand({
      id: "graph-linked-flow-ko-1-select",
      name: "그래프 linked 1/3: 선택(Select target notes/folders)",
      callback: async () => this.openSelectionModal()
    });
    this.addCommand({
      id: "graph-linked-flow-ko-2-analyze",
      name: "그래프 linked 2/3: 분석(Analyze selected notes)",
      callback: async () => this.runAnalysis()
    });
    this.addCommand({
      id: "graph-linked-flow-ko-3-apply",
      name: "그래프 linked 3/3: 반영(Apply linked edges to selected notes)",
      callback: async () => this.applyLinkedEdgesForGraphView()
    });
    this.addCommand({
      id: "explain-orchestrator-parser-modes",
      name: "Workflow/Graph Linked: Explain orchestration/parser modes (quick help)",
      callback: async () => {
        new import_obsidian4.Notice("Mode guide: Conversation mode controls agent routing(Ask/Plan/Agent/Orchestration). Parser mode controls attachment extraction(Fast vs Detailed OCR). Recommended default: Ask + Fast. For multi-step planning: Orchestration + Detailed. Check parser mode badges in chat header/status panel for current mode.", 9e3);
      }
    });
    this.addCommand({
      id: "oauth-google-login-now",
      name: "OAuth: Google login now (quick setup)",
      callback: async () => {
        this.applyGoogleOAuthQuickSetupForQa();
        await this.saveSettings();
        const validation = this.getOAuthLoginValidationForQa();
        if (!validation.ready) {
          new import_obsidian4.Notice(`${validation.message} ${validation.guidance || ""}`.trim(), 8e3);
          return;
        }
        try {
          await this.startOAuthLoginForQa();
          new import_obsidian4.Notice("OAuth login completed. / OAuth 로그인 완료", 4e3);
        } catch (error) {
          new import_obsidian4.Notice(this.formatOAuthLoginFailureForQa(error), 8e3);
        }
      }
    });
    this.addCommand({
      id: "parser-inbox-open-folder",
      name: "Parser inbox: Open folder",
      callback: async () => {
        await this.openParserInboxFolderForQa();
      }
    });
    this.addCommand({
      id: "parser-inbox-scan-now",
      name: "Parser inbox: Scan now",
      callback: async () => {
        await this.scanParserInboxNowForQa();
      }
    });
    this.addCommand({
      id: "parser-inbox-show-supported-formats",
      name: "Parser inbox: Show supported formats",
      callback: async () => {
        this.notice(`Parser formats: ${this.getParserSupportedFormatsForQa().join(", ")}`, 7e3);
      }
    });
    this.addCommand({
      id: "parser-inbox-toggle-watch",
      name: "Parser inbox: Toggle watch on/off",
      callback: async () => {
        const next = !this.settings.qaParserInboxWatchEnabled;
        await this.setParserInboxWatchEnabledForQa(next);
        this.notice(`Parser inbox watch: ${next ? "ON" : "OFF"}`, 5e3);
      }
    });
    this.addCommand({
      id: "folder-reclass-preview",
      name: "Folder reclassification (preview + apply moves)",
      callback: () => {
        const ctx = { app: this.app };
        const selectedFiles = [];
        const selectedPaths = Array.isArray(this.settings.targetFilePaths) ? [...this.settings.targetFilePaths] : [];
        let excludedCount = 0;
        for (const path of selectedPaths) {
          if (this.isPathExcluded(path)) {
            excludedCount += 1;
            continue;
          }
          const entry = this.app.vault.getAbstractFileByPath(path);
          if (entry instanceof import_obsidian4.TFile && entry.extension === "md") {
            selectedFiles.push(entry);
          }
        }
        const selectionScope = derivePR3DefaultDenyScopeFromSelection(
          selectedPaths,
          Array.isArray(this.settings.targetFolderPaths) ? this.settings.targetFolderPaths : [],
          (path) => this.isPathExcluded(path)
        );
        let selectionInfo;
        if (typeof console !== "undefined" && typeof console.debug === "function") {
          const resolvedFilesCount = selectedFiles.length;
          const hasFolderScope = Array.isArray(this.settings.targetFolderPaths) && this.settings.targetFolderPaths.length > 0;
          const comparisonSkippedBySize = selectedPaths.length > 1e3;
          let accessorCount;
          let countDelta;
          if (!comparisonSkippedBySize && typeof this.getSelectedFiles === "function" && !hasFolderScope) {
            const accessorFiles = this.getSelectedFiles();
            if (Array.isArray(accessorFiles)) {
              accessorCount = accessorFiles.length;
              countDelta = resolvedFilesCount - accessorCount;
            }
          }
          const debugPayload = {
            totalPaths: selectedPaths.length,
            excludedCount,
            resolvedFilesCount,
            scopeRootsCount: selectionScope.scope.roots.length,
            scopeRootsTruncated: selectionScope.rootsTruncated === true
          };
          if (comparisonSkippedBySize) {
            debugPayload.comparisonSkippedBySize = true;
          } else if (!hasFolderScope && typeof accessorCount === "number") {
            debugPayload.accessorCount = accessorCount;
            debugPayload.countDelta = typeof countDelta === "number" ? countDelta : 0;
          } else if (hasFolderScope) {
            debugPayload.comparisonSkippedByFolderScope = true;
          }
          selectionInfo = debugPayload;
          console.debug("[Omni-Forge][PR3][Selection->Preview]", debugPayload);
        }
        if (selectedFiles.length === 0) {
          this.notice("No target notes selected. Open selector first.");
          void this.openSelectionModal();
          return;
        }
        const source = new FolderReclassActiveFileSource();
        const candidates = source.getCandidates({ app: this.app, selectedFiles });
        const suggestions = recommendFolderReclass(candidates, ctx);
        const modalOpenGuard = { opened: false };
        const scopeRoots = selectionScope && selectionScope.scope && Array.isArray(selectionScope.scope.roots) ? selectionScope.scope.roots : [];
        const isUnderAnyRoot = (path, roots) => {
          if (roots.includes(".")) {
            return true;
          }
          for (const root of roots) {
            if (typeof root !== "string" || !root) {
              continue;
            }
            if (path === root || path.startsWith(`${root}/`)) {
              return true;
            }
          }
          return false;
        };
        const totalSuggestions = Array.isArray(suggestions) ? suggestions.length : 0;
        let inScopeCount = 0;
        let outOfScopeCount = 0;
        let unknownPathCount = 0;
        const outOfScopeSample = [];
        for (const suggestion of suggestions) {
          let path = null;
          if (suggestion && typeof suggestion.filePath === "string") {
            path = suggestion.filePath;
          } else if (suggestion && typeof suggestion.fromFilePath === "string") {
            path = suggestion.fromFilePath;
          } else if (suggestion && suggestion.candidate && typeof suggestion.candidate.filePath === "string") {
            path = suggestion.candidate.filePath;
          }
          if (typeof path !== "string") {
            unknownPathCount += 1;
            continue;
          }
          if (isUnderAnyRoot(path, scopeRoots)) {
            inScopeCount += 1;
          } else {
            outOfScopeCount += 1;
            if (outOfScopeSample.length < 5) {
              outOfScopeSample.push(path);
            }
          }
        }
        const shadowPayload = {
          scopeRootsCount: scopeRoots.length,
          scopeRootsTruncated: selectionScope.rootsTruncated === true,
          totalSuggestions,
          inScopeCount,
          outOfScopeCount,
          unknownPathCount
        };
        if (outOfScopeCount > 0 && outOfScopeCount <= 5) {
          shadowPayload.outOfScopeSample = outOfScopeSample;
        }
        const enforcementContract = {
          version: "v1",
          policy: {
            mode: "default-deny",
            behavior: "telemetry-only"
          },
          thresholds: {
            maxOutOfScopeBeforeBlock: 1
          },
          notes: "PR3 Step2 enforcement contract skeleton (preview telemetry only)."
        };
        const decision = evaluatePR3ScopeEnforcementDecision(
          enforcementContract,
          shadowPayload
        );
        shadowPayload.decision = decision;
        const snapshot = buildPR3EvaluationSnapshot({
          selectionInfo,
          scopeInfo: selectionScope,
          shadowPayload,
          decision
        });
        const policyDecision = buildPR3PolicyDecision({
          decision,
          snapshot
        });
        snapshot.policy = policyDecision;
        handlePR3ScopeEnforcementDecision(decision, { snapshot, app: this.app, modalOpenGuard });
        if (typeof console !== "undefined" && typeof console.debug === "function") {
          console.debug("[Omni-Forge][PR3][EvaluationSnapshot]", snapshot);
        }
        const model = createFolderReclassModel(suggestions);
        if (model.rows.length === 0) {
          this.notice("No reclassification candidates for selected scope.");
          return;
        }
        new FolderReclassPreviewModal(this.app, model.rows, this.settings).open();
      }
    });
    this.addCommand({
      id: "auto-tag-active-note",
      name: "Auto-tag active note (tags only)",
      callback: async () => {
        const active = this.app.workspace.getActiveFile();
        if (!(active instanceof import_obsidian4.TFile) || active.extension !== "md") {
          this.notice("No active markdown note.");
          return;
        }
        await this.runAutoTagForFile(active, "manual");
      }
    });
    this.addCommand({
      id: "clear-target-notes",
      name: "Clear selected target notes/folders",
      callback: async () => {
        await this.clearSelectionForQa(true);
      }
    });
    this.addCommand({
      id: "backup-selected-notes",
      name: "Backup selected notes",
      callback: async () => this.backupSelectedNotesNow()
    });
    this.addCommand({
      id: "restore-latest-backup",
      name: "Restore from latest backup",
      callback: async () => this.restoreFromLatestBackup()
    });
    this.addCommand({
      id: "cleanup-selected-frontmatter",
      name: "Cleanup frontmatter properties for selected notes",
      callback: async () => this.runPropertyCleanup(false)
    });
    this.addCommand({
      id: "cleanup-selected-frontmatter-dry-run",
      name: "Dry-run cleanup frontmatter properties for selected notes",
      callback: async () => this.runPropertyCleanup(true)
    });
    this.addCommand({
      id: "select-cleanup-keys-from-selected-notes",
      name: "Select cleanup keys from selected notes",
      callback: async () => this.openCleanupKeyPicker()
    });
    this.addCommand({
      id: "refresh-ollama-models",
      name: "Refresh Ollama model detection",
      callback: async () => {
        await this.refreshOllamaDetection({ notify: true, autoApply: true });
      }
    });
    this.addCommand({
      id: "refresh-embedding-models",
      name: "Refresh embedding model detection",
      callback: async () => {
        await this.refreshEmbeddingModelDetection({ notify: true, autoApply: true });
      }
    });
    this.addCommand({
      id: "generate-moc-now",
      name: "Generate MOC from selected notes",
      callback: async () => this.generateMocFromSelection()
    });
    this.addCommand({
      id: "ask-local-ai-from-selected-notes",
      name: "Ask local AI from selected notes",
      callback: async () => {
        this.markSelectedAskIntentForQa();
        await this.openLocalQaWorkspaceView();
      }
    });
    this.addSettingTab(new KnowledgeWeaverSettingTab(this.app, this));
  }
  onunload() {
    this.app.workspace.getLeavesOfType(LOCAL_QA_VIEW_TYPE).forEach((leaf) => leaf.detach());
    this.setStatus("idle");
  }
  getOllamaDetectionSummary() {
    return this.ollamaDetectionSummary;
  }
  getOllamaModelOptions() {
    return this.ollamaDetectionOptions;
  }
  getDetectedOllamaModelNames() {
    var _a;
    if (((_a = this.ollamaDetectionCache) == null ? void 0 : _a.models) && this.ollamaDetectionCache.models.length > 0) {
      return [...this.ollamaDetectionCache.models];
    }
    return this.ollamaDetectionOptions.map((option) => option.model);
  }
  hasDetectedOllamaModel(modelName) {
    const target = modelName.trim();
    if (!target) {
      return false;
    }
    return this.getDetectedOllamaModelNames().includes(target);
  }
  resolveDetectedRoleFallbackModel(role) {
    var _a, _b, _c, _d;
    const options = this.getRoleModelOptionsForQa(role);
    const recommended = (_b = (_a = options.find((option) => option.status === "recommended")) == null ? void 0 : _a.model) == null ? void 0 : _b.trim();
    if (recommended) {
      return recommended;
    }
    const available = (_d = (_c = options.find((option) => option.status !== "unavailable")) == null ? void 0 : _c.model) == null ? void 0 : _d.trim();
    return available || null;
  }
  getQaModelRecommendationForRole(roleHint) {
    const role = ROLE_MODEL_SETTING_CONFIGS.some((config) => config.role === roleHint) ? roleHint : this.resolveQaPrimaryRole();
    const fromRoleOptions = this.resolveDetectedRoleFallbackModel(role);
    if (fromRoleOptions) {
      return fromRoleOptions;
    }
    const qaModel = this.settings.qaOllamaModel.trim();
    if (qaModel && isOllamaModelAllowedForQaRole(role, qaModel)) {
      return qaModel;
    }
    const baseModel = this.settings.ollamaModel.trim();
    if (baseModel && isOllamaModelAllowedForQaRole(role, baseModel)) {
      return baseModel;
    }
    return "";
  }
  async applyRecommendedQaModelForRole(roleHint) {
    const role = ROLE_MODEL_SETTING_CONFIGS.some((config) => config.role === roleHint) ? roleHint : this.resolveQaPrimaryRole();
    if (this.getQaChatModelFamilyForQa() === "cloud") {
      return "Cloud profile is active. Local role-model recommendation is skipped.";
    }
    const recommended = this.getQaModelRecommendationForRole(role);
    if (!recommended) {
      return `No recommended local model was found for role '${role}'. Refresh local detection first.`;
    }
    const roleKey = this.getRoleModelSettingKey(role);
    if (roleKey) {
      this.writeRoleModelSetting(roleKey, recommended);
    }
    this.settings.qaOllamaModel = recommended;
    if (!this.settings.ollamaModel.trim()) {
      this.settings.ollamaModel = recommended;
    }
    await this.saveSettings();
    await this.refreshOpenQaWorkspaceViews();
    return `Applied local recommendation for role '${role}': ${recommended}`;
  }
  getRoleModelSettingKey(role) {
    var _a;
    const found = ROLE_MODEL_SETTING_CONFIGS.find((config) => config.role === role);
    return (_a = found == null ? void 0 : found.key) != null ? _a : null;
  }
  readRoleModelSetting(key) {
    return this.settings[key].trim();
  }
  writeRoleModelSetting(key, value) {
    this.settings[key] = value.trim();
  }
  isLegacyUniformRoleModelConfig() {
    const values = ROLE_MODEL_SETTING_CONFIGS.map((config) => this.readRoleModelSetting(config.key)).filter((value) => value.length > 0);
    if (values.length < 2) {
      return false;
    }
    const unique = [...new Set(values)];
    if (unique.length !== 1) {
      return false;
    }
    const uniform = unique[0];
    return uniform === this.settings.ollamaModel.trim() || uniform === this.settings.qaOllamaModel.trim();
  }
  getRoleModelOptionsForQa(role) {
    const models = this.getDetectedOllamaModelNames();
    if (models.length === 0) {
      return [];
    }
    return buildRoleSpecificOllamaModelOptions(role, models);
  }
  getRoleModelRecommendationSummaryForQa() {
    const parts = ROLE_MODEL_SETTING_CONFIGS.map((config) => {
      var _a, _b;
      const options = this.getRoleModelOptionsForQa(config.role);
      const recommended = (_b = (_a = options.find((option) => option.status === "recommended")) == null ? void 0 : _a.model) != null ? _b : "(none)";
      return `${config.name}: ${recommended}`;
    });
    return parts.join(" | ");
  }
  async applyRecommendedRoleModelsForQa(notify, forceApply) {
    var _a;
    const legacyUniform = this.isLegacyUniformRoleModelConfig();
    let changed = 0;
    for (const config of ROLE_MODEL_SETTING_CONFIGS) {
      const options = this.getRoleModelOptionsForQa(config.role);
      const recommended = (_a = options.find((option) => option.status === "recommended")) == null ? void 0 : _a.model;
      const current = this.readRoleModelSetting(config.key);
      if (!recommended) {
        if (current.length > 0 && !isOllamaModelAllowedForQaRole(config.role, current)) {
          this.writeRoleModelSetting(config.key, "");
          changed += 1;
        }
        continue;
      }
      const currentFound = current.length > 0 && options.some((option) => option.model === current);
      const currentUnavailable = current.length > 0 && !isOllamaModelAllowedForQaRole(config.role, current);
      const shouldApply = forceApply || legacyUniform || current.length === 0 || !currentFound || currentUnavailable;
      if (!shouldApply || current === recommended) {
        continue;
      }
      this.writeRoleModelSetting(config.key, recommended);
      changed += 1;
    }
    if (changed > 0) {
      await this.saveSettings();
    }
    if (notify) {
      if (changed > 0) {
        this.notice(`Applied role model recommendations to ${changed} field(s).`);
      } else {
        this.notice("No role model changes were needed.");
      }
    }
  }
  getEmbeddingDetectionSummary() {
    return this.embeddingDetectionSummary;
  }
  getEmbeddingModelOptions() {
    return this.embeddingDetectionOptions;
  }
  async openLocalQaWorkspaceView(openNewPane = false) {
    const isCloudFamily = this.getQaChatModelFamilyForQa() === "cloud";
    if (isCloudFamily && this.settings.oauthEnabled === true) {
      void this.tryAutoOAuthLoginForQa("openLocalQaWorkspaceView");
    }
    const existingLeaves = this.app.workspace.getLeavesOfType(LOCAL_QA_VIEW_TYPE);
    if (openNewPane) {
      if (existingLeaves.length >= LOCAL_QA_MAX_PANES) {
        this.notice(`최대 ${LOCAL_QA_MAX_PANES}개 채팅창까지 열 수 있습니다.`);
        if (existingLeaves[0]) {
          this.app.workspace.revealLeaf(existingLeaves[0]);
        }
        return false;
      }
      const splitLeaf = this.app.workspace.getRightLeaf(true);
      if (!splitLeaf) {
        this.notice("Could not open additional chat pane.");
        return false;
      }
      await splitLeaf.setViewState({
        type: LOCAL_QA_VIEW_TYPE,
        active: true
      });
      this.app.workspace.revealLeaf(splitLeaf);
      return true;
    }
    let leaf = existingLeaves[0];
    if (!leaf) {
      const rightLeaf = this.app.workspace.getRightLeaf(false);
      if (!rightLeaf) {
        this.notice("Could not open right-side chat pane.");
        return false;
      }
      leaf = rightLeaf;
      await leaf.setViewState({
        type: LOCAL_QA_VIEW_TYPE,
        active: true
      });
    }
    this.app.workspace.revealLeaf(leaf);
    return true;
  }
  async openAnalyzedTrack() {
    var _a;
    const selectedFiles = this.getSelectedFiles();
    const folderCounter = /* @__PURE__ */ new Map();
    for (const file of selectedFiles) {
      const folder = (0, import_obsidian4.normalizePath)(file.path.split("/").slice(0, -1).join("/")) || "(root)";
      folderCounter.set(folder, ((_a = folderCounter.get(folder)) != null ? _a : 0) + 1);
    }
    const topFolders = [...folderCounter.entries()].sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0])).slice(0, 4).map(([folder, count]) => `${folder}(${count})`);
    const sampleFiles = selectedFiles.slice(0, 4).map((file) => file.path);
    const cache = await this.loadAnalysisCache();
    const cacheEntries = Object.keys(cache.entries).length;
    await this.openSelectionModal({
      title: "Analyzed Track snapshot / \uBD84\uC11D \uBC94\uC704 \uC2A4\uB0C5\uC0F7",
      description: "Review analyzed scope first, then adjust file/folder selection.",
      modalWidth: "min(1180px, 95vw)",
      snapshotLines: [
        `Analyzed snapshot: files=${selectedFiles.length}, selectedFolders=${this.settings.targetFolderPaths.length}, cacheEntries=${cacheEntries}`,
        topFolders.length > 0 ? `Top folders: ${topFolders.join(", ")}` : "Top folders: (none)",
        sampleFiles.length > 0 ? `Sample files: ${sampleFiles.join(", ")}` : "Sample files: (none)"
      ]
    });
  }
  async refreshOpenQaWorkspaceViews() {
    const leaves = this.app.workspace.getLeavesOfType(LOCAL_QA_VIEW_TYPE);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view instanceof LocalQAWorkspaceView) {
        await view.refreshFromSettingsForQa();
      }
    }
  }
  getSelectedFilesForQa() {
    return this.getSelectedFiles();
  }
  getSelectedFolderPathsForQa() {
    return [...this.settings.targetFolderPaths];
  }
  getAnalyzedScopeSnapshotSummaryForQa() {
    const files = this.getSelectedFiles();
    const folderSet = /* @__PURE__ */ new Set();
    for (const file of files) {
      const folder = (0, import_obsidian4.normalizePath)(file.path.split("/").slice(0, -1).join("/")) || "(root)";
      folderSet.add(folder);
    }
    const folderCount = folderSet.size;
    const cacheCount = this.analysisCache ? Object.keys(this.analysisCache.entries).length : 0;
    return [
      `\uC120\uD0DD \uD30C\uC77C ${files.length}\uAC1C`,
      `\uC120\uD0DD \uD3F4\uB354 ${this.settings.targetFolderPaths.length}\uAC1C`,
      `\uD3EC\uD568 \uD3F4\uB354(\uD655\uC7A5) ${folderCount}\uAC1C`,
      `\uBD84\uC11D \uCE90\uC2DC \uC5D4\uD2B8\uB9AC ${cacheCount}\uAC1C`
    ].join(" | ");
  }
  getQaModelOverrideForQa() {
    return this.settings.qaOllamaModel.trim();
  }
  getQaRolePresetForQa() {
    return this.settings.qaRolePreset;
  }
  getQaPipelinePresetForQa() {
    return this.settings.qaPipelinePreset;
  }
  getQaPresetProfileForQa() {
    return this.settings.qaLocalPresetProfile;
  }
  getQaPresetProfileLabelForQa() {
    return getQaLocalPresetProfileLabel(this.settings.qaLocalPresetProfile);
  }
  getQaConversationModeForQa() {
    return this.settings.qaConversationMode;
  }
  getQaConversationModeLabelForQa() {
    return getQaConversationModeLabel(this.settings.qaConversationMode);
  }
  getQaConversationModeOptionsForQa() {
    return QA_CONVERSATION_MODE_OPTIONS;
  }
  getQaChatModelFamilyForQa() {
    return this.settings.qaChatModelFamily === "cloud" ? "cloud" : "local";
  }
  getQaChatModelProfileForQa() {
    return (this.settings.qaChatModelProfile || "").trim();
  }
  getQaChatModelFamilyOptionsForQa() {
    return [
      { value: "local", label: "Local" },
      { value: "cloud", label: "Cloud" }
    ];
  }
  getQaChatModelProfileOptionsForQa(family) {
    if (family === "cloud") {
      const codexModel = this.settings.openAIModel.trim() || DEFAULT_SETTINGS.openAIModel;
      const claudeModel = this.settings.anthropicModel.trim() || DEFAULT_SETTINGS.anthropicModel;
      const geminiModel = this.settings.geminiModel.trim() || DEFAULT_SETTINGS.geminiModel;
      return [
        { value: "codex", label: codexModel ? `Codex (${codexModel})` : "Codex" },
        { value: "claude", label: claudeModel ? `Claude (${claudeModel})` : "Claude" },
        { value: "gemini", label: geminiModel ? `Gemini (${geminiModel})` : "Gemini" }
      ];
    }
    return [
      { value: "local-flash", label: "Local Flash" },
      { value: "local-pro", label: "Local Pro" }
    ];
  }
  async setQaChatModelFamilyForQa(family) {
    const nextFamily = family === "cloud" ? "cloud" : "local";
    this.settings.qaChatModelFamily = nextFamily;
    const allowedProfiles = nextFamily === "cloud" ? /* @__PURE__ */ new Set(["codex", "claude", "gemini"]) : /* @__PURE__ */ new Set(["local-flash", "local-pro"]);
    const normalizedProfile = allowedProfiles.has(this.settings.qaChatModelProfile) ? this.settings.qaChatModelProfile : nextFamily === "cloud" ? "codex" : "local-flash";
    this.settings.qaChatModelProfile = normalizedProfile;
    return await this.applyQaChatModelProfileForQa(normalizedProfile, nextFamily);
  }
  appendQaAllowedOutboundHostFromUrl(rawUrl) {
    const value = (rawUrl || "").trim();
    if (!value) {
      return;
    }
    try {
      const parsed = new URL(value);
      const host = parsed.hostname.trim().toLowerCase();
      if (!host) {
        return;
      }
      const merged = new Set(this.parseQaAllowedOutboundHosts());
      merged.add(host);
      this.settings.qaAllowedOutboundHosts = [...merged].sort((a, b) => a.localeCompare(b)).join(", ");
    } catch (e) {
    }
  }
  normalizeOAuthProviderPresetForQa(rawValue) {
    const value = typeof rawValue === "string" ? rawValue.trim().toLowerCase() : "";
    if (value === "google" || value === "auth0" || value === "custom") {
      return value;
    }
    return "custom";
  }
  sanitizeOAuthDomainForQa(rawValue) {
    const value = typeof rawValue === "string" ? rawValue.trim() : "";
    if (!value) {
      return "";
    }
    const withoutScheme = value.replace(/^https?:\/\//i, "");
    const hostOnly = withoutScheme.split("/")[0] || "";
    return hostOnly.trim().replace(/\/+$/g, "");
  }
  resolveAuth0PresetUrlsForQa(rawDomain) {
    const domain = this.sanitizeOAuthDomainForQa(rawDomain);
    if (!domain) {
      return null;
    }
    return {
      authUrl: `https://${domain}/authorize`,
      tokenUrl: `https://${domain}/oauth/token`
    };
  }
  applyOAuthProviderPresetForQa(rawPreset) {
    const preset = this.normalizeOAuthProviderPresetForQa(rawPreset);
    this.settings.oauthProviderPreset = preset;
    if (preset === "google") {
      this.settings.oauthProvider = "google";
      this.settings.oauthAuthUrl = "https://accounts.google.com/o/oauth2/v2/auth";
      this.settings.oauthTokenUrl = "https://oauth2.googleapis.com/token";
      this.settings.oauthScopes = "openid profile email";
      return;
    }
    if (preset === "auth0") {
      this.settings.oauthProvider = "auth0";
      const auth0Urls = this.resolveAuth0PresetUrlsForQa(this.settings.oauthAuth0Domain);
      if (auth0Urls) {
        this.settings.oauthAuthUrl = auth0Urls.authUrl;
        this.settings.oauthTokenUrl = auth0Urls.tokenUrl;
      }
      return;
    }
    this.settings.oauthProvider = "generic";
  }
  applyGoogleOAuthQuickSetupForQa() {
    this.settings.provider = "openai";
    this.settings.qaChatModelFamily = "cloud";
    this.settings.qaChatModelProfile = "codex";
    this.settings.qaLocalPresetProfile = "custom";
    this.settings.qaAllowNonLocalEndpoint = true;
    this.settings.oauthEnabled = true;
    this.applyOAuthProviderPresetForQa("google");
    this.settings.oauthRedirectUri = this.normalizeOAuthRedirectUriForQa(this.settings.oauthRedirectUri);
    const bridgeBase = toOpenAICompatibleBase(this.settings.openAIBaseUrl.trim() || DEFAULT_SETTINGS.openAIBaseUrl);
    this.settings.qaOllamaBaseUrl = bridgeBase;
    this.settings.qaOllamaModel = this.settings.openAIModel.trim() || DEFAULT_SETTINGS.openAIModel;
    this.appendQaAllowedOutboundHostFromUrl(bridgeBase);
  }
  getOAuthRedirectValidationForQa() {
    const raw = typeof this.settings.oauthRedirectUri === "string" ? this.settings.oauthRedirectUri.trim() : "";
    const normalized = this.normalizeOAuthRedirectUriForQa(raw);
    let host = "";
    let path = "";
    let protocol = "";
    try {
      const parsed = new URL(normalized);
      host = parsed.hostname.toLowerCase();
      path = parsed.pathname || "";
      protocol = parsed.protocol || "";
    } catch (e) {
      host = "";
      path = "";
      protocol = "";
    }
    const hostOk = host === "127.0.0.1" || host === "localhost";
    const pathOk = path === "/callback";
    const protocolOk = protocol === "http:" || protocol === "https:";
    const exactMatch = raw === normalized;
    const ready = Boolean(raw) && exactMatch && hostOk && pathOk && protocolOk;
    const message = ready ? `redirect ready: ${normalized}` : `redirect needs fix: current='${raw || "(empty)"}' expected='${normalized}'`;
    const guidance = ready ? "Register exactly the same URI in provider console." : "Use localhost/127.0.0.1 callback URI and register the same value in provider console.";
    return {
      ready,
      message,
      guidance,
      raw,
      normalized,
      hostOk,
      pathOk,
      protocolOk,
      exactMatch
    };
  }
  getOAuthSetupChecklistForQa() {
    const preset = this.normalizeOAuthProviderPresetForQa(this.settings.oauthProviderPreset);
    const validation = this.getOAuthLoginValidationForQa();
    const redirect = this.getOAuthRedirectValidationForQa();
    const transport = this.getOAuthTransportValidationForQa();
    const tokenFresh = this.isOAuthTokenFreshForQa();
    const tokenPresent = typeof this.settings.oauthAccessToken === "string" && this.settings.oauthAccessToken.trim().length > 0;
    const lines = [
      `1) preset: ${preset === "google" ? "google (ok)" : `${preset} (switch to google for Google OAuth)`}`,
      `2) client ID: ${this.settings.oauthClientId.trim() ? "set" : "missing"}`,
      `3) redirect URI: ${redirect.ready ? "valid" : "invalid"}`,
      `4) start login: ${validation.ready ? "ready" : "blocked (fill required fields)"}`,
      `5) token status: ${tokenFresh ? "active" : tokenPresent ? "present but refresh/login needed" : "missing"}`,
      `transport: ${transport.ready ? "ok" : "needs action"}`
    ];
    return {
      ready: validation.ready && redirect.ready && transport.ready,
      lines,
      text: lines.join(" | ")
    };
  }
  applyRecommendedOAuthBridgeDefaultsForQa() {
    this.settings.oauthBridgeEnabled = true;
    if (!this.settings.oauthBridgeBaseUrl.trim()) {
      this.settings.oauthBridgeBaseUrl = "http://127.0.0.1:8787/v1";
    }
    const bridgeBase = resolveOAuthBridgeBaseUrl(this.settings);
    this.settings.qaOllamaBaseUrl = bridgeBase;
    this.appendQaAllowedOutboundHostFromUrl(bridgeBase);
  }
  getOAuthTransportValidationForQa() {
    const oauthEnabled = this.settings.oauthEnabled === true;
    if (!oauthEnabled) {
      return {
        ready: true,
        level: "ok",
        message: "OAuth transport inactive (OAuth disabled).",
        guidance: ""
      };
    }
    const oauthBridgeEnabled = this.settings.oauthBridgeEnabled === true;
    const activeBase = oauthBridgeEnabled ? resolveOAuthBridgeBaseUrl(this.settings) : toOpenAICompatibleBase(this.settings.openAIBaseUrl.trim() || DEFAULT_SETTINGS.openAIBaseUrl);
    let host = "";
    try {
      host = new URL(activeBase).hostname.toLowerCase();
    } catch (e) {
      host = "";
    }
    const preset = this.normalizeOAuthProviderPresetForQa(this.settings.oauthProviderPreset);
    const isOpenAiPublicHost = host === "api.openai.com" || host.endsWith(".openai.com");
    if (preset === "google" && !oauthBridgeEnabled && isOpenAiPublicHost) {
      return {
        ready: false,
        level: "warning",
        message: "OAuth endpoint mismatch detected: Google OAuth + direct api.openai.com.",
        guidance: "Enable OAuth bridge mode (recommended) or change OpenAI base URL to your OAuth-compatible OpenAI-style endpoint."
      };
    }
    if (oauthBridgeEnabled && !this.settings.oauthBridgeBaseUrl.trim()) {
      return {
        ready: true,
        level: "notice",
        message: "OAuth bridge mode is enabled with OpenAI base URL fallback.",
        guidance: "Set OAuth bridge base URL explicitly if your bridge host differs from OpenAI base URL."
      };
    }
    return {
      ready: true,
      level: "ok",
      message: `OAuth transport ready: ${oauthBridgeEnabled ? "bridge" : "direct"} (${host || "unknown-host"}).`,
      guidance: oauthBridgeEnabled ? "Cloud requests will use OAuth bridge endpoint." : "Cloud requests will use direct OpenAI-compatible endpoint."
    };
  }
  getOAuthValidationFieldMetaForQa() {
    return [
      { key: "oauthAuthUrl", label: "auth URL", settingLabel: "OAuth authorization URL" },
      { key: "oauthTokenUrl", label: "token URL", settingLabel: "OAuth token URL" },
      { key: "oauthClientId", label: "client ID", settingLabel: "OAuth client ID" },
      { key: "oauthRedirectUri", label: "redirect URI", settingLabel: "OAuth redirect URI" }
    ];
  }
  getOAuthMissingFieldHintForQa(fieldKey) {
    switch (fieldKey) {
      case "oauthClientId":
        return "Set OAuth client ID first. Use Google Cloud Console > Credentials > OAuth 2.0 Client IDs.";
      case "oauthRedirectUri":
        return "Use redirect URI http://127.0.0.1:8765/callback and register the same URI in provider console.";
      case "oauthAuthUrl":
        return "For Google preset, auth URL should be https://accounts.google.com/o/oauth2/v2/auth.";
      case "oauthTokenUrl":
        return "For Google preset, token URL should be https://oauth2.googleapis.com/token.";
      default:
        return "Fill required OAuth fields in Settings > Cloud provider config.";
    }
  }
  getOAuthLoginFailureHintForQa(rawMessage) {
    const normalized = typeof rawMessage === "string" ? rawMessage.toLowerCase() : "";
    if (!normalized) {
      return "";
    }
    if (normalized.includes("missing required fields")) {
      return "Complete all required OAuth fields in settings, then retry Start OAuth Login.";
    }
    if (normalized.includes("oauth endpoint mismatch detected") || normalized.includes("oauth transport mismatch")) {
      return "Enable OAuth bridge mode (recommended) or change OpenAI base URL to your OAuth-compatible OpenAI-style endpoint.";
    }
    if (normalized.includes("oauth client id is empty")) {
      return this.getOAuthMissingFieldHintForQa("oauthClientId");
    }
    if (normalized.includes("cloud chat completion failed: 401") || normalized.includes("cloud responses request failed: 401")) {
      const transport = this.getOAuthTransportValidationForQa();
      if (!transport.ready) {
        return transport.guidance || transport.message;
      }
      return "Cloud endpoint returned 401. Verify token audience/scope and endpoint compatibility.";
    }
    if (normalized.includes("oauth token exchange failed")) {
      return "Token exchange failed. Verify OAuth consent screen publish/test-user config, client ID, and redirect URI registration.";
    }
    if (normalized.includes("access blocked") || normalized.includes("app not verified") || normalized.includes("consent")) {
      return "OAuth consent screen issue detected. In Google Cloud Console, configure consent screen and add your account to Test users.";
    }
    if (normalized.includes("test user") || normalized.includes("not in the list of allowed users") || normalized.includes("not authorized to use this app")) {
      return "Current account is not allowed. Add this Google account to OAuth Test users or publish the app.";
    }
    if (normalized.includes("redirect_uri_mismatch") || normalized.includes("redirect uri mismatch")) {
      return "Register this redirect URI in provider console: http://127.0.0.1:8765/callback.";
    }
    if (normalized.includes("invalid_client") || normalized.includes("unauthorized_client")) {
      return "OAuth client is invalid. Verify client ID, app type, and enabled OAuth consent screen.";
    }
    if (normalized.includes("invalid_grant")) {
      return "Authorization code is expired/invalid. Restart OAuth login and finish consent quickly.";
    }
    if (normalized.includes("invalid_scope")) {
      return "Requested scopes were rejected. For Google start with: openid profile email.";
    }
    if (normalized.includes("access_denied")) {
      return "Authorization was denied or canceled in the provider consent screen.";
    }
    if (normalized.includes("state mismatch")) {
      return "OAuth state mismatch. Retry with a fresh browser tab and do not reuse old callback URLs.";
    }
    if (normalized.includes("callback listener failed") || normalized.includes("eaddrinuse")) {
      return "Local callback listener failed. Port 8765 may be in use by another app.";
    }
    if (normalized.includes("timed out")) {
      return "OAuth callback timed out. Complete provider consent in browser within 180 seconds.";
    }
    if (normalized.includes("failed to open the oauth authorization url")) {
      return "Browser launch failed. Copy/paste the authorization URL manually if needed.";
    }
    return "";
  }
  formatOAuthLoginFailureForQa(error) {
    const message = error instanceof Error ? error.message : "unknown error";
    const hint = this.getOAuthLoginFailureHintForQa(message);
    return hint ? `OAuth login failed: ${message} | Hint: ${hint}` : `OAuth login failed: ${message}`;
  }
  getOAuthAutoLoginCooldownMsForQa() {
    return 3e5;
  }
  isOAuthAutoLoginCoolingDownForQa(now = Date.now()) {
    return Number.isFinite(this.oauthAutoLoginCooldownUntil) && this.oauthAutoLoginCooldownUntil > now;
  }
  async tryAutoOAuthLoginForQa(reason = "runtime") {
    if (this.settings.oauthEnabled !== true) {
      return false;
    }
    if (this.isOAuthTokenFreshForQa()) {
      return false;
    }
    const now = Date.now();
    if (this.isOAuthAutoLoginCoolingDownForQa(now)) {
      return false;
    }
    const validation = this.getOAuthLoginValidationForQa();
    if (!validation.ready) {
      if (!this.oauthAutoLoginMissingConfigNotified) {
        new import_obsidian4.Notice(`${validation.message} (auto-login skipped)`, 8e3);
        this.oauthAutoLoginMissingConfigNotified = true;
      }
      this.oauthAutoLoginCooldownUntil = now + this.getOAuthAutoLoginCooldownMsForQa();
      return false;
    }
    this.oauthAutoLoginMissingConfigNotified = false;
    try {
      new import_obsidian4.Notice("OAuth 자동 로그인 시도중... / Opening browser...", 3500);
      await this.startOAuthLoginForQa();
      this.oauthAutoLoginCooldownUntil = 0;
      new import_obsidian4.Notice("OAuth 자동 로그인 완료 / OAuth auto-login completed", 4e3);
      return true;
    } catch (error) {
      const message = error instanceof Error ? error.message : "unknown error";
      this.oauthAutoLoginCooldownUntil = now + this.getOAuthAutoLoginCooldownMsForQa();
      new import_obsidian4.Notice(`OAuth 자동 로그인 실패(5분 후 재시도): ${message}`, 8e3);
      return false;
    }
  }
  getOAuthLoginValidationForQa() {
    const required = this.getOAuthValidationFieldMetaForQa();
    const missingEntries = required.filter((item) => {
      const value = this.settings[item.key];
      return typeof value !== "string" || !value.trim();
    });
    const missing = missingEntries.map((item) => item.label);
    const missingKeys = missingEntries.map((item) => item.key);
    if (missingEntries.length === 0) {
      return {
        ready: true,
        missing,
        missingKeys,
        focusField: "",
        message: "OAuth login is ready.",
        guidance: "All required fields are present."
      };
    }
    const focusField = missingKeys.includes("oauthClientId") ? "oauthClientId" : missingKeys[0] || "";
    const hint = this.getOAuthMissingFieldHintForQa(focusField);
    const detail = missingEntries.map((item) => `${item.label} -> ${item.settingLabel}`).join(" | ");
    return {
      ready: false,
      missing,
      missingKeys,
      focusField,
      message: `Missing required fields: ${missing.join(", ")}. ${hint}`,
      guidance: `Fill required settings: ${detail}`
    };
  }
  normalizeOAuthRedirectUriForQa(rawValue) {
    const fallback = DEFAULT_SETTINGS.oauthRedirectUri;
    const value = typeof rawValue === "string" && rawValue.trim() ? rawValue.trim() : fallback;
    try {
      const parsed = new URL(value);
      const host = parsed.hostname.toLowerCase();
      if (host !== "127.0.0.1" && host !== "localhost") {
        return fallback;
      }
      if (parsed.protocol !== "http:" && parsed.protocol !== "https:") {
        return fallback;
      }
      parsed.protocol = "http:";
      parsed.hostname = "127.0.0.1";
      parsed.port = "8765";
      if (!parsed.pathname || parsed.pathname === "/") {
        parsed.pathname = "/callback";
      }
      parsed.search = "";
      parsed.hash = "";
      return parsed.toString();
    } catch (e) {
      return fallback;
    }
  }
  parseOAuthScopesForQa() {
    const raw = typeof this.settings.oauthScopes === "string" ? this.settings.oauthScopes : "";
    return raw.split(/[\s,\n]+/).map((item) => item.trim()).filter((item) => item.length > 0).join(" ");
  }
  getOAuthTokenExpiryMsForQa() {
    const raw = Number(this.settings.oauthTokenExpiry);
    if (!Number.isFinite(raw) || raw <= 0) {
      return 0;
    }
    return Math.floor(raw);
  }
  isOAuthTokenFreshForQa(bufferMs = 6e4) {
    const token = typeof this.settings.oauthAccessToken === "string" ? this.settings.oauthAccessToken.trim() : "";
    if (!token) {
      return false;
    }
    const expiryMs = this.getOAuthTokenExpiryMsForQa();
    if (!expiryMs) {
      return true;
    }
    return Date.now() + Math.max(0, Math.floor(bufferMs)) < expiryMs;
  }
  getOAuthStatusSummaryForQa() {
    const enabled = this.settings.oauthEnabled === true;
    const validation = this.getOAuthLoginValidationForQa();
    const transport = this.getOAuthTransportValidationForQa();
    const accessTokenPresent = typeof this.settings.oauthAccessToken === "string" && this.settings.oauthAccessToken.trim().length > 0;
    const refreshTokenPresent = typeof this.settings.oauthRefreshToken === "string" && this.settings.oauthRefreshToken.trim().length > 0;
    const expiryMs = this.getOAuthTokenExpiryMsForQa();
    let expiryText = "not set";
    if (expiryMs > 0) {
      const iso = new Date(expiryMs).toISOString();
      const remainingMs = expiryMs - Date.now();
      if (remainingMs <= 0) {
        expiryText = `expired (${iso})`;
      } else {
        const remainingMin = Math.max(1, Math.ceil(remainingMs / 6e4));
        expiryText = `active, expires in ${remainingMin}m (${iso})`;
      }
    }
    const configState = validation.ready ? "ready" : `missing ${validation.missing.join(", ")}`;
    const reloginState = enabled ? tokenFreshStatusForSummary(accessTokenPresent, expiryMs) : "n/a";
    return [
      `OAuth: ${enabled ? "enabled" : "disabled"}`,
      `config: ${configState}`,
      `transport: ${transport.ready ? transport.message : `needs action (${transport.message})`}`,
      `access token: ${accessTokenPresent ? "present" : "missing"}`,
      `refresh token: ${refreshTokenPresent ? "present" : "missing"}`,
      `expiry: ${expiryText}`,
      `re-login: ${reloginState}`
    ].join(" | ");
  }
  async clearOAuthTokensForQa() {
    this.settings.oauthAccessToken = "";
    this.settings.oauthRefreshToken = "";
    this.settings.oauthTokenExpiry = 0;
    await this.saveSettings();
  }
  async exchangeOAuthCodeForTokenForQa(code, redirectUri, codeVerifier) {
    const tokenUrl = this.settings.oauthTokenUrl.trim();
    const clientId = this.settings.oauthClientId.trim();
    if (!tokenUrl) {
      throw new Error("OAuth token URL is empty.");
    }
    if (!clientId) {
      throw new Error("OAuth client ID is empty.");
    }
    const body = new URLSearchParams();
    body.set("grant_type", "authorization_code");
    body.set("code", code);
    body.set("redirect_uri", redirectUri);
    body.set("client_id", clientId);
    if (this.settings.oauthUsePkce !== false && codeVerifier) {
      body.set("code_verifier", codeVerifier);
    }
    const scopes = this.parseOAuthScopesForQa();
    if (scopes) {
      body.set("scope", scopes);
    }
    // TODO: Some providers require extra params (client_secret, audience, resource). Add per-provider fields once endpoint requirements are confirmed.
    const providerHint = typeof this.settings.oauthProvider === "string" ? this.settings.oauthProvider.trim().toLowerCase() : "";
    if (providerHint && providerHint !== "generic") {
      body.set("provider", providerHint);
    }
    const response = await (0, import_obsidian4.requestUrl)({
      url: tokenUrl,
      method: "POST",
      headers: {
        Accept: "application/json"
      },
      contentType: "application/x-www-form-urlencoded",
      body: body.toString(),
      throw: false
    });
    const payload = parseOAuthTokenPayload(response);
    if (response.status >= 300) {
      const detail = typeof payload.error_description === "string" ? payload.error_description : typeof payload.error === "string" ? payload.error : typeof response.text === "string" ? response.text.trim() : "";
      const base = `OAuth token exchange failed: ${response.status}${detail ? ` (${detail})` : ""}`;
      const hint = this.getOAuthLoginFailureHintForQa(detail || base);
      throw new Error(hint ? `${base} | ${hint}` : base);
    }
    const accessToken = typeof payload.access_token === "string" ? payload.access_token.trim() : "";
    if (!accessToken) {
      throw new Error("OAuth token response is missing access_token.");
    }
    this.settings.oauthAccessToken = accessToken;
    if (typeof payload.refresh_token === "string" && payload.refresh_token.trim()) {
      this.settings.oauthRefreshToken = payload.refresh_token.trim();
    }
    this.settings.oauthTokenExpiry = resolveOAuthTokenExpiryMs(payload);
    return accessToken;
  }
  async refreshOAuthAccessTokenForQa() {
    const tokenUrl = this.settings.oauthTokenUrl.trim();
    const clientId = this.settings.oauthClientId.trim();
    const refreshToken = this.settings.oauthRefreshToken.trim();
    if (!tokenUrl) {
      throw new Error("OAuth token URL is empty.");
    }
    if (!clientId) {
      throw new Error("OAuth client ID is empty.");
    }
    if (!refreshToken) {
      throw new Error("OAuth refresh token is missing.");
    }
    const body = new URLSearchParams();
    body.set("grant_type", "refresh_token");
    body.set("refresh_token", refreshToken);
    body.set("client_id", clientId);
    const scopes = this.parseOAuthScopesForQa();
    if (scopes) {
      body.set("scope", scopes);
    }
    // TODO: Some providers require extra params (client_secret, audience, resource). Add per-provider fields once endpoint requirements are confirmed.
    const providerHint = typeof this.settings.oauthProvider === "string" ? this.settings.oauthProvider.trim().toLowerCase() : "";
    if (providerHint && providerHint !== "generic") {
      body.set("provider", providerHint);
    }
    const response = await (0, import_obsidian4.requestUrl)({
      url: tokenUrl,
      method: "POST",
      headers: {
        Accept: "application/json"
      },
      contentType: "application/x-www-form-urlencoded",
      body: body.toString(),
      throw: false
    });
    const payload = parseOAuthTokenPayload(response);
    if (response.status >= 300) {
      const detail = typeof payload.error_description === "string" ? payload.error_description : typeof payload.error === "string" ? payload.error : typeof response.text === "string" ? response.text.trim() : "";
      const base = `OAuth token refresh failed: ${response.status}${detail ? ` (${detail})` : ""}`;
      const hint = this.getOAuthLoginFailureHintForQa(detail || base);
      throw new Error(hint ? `${base} | ${hint}` : base);
    }
    const accessToken = typeof payload.access_token === "string" ? payload.access_token.trim() : "";
    if (!accessToken) {
      throw new Error("OAuth refresh response is missing access_token.");
    }
    this.settings.oauthAccessToken = accessToken;
    if (typeof payload.refresh_token === "string" && payload.refresh_token.trim()) {
      this.settings.oauthRefreshToken = payload.refresh_token.trim();
    }
    this.settings.oauthTokenExpiry = resolveOAuthTokenExpiryMs(payload);
    await this.saveSettings();
    return accessToken;
  }
  async ensureOAuthAccessTokenForQa() {
    if (this.settings.oauthEnabled !== true) {
      return "";
    }
    if (this.isOAuthTokenFreshForQa()) {
      return this.settings.oauthAccessToken.trim();
    }
    if (this.settings.oauthRefreshToken.trim()) {
      return await this.refreshOAuthAccessTokenForQa();
    }
    if (this.settings.oauthAccessToken.trim() && this.getOAuthTokenExpiryMsForQa() === 0) {
      return this.settings.oauthAccessToken.trim();
    }
    throw new Error("OAuth access token is missing or expired. Run Start OAuth Login.");
  }
  async getOAuthAuthHeadersForQa() {
    if (this.settings.oauthEnabled !== true) {
      return {};
    }
    const token = await this.ensureOAuthAccessTokenForQa();
    if (!token) {
      return {};
    }
    return { Authorization: `Bearer ${token}` };
  }
  waitForOAuthCallbackForQa(redirectUri, expectedState, timeoutMs = 18e4) {
    let parsed;
    try {
      parsed = new URL(redirectUri);
    } catch (e) {
      return Promise.reject(new Error("OAuth redirect URI is invalid."));
    }
    const host = parsed.hostname;
    const port = parsed.port ? Number(parsed.port) : parsed.protocol === "https:" ? 443 : 80;
    const callbackPath = parsed.pathname || "/callback";
    return new Promise((resolve, reject) => {
      let settled = false;
      let timer = null;
      const server = nodeHttp.createServer((req, res) => {
        const requestUrl = new URL(req.url || "/", `${parsed.protocol}//${host}:${port}`);
        if (requestUrl.pathname !== callbackPath) {
          res.statusCode = 404;
          res.end("Not found.");
          return;
        }
        const state = requestUrl.searchParams.get("state") || "";
        const code = requestUrl.searchParams.get("code") || "";
        const oauthError = requestUrl.searchParams.get("error") || "";
        const oauthErrorDescription = requestUrl.searchParams.get("error_description") || "";
        if (!expectedState || state !== expectedState) {
          res.statusCode = 400;
          res.setHeader("Content-Type", "text/html; charset=utf-8");
          res.end("<html><body><h3>OAuth failed</h3><p>State mismatch.</p></body></html>");
          finalize(new Error("OAuth callback state mismatch."));
          return;
        }
        if (oauthError) {
          res.statusCode = 400;
          res.setHeader("Content-Type", "text/html; charset=utf-8");
          res.end("<html><body><h3>OAuth failed</h3><p>Authorization error returned by provider.</p></body></html>");
          const reason = oauthErrorDescription || oauthError;
          const hint = this.getOAuthLoginFailureHintForQa(reason);
          finalize(new Error(hint ? `OAuth authorization failed: ${reason} | ${hint}` : `OAuth authorization failed: ${reason}`));
          return;
        }
        if (!code) {
          res.statusCode = 400;
          res.setHeader("Content-Type", "text/html; charset=utf-8");
          res.end("<html><body><h3>OAuth failed</h3><p>Authorization code is missing.</p></body></html>");
          finalize(new Error("OAuth callback did not include a code."));
          return;
        }
        res.statusCode = 200;
        res.setHeader("Content-Type", "text/html; charset=utf-8");
        res.end("<html><body><h3>OAuth login complete</h3><p>You can close this tab and return to Obsidian.</p></body></html>");
        finalize(null, { code });
      });
      const finalize = (error, payload) => {
        if (settled) {
          return;
        }
        settled = true;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        try {
          server.close();
        } catch (e) {
        }
        if (error) {
          reject(error);
          return;
        }
        resolve(payload);
      };
      server.on("error", (error) => {
        const message = error instanceof Error ? error.message : "unknown error";
        finalize(new Error(`OAuth callback listener failed: ${message}`));
      });
      timer = setTimeout(() => {
        finalize(new Error("OAuth callback timed out after waiting 180 seconds."));
      }, Math.max(1e4, timeoutMs));
      server.listen(port, host);
    });
  }
  async startOAuthLoginForQa() {
    const validation = this.getOAuthLoginValidationForQa();
    if (!validation.ready) {
      throw new Error(validation.message);
    }
    const authUrl = this.settings.oauthAuthUrl.trim();
    const clientId = this.settings.oauthClientId.trim();
    this.settings.oauthEnabled = true;
    const redirectUri = this.normalizeOAuthRedirectUriForQa(this.settings.oauthRedirectUri);
    this.settings.oauthRedirectUri = redirectUri;
    const state = toBase64Url(nodeCrypto.randomBytes(24));
    let codeVerifier = "";
    let codeChallenge = "";
    if (this.settings.oauthUsePkce !== false) {
      codeVerifier = toBase64Url(nodeCrypto.randomBytes(64));
      codeChallenge = toBase64Url(nodeCrypto.createHash("sha256").update(codeVerifier).digest());
    }
    const authorizeUrl = new URL(authUrl);
    authorizeUrl.searchParams.set("response_type", "code");
    authorizeUrl.searchParams.set("client_id", clientId);
    authorizeUrl.searchParams.set("redirect_uri", redirectUri);
    authorizeUrl.searchParams.set("state", state);
    const scopes = this.parseOAuthScopesForQa();
    if (scopes) {
      authorizeUrl.searchParams.set("scope", scopes);
    }
    if (codeChallenge) {
      authorizeUrl.searchParams.set("code_challenge_method", "S256");
      authorizeUrl.searchParams.set("code_challenge", codeChallenge);
    }
    const opened = await this.openLinkWithDesktopShell(authorizeUrl.toString());
    if (!opened) {
      throw new Error("Failed to open the OAuth authorization URL.");
    }
    try {
      const callback = await this.waitForOAuthCallbackForQa(redirectUri, state);
      await this.exchangeOAuthCodeForTokenForQa(callback.code, redirectUri, codeVerifier);
      await this.saveSettings();
    } catch (error) {
      const message = error instanceof Error ? error.message : "unknown error";
      const hint = this.getOAuthLoginFailureHintForQa(message);
      throw new Error(hint ? `${message} | ${hint}` : message);
    }
  }
  async applyQaChatModelProfileForQa(profile, familyHint) {
    const family = familyHint === "cloud" ? "cloud" : this.getQaChatModelFamilyForQa();
    if (family === "local") {
      const normalized = profile === "local-pro" ? "local-pro" : "local-flash";
      const preset = normalized === "local-pro" ? "balanced_local" : "fast_local";
      const summary = await this.applyOneClickLocalPresetForQa(preset);
      this.settings.qaChatModelFamily = "local";
      this.settings.qaChatModelProfile = normalized;
      await this.saveSettings();
      await this.refreshOpenQaWorkspaceViews();
      return summary;
    }
    const normalized = profile === "claude" || profile === "gemini" ? profile : "codex";
    const bridgeBase = toOpenAICompatibleBase(this.settings.openAIBaseUrl.trim() || DEFAULT_SETTINGS.openAIBaseUrl);
    this.settings.qaChatModelFamily = "cloud";
    this.settings.qaChatModelProfile = normalized;
    this.settings.qaLocalPresetProfile = "custom";
    this.settings.qaAllowNonLocalEndpoint = true;
    this.settings.qaOllamaBaseUrl = bridgeBase;
    this.appendQaAllowedOutboundHostFromUrl(bridgeBase);
    if (normalized === "claude") {
      this.settings.provider = "anthropic";
      this.settings.qaOllamaModel = this.settings.anthropicModel.trim() || DEFAULT_SETTINGS.anthropicModel;
    } else if (normalized === "gemini") {
      this.settings.provider = "gemini";
      this.settings.qaOllamaModel = this.settings.geminiModel.trim() || DEFAULT_SETTINGS.geminiModel;
    } else {
      this.settings.provider = "openai";
      this.settings.qaOllamaModel = this.settings.openAIModel.trim() || DEFAULT_SETTINGS.openAIModel;
    }
    await this.saveSettings();
    await this.refreshOpenQaWorkspaceViews();
    return `Cloud profile applied: ${normalized}. Q&A base URL uses OpenAI-compatible bridge endpoint (${this.settings.qaOllamaBaseUrl}).`;
  }
  applyQaConversationModePreset(mode) {
    this.settings.qaConversationMode = mode;
    switch (mode) {
      case "ask":
        this.settings.qaRolePreset = "ask";
        this.settings.qaPipelinePreset = "legacy_auto";
        this.settings.qaAgentToolModeEnabled = false;
        this.settings.qaOrchestratorEnabled = false;
        this.settings.qaSafeguardPassEnabled = false;
        break;
      case "plan":
        this.settings.qaRolePreset = "orchestrator";
        this.settings.qaPipelinePreset = "orchestrator_safeguard";
        this.settings.qaAgentToolModeEnabled = false;
        this.settings.qaOrchestratorEnabled = true;
        this.settings.qaSafeguardPassEnabled = true;
        this.settings.qaAlwaysDetailedAnswer = true;
        this.settings.qaMinAnswerChars = Math.max(260, this.settings.qaMinAnswerChars);
        break;
      case "agent":
        this.settings.qaRolePreset = "coder";
        this.settings.qaPipelinePreset = "legacy_auto";
        this.settings.qaAgentToolModeEnabled = true;
        this.settings.qaAgentRequireApproval = false;
        this.settings.qaOrchestratorEnabled = false;
        this.settings.qaSafeguardPassEnabled = false;
        break;
      case "orchestration":
        this.settings.qaRolePreset = "orchestrator";
        this.settings.qaPipelinePreset = "orchestrator_auto_route";
        this.settings.qaAgentToolModeEnabled = false;
        this.settings.qaOrchestratorEnabled = true;
        this.settings.qaSafeguardPassEnabled = true;
        this.settings.qaAlwaysDetailedAnswer = true;
        this.settings.qaMinAnswerChars = Math.max(320, this.settings.qaMinAnswerChars);
        break;
      default:
        break;
    }
  }
  async setQaConversationModeForQa(mode) {
    this.applyQaConversationModePreset(mode);
    this.settings.qaLocalPresetProfile = "custom";
    await this.saveSettings();
    if (mode === "orchestration") {
      await this.refreshOllamaDetection({ notify: false, autoApply: true });
      await this.refreshEmbeddingModelDetection({ notify: false, autoApply: true });
      await this.applyRecommendedRoleModelsForQa(false, true);
      const defaultPipeline = this.getQaPipelinePresetOptionsForQa()[0];
      if (defaultPipeline && this.settings.qaPipelinePreset !== defaultPipeline.value) {
        this.settings.qaPipelinePreset = defaultPipeline.value;
        await this.saveSettings();
      }
    }
    await this.refreshOpenQaWorkspaceViews();
  }
  getQaRolePresetOptionsForQa() {
    return QA_ROLE_PRESET_OPTIONS;
  }
  getQaPipelinePresetOptionsForQa() {
    if (this.settings.qaConversationMode === "orchestration") {
      const defaultOption = QA_PIPELINE_PRESET_OPTIONS.find((option) => option.value === "orchestrator_auto_route");
      return defaultOption ? [defaultOption] : QA_PIPELINE_PRESET_OPTIONS;
    }
    return QA_PIPELINE_PRESET_OPTIONS;
  }
  getQaModelLabelForQa(role) {
    const resolvedRole = role != null ? role : this.resolveQaPrimaryRole();
    return this.resolveQaModelForRole(resolvedRole) || "(not set)";
  }
  getQaEmbeddingModelForQa() {
    return this.settings.semanticOllamaModel.trim();
  }
  getQaParserModeForQa() {
    return this.settings.qaParserMode === "detailed" ? "detailed" : "fast";
  }
  getParserModeProfileForQa() {
    const mode = this.getQaParserModeForQa();
    if (mode === "detailed") {
      return {
        mode,
        badge: "DETAILED",
        focus: "quality-first",
        summary: `Detailed mode prioritizes OCR quality (up to ${LOCAL_QA_PDF_OCR_MAX_PAGES_DETAILED} PDF pages, stronger OCR fallback, longer extraction budget).`,
        recommendation: "Use for handwriting, garbled text, or source-critical work where extraction quality matters more than speed."
      };
    }
    return {
      mode,
      badge: "FAST",
      focus: "speed-first",
      summary: `Fast mode prioritizes quick parsing (up to ${LOCAL_QA_PDF_OCR_MAX_PAGES_FAST} PDF pages, lightweight OCR chain, shorter extraction budget).`,
      recommendation: "Use for daily chat and quick scans. If quality is low, run OCR re-parse or switch to Detailed."
    };
  }
  getParserToolReadinessSummaryForQa() {
    return this.parserToolSummary;
  }
  getParserToolReadinessLinesForQa() {
    const tools = ["pdftotext", "pdftoppm", "tesseract", "soffice"];
    return tools.map((tool) => `${tool}: ${this.parserToolStatus[tool] ? "ready" : "missing"}`);
  }
  getParserSupportedFormatsForQa() {
    return ["PDF", "XLSX", "IMAGE(png/jpg/jpeg/webp)", "HWP(HWP->PDF auto PoC + fallback guide)", "HWPX(XML 1차 추출 + fallback guide)"];
  }
  getParserInboxFolderPathForQa() {
    return (0, import_obsidian4.normalizePath)((this.settings.qaParserInboxFolder || "inbox").trim() || "inbox");
  }
  getParserInboxLastEventForQa() {
    return { ...this.parserInboxLastEvent };
  }
  getParserInboxStatusForQa() {
    return { ...this.parserInboxMetrics };
  }
  formatParserEtaMsForQa(ms) {
    if (!Number.isFinite(ms) || ms <= 0) {
      return "-";
    }
    const sec = Math.max(1, Math.round(ms / 1e3));
    if (sec < 60) {
      return `${sec}s`;
    }
    const min = Math.floor(sec / 60);
    const rem = sec % 60;
    return `${min}m ${rem}s`;
  }
  async setParserInboxWatchEnabledForQa(enabled) {
    this.settings.qaParserInboxWatchEnabled = enabled;
    await this.saveSettings();
    await this.refreshOpenQaWorkspaceViews();
  }
  async openParserInboxFolderForQa() {
    const inbox = this.getParserInboxFolderPathForQa();
    await this.ensureFolderExists(inbox);
    const created = this.app.vault.getAbstractFileByPath(inbox);
    if (created) {
      const leaf = this.app.workspace.getLeavesOfType("file-explorer")[0];
      const view = leaf == null ? void 0 : leaf.view;
      if (view && typeof view.revealInFolder === "function") {
        try {
          view.revealInFolder(created);
        } catch (e) {
        }
      }
    }
    this.notice(`Parser inbox folder ready: ${inbox}`, 4e3);
    return inbox;
  }
  async scanParserInboxNowForQa(options) {
    const inbox = this.getParserInboxFolderPathForQa();
    await this.ensureFolderExists(inbox);
    const folder = this.app.vault.getAbstractFileByPath(inbox);
    if (!(folder instanceof import_obsidian4.TFolder)) {
      this.notice(`Parser inbox folder not found: ${inbox}`, 6e3);
      return { scanned: 0, matched: 0 };
    }
    const files = this.app.vault.getFiles().filter((file) => this.isPathInsideFolder(file.path, inbox));
    const targets = files.filter((file) => this.isParserInboxTargetFile(file));
    const forceOcr = Boolean(options == null ? void 0 : options.forceOcr);
    const parserMode = this.getQaParserModeForQa();
    this.emitParserDiagnostic({
      stage: "scan-start",
      result: "info",
      reasonCode: "scan",
      parserMode,
      forceOcr,
      targetCount: targets.length,
      toolStatus: {
        pdftotext: this.parserToolStatus.pdftotext === true,
        pdftoppm: this.parserToolStatus.pdftoppm === true,
        tesseract: this.parserToolStatus.tesseract === true,
        soffice: this.parserToolStatus.soffice === true
      }
    });
    this.updateParserInboxMetrics({
      stage: "scanning",
      queueLength: targets.length,
      total: targets.length,
      processed: 0,
      success: 0,
      skip: 0,
      error: 0,
      startedAt: Date.now(),
      lastFile: "(none)",
      lastResult: "idle"
    });
    let matched = 0;
    for (const file of targets) {
      matched += 1;
      await this.handleParserInboxFileCreate(file, { force: true, forceOcr });
    }
    this.updateParserInboxMetrics({
      stage: "done",
      queueLength: 0
    });
    this.emitParserDiagnostic({
      stage: "scan-done",
      result: "info",
      reasonCode: "scan_complete",
      parserMode,
      forceOcr,
      matched,
      success: this.parserInboxMetrics.success || 0,
      skip: this.parserInboxMetrics.skip || 0,
      error: this.parserInboxMetrics.error || 0
    });
    this.notice(`Parser inbox scan done: matched ${matched} file(s) in ${inbox} (mode=${parserMode})`, 6e3);
    return { scanned: files.length, matched };
  }
  setParserInboxLastEvent(event) {
    const fallback = {
      fileName: "(none)",
      result: "idle",
      message: "Parser inbox idle"
    };
    this.parserInboxLastEvent = {
      fileName: typeof (event == null ? void 0 : event.fileName) === "string" && event.fileName.trim() ? event.fileName : fallback.fileName,
      result: typeof (event == null ? void 0 : event.result) === "string" && event.result.trim() ? event.result : fallback.result,
      message: typeof (event == null ? void 0 : event.message) === "string" && event.message.trim() ? event.message : fallback.message
    };
    void this.refreshOpenQaWorkspaceViews();
  }
  updateParserInboxMetrics(patch) {
    const prev = this.parserInboxMetrics || {};
    const next = { ...prev, ...patch };
    const elapsedMs = next.startedAt > 0 ? Math.max(0, Date.now() - next.startedAt) : 0;
    next.elapsedMs = elapsedMs;
    const processed = Math.max(0, next.processed || 0);
    const total = Math.max(processed, next.total || 0);
    next.total = total;
    if (total > processed && processed > 0) {
      const avg = elapsedMs / processed;
      next.etaMs = Math.max(0, Math.round(avg * (total - processed)));
    } else {
      next.etaMs = 0;
    }
    this.parserInboxMetrics = next;
    void this.refreshOpenQaWorkspaceViews();
  }
  async isShellCommandAvailable(command) {
    const safe = command.trim();
    if (!/^[A-Za-z0-9._-]+$/.test(safe)) {
      return false;
    }
    const probe = process.platform === "win32" ? `where ${safe}` : `command -v ${safe}`;
    try {
      await execAsync(probe);
      return true;
    } catch (e) {
      return false;
    }
  }
  async refreshParserToolReadinessForQa(notify) {
    const pdftotext = await this.isShellCommandAvailable("pdftotext");
    const pdftoppm = await this.isShellCommandAvailable("pdftoppm");
    const tesseract = await this.isShellCommandAvailable("tesseract");
    const sofficeBin = await resolveSofficeExecutableForHwpPoC();
    const soffice = Boolean(sofficeBin);
    this.parserToolStatus = { pdftotext, pdftoppm, tesseract, soffice };
    const coreReady = pdftotext && pdftoppm && tesseract;
    const parserProfile = this.getParserModeProfileForQa();
    this.parserToolSummary = [
      `PDF text: ${pdftotext ? "ready" : "missing"}`,
      `PDF OCR render: ${pdftoppm ? "ready" : "missing"}`,
      `OCR engine: ${tesseract ? "ready" : "missing"}`,
      `HWP converter(soffice): ${soffice ? "ready" : "missing"}`,
      `Parser mode: ${parserProfile.badge} (${parserProfile.focus})`,
      coreReady ? "Detailed parser chain available." : "Fallback parser mode will be used for missing tools.",
      soffice ? "HWP auto-convert PoC route is available." : "HWP auto-convert PoC route will fallback to guide."
    ].join(" | ");
    if (notify) {
      this.notice(this.parserToolSummary, 7e3);
    }
    return this.parserToolSummary;
  }
  getQaRoleModelSummaryForQa() {
    const entries = [
      { role: "ask", short: "ask" },
      { role: "ask_vision", short: "vision" },
      { role: "image_generator", short: "image" },
      { role: "orchestrator", short: "orch" },
      { role: "architect", short: "arch" },
      { role: "coder", short: "coder" },
      { role: "debugger", short: "debug" },
      { role: "safeguard", short: "safe" }
    ];
    return entries.map((entry) => {
      const model = this.getQaModelLabelForQa(entry.role);
      const status = isOllamaModelAllowedForQaRole(entry.role, model) ? "" : "(\uBD88\uAC00)";
      return `${entry.short}=${model}${status}`;
    }).join(", ");
  }
  getQaLocalModelValidationForQa(roleHint) {
    const role = ROLE_MODEL_SETTING_CONFIGS.some((config) => config.role === roleHint) ? roleHint : this.resolveQaPrimaryRole();
    const family = this.getQaChatModelFamilyForQa();
    const selected = this.resolveQaModelForRole(role).trim();
    const detected = this.getDetectedOllamaModelNames();
    const recommended = this.getQaModelRecommendationForRole(role);
    if (family === "cloud") {
      return {
        status: "cloud",
        role,
        selected,
        recommended,
        detectedCount: detected.length,
        summary: `Cloud profile active. Local model check is informational only (role=${role}).`
      };
    }
    if (detected.length === 0) {
      return {
        status: "blocked",
        role,
        selected,
        recommended,
        detectedCount: 0,
        summary: "No local model detected. Install at least one local chat/instruct model and refresh detection."
      };
    }
    if (!selected) {
      return {
        status: "warn",
        role,
        selected,
        recommended,
        detectedCount: detected.length,
        summary: `Q&A model is empty for role '${role}'. Recommended: ${recommended || "(none)"}.`
      };
    }
    const suitable = isOllamaModelAllowedForQaRole(role, selected);
    if (!suitable) {
      return {
        status: "blocked",
        role,
        selected,
        recommended,
        detectedCount: detected.length,
        summary: `Selected model '${selected}' is not suitable for role '${role}'. Recommended: ${recommended || "(none)"}.`
      };
    }
    const detectedCurrent = this.hasDetectedOllamaModel(selected);
    if (!detectedCurrent) {
      return {
        status: "warn",
        role,
        selected,
        recommended,
        detectedCount: detected.length,
        summary: `Selected model '${selected}' is not in detected local inventory. Recommended: ${recommended || "(none)"}.`
      };
    }
    return {
      status: "ok",
      role,
      selected,
      recommended,
      detectedCount: detected.length,
      summary: `Selected model '${selected}' is detected and role-compatible.`
    };
  }
  getQaAgentModeSummaryForQa() {
    if (!this.settings.qaAgentToolModeEnabled) {
      return "off";
    }
    const parts = [
      this.settings.qaAgentRequireApproval ? "approval" : "auto",
      this.settings.qaAgentAllowShellTool ? "shell:on" : "shell:off",
      this.settings.qaAgentShellFullAccess ? "access:full" : "access:scoped"
    ];
    if (this.pendingQaActionPlan) {
      parts.push(`pending:${this.pendingQaActionPlan.actions.length}`);
    }
    return parts.join(",");
  }
  isQaContextEnabledForQa() {
    return this.settings.qaContextInChat;
  }
  markSelectedAskIntentForQa() {
    this.qaSelectedAskIntent = true;
  }
  consumeSelectedAskGuardForQa() {
    const active = this.qaSelectedAskIntent === true;
    this.qaSelectedAskIntent = false;
    return active && this.settings.qaRequireSelectionForSelectedAsk !== false;
  }
  async setQaContextEnabledForQa(enabled) {
    this.settings.qaContextInChat = enabled;
    await this.saveSettings();
    await this.refreshOpenQaWorkspaceViews();
  }
  isQaAgentToolModeEnabledForQa() {
    return this.settings.qaAgentToolModeEnabled;
  }
  async setQaAgentToolModeEnabledForQa(enabled) {
    this.settings.qaAgentToolModeEnabled = enabled;
    await this.saveSettings();
  }
  inferQaCloudProfileFromModelName(modelName) {
    const normalized = modelName.trim().toLowerCase();
    if (!normalized) {
      return null;
    }
    if (CLOUD_ANTHROPIC_MODEL_REGEX.test(normalized)) {
      return "claude";
    }
    if (CLOUD_GEMINI_MODEL_REGEX.test(normalized)) {
      return "gemini";
    }
    if (CLOUD_OPENAI_MODEL_REGEX.test(normalized)) {
      return "codex";
    }
    return null;
  }
  syncQaCloudFamilyFromModelHint(modelName) {
    const inferredProfile = this.inferQaCloudProfileFromModelName(modelName);
    if (!inferredProfile) {
      return false;
    }
    this.settings.qaChatModelFamily = "cloud";
    this.settings.qaChatModelProfile = inferredProfile;
    this.settings.qaAllowNonLocalEndpoint = true;
    this.settings.qaOllamaBaseUrl = toOpenAICompatibleBase(this.settings.openAIBaseUrl.trim() || DEFAULT_SETTINGS.openAIBaseUrl);
    this.appendQaAllowedOutboundHostFromUrl(this.settings.qaOllamaBaseUrl);
    if (inferredProfile === "claude") {
      this.settings.provider = "anthropic";
    } else if (inferredProfile === "gemini") {
      this.settings.provider = "gemini";
    } else {
      this.settings.provider = "openai";
    }
    return true;
  }
  getQaRoleSystemPromptForQa(role) {
    switch (role) {
      case "ask":
        return this.settings.qaAskSystemPrompt;
      case "ask_vision":
        return this.settings.qaAskVisionSystemPrompt;
      case "image_generator":
        return this.settings.qaImageGeneratorSystemPrompt;
      case "coder":
        return this.settings.qaCoderSystemPrompt;
      case "debugger":
        return this.settings.qaDebuggerSystemPrompt;
      case "architect":
        return this.settings.qaArchitectSystemPrompt;
      case "orchestrator":
        return this.settings.qaOrchestratorSystemPrompt;
      case "safeguard":
        return this.settings.qaSafeguardSystemPrompt;
      default:
        return "";
    }
  }
  getDefaultQaRoleSystemPromptForQa(role) {
    switch (role) {
      case "ask":
        return DEFAULT_SETTINGS.qaAskSystemPrompt;
      case "ask_vision":
        return DEFAULT_SETTINGS.qaAskVisionSystemPrompt;
      case "image_generator":
        return DEFAULT_SETTINGS.qaImageGeneratorSystemPrompt;
      case "coder":
        return DEFAULT_SETTINGS.qaCoderSystemPrompt;
      case "debugger":
        return DEFAULT_SETTINGS.qaDebuggerSystemPrompt;
      case "architect":
        return DEFAULT_SETTINGS.qaArchitectSystemPrompt;
      case "orchestrator":
        return DEFAULT_SETTINGS.qaOrchestratorSystemPrompt;
      case "safeguard":
        return DEFAULT_SETTINGS.qaSafeguardSystemPrompt;
      default:
        return "";
    }
  }
  async setQaRoleSystemPromptForQa(role, prompt) {
    const value = prompt.trim();
    switch (role) {
      case "ask":
        this.settings.qaAskSystemPrompt = value;
        break;
      case "ask_vision":
        this.settings.qaAskVisionSystemPrompt = value;
        break;
      case "image_generator":
        this.settings.qaImageGeneratorSystemPrompt = value;
        break;
      case "coder":
        this.settings.qaCoderSystemPrompt = value;
        break;
      case "debugger":
        this.settings.qaDebuggerSystemPrompt = value;
        break;
      case "architect":
        this.settings.qaArchitectSystemPrompt = value;
        break;
      case "orchestrator":
        this.settings.qaOrchestratorSystemPrompt = value;
        break;
      case "safeguard":
        this.settings.qaSafeguardSystemPrompt = value;
        break;
      default:
        break;
    }
    await this.saveSettings();
  }
  getQaModelOptionsForQa() {
    const models = this.ollamaDetectionOptions.map((option) => option.model).filter((model) => isOllamaModelAnalyzable(model));
    const deduped = [...new Set(models)];
    const current = this.settings.qaOllamaModel.trim();
    if (current && !deduped.includes(current)) {
      deduped.unshift(current);
    }
    return deduped;
  }
  async setQaModelOverrideForQa(modelOverride) {
    const normalized = modelOverride.trim();
    this.settings.qaOllamaModel = normalized;
    if (normalized) {
      this.syncQaCloudFamilyFromModelHint(normalized);
    }
    this.settings.qaLocalPresetProfile = "custom";
    await this.saveSettings();
    await this.refreshOpenQaWorkspaceViews();
  }
  async applyQaChatModelSelectionForQa(role, modelName) {
    const next = modelName.trim();
    this.settings.qaOllamaModel = next;
    if (next) {
      this.syncQaCloudFamilyFromModelHint(next);
    }
    this.settings.qaLocalPresetProfile = "custom";
    const roleKey = this.getRoleModelSettingKey(role);
    if (roleKey) {
      this.settings[roleKey] = next;
    }
    await this.saveSettings();
    await this.refreshOpenQaWorkspaceViews();
  }
  async setQaRolePresetForQa(rolePreset) {
    this.settings.qaRolePreset = rolePreset;
    this.settings.qaLocalPresetProfile = "custom";
    await this.saveSettings();
    await this.refreshOpenQaWorkspaceViews();
  }
  async setQaPipelinePresetForQa(pipelinePreset) {
    this.settings.qaPipelinePreset = pipelinePreset;
    this.settings.qaLocalPresetProfile = "custom";
    await this.saveSettings();
    await this.refreshOpenQaWorkspaceViews();
  }
  getPresetRank(preset) {
    switch (preset) {
      case "quality_local":
        return 3;
      case "balanced_local":
        return 2;
      case "fast_local":
      default:
        return 1;
    }
  }
  resolveHardwarePresetCeiling() {
    var _a, _b;
    const ramGiB = Number((nodeOs.totalmem() / 1024 ** 3).toFixed(1));
    const cpuThreads = (_b = (_a = nodeOs.cpus()) == null ? void 0 : _a.length) != null ? _b : 0;
    if (!Number.isFinite(ramGiB) || ramGiB <= 0) {
      return {
        ceiling: "balanced_local",
        ramGiB: 0,
        cpuThreads,
        reason: "RAM \uC815\uBCF4\uB97C \uC815\uD655\uD788 \uC77D\uC9C0 \uBABB\uD574 Pro\uAE4C\uC9C0 \uD5C8\uC6A9\uD569\uB2C8\uB2E4."
      };
    }
    if (ramGiB < 16 || cpuThreads < 6) {
      return {
        ceiling: "fast_local",
        ramGiB,
        cpuThreads,
        reason: "RAM<16GB \uB610\uB294 CPU \uC2A4\uB808\uB4DC<6 \uC774\uBBC0\uB85C Flash \uAD8C\uC7A5/\uC81C\uD55C\uC785\uB2C8\uB2E4."
      };
    }
    if (ramGiB < 32 || cpuThreads < 10) {
      return {
        ceiling: "balanced_local",
        ramGiB,
        cpuThreads,
        reason: "\uC911\uAC04\uAE09 \uC0AC\uC591\uC73C\uB85C Pro\uAE4C\uC9C0 \uC548\uC815\uC801\uC785\uB2C8\uB2E4."
      };
    }
    return {
      ceiling: "quality_local",
      ramGiB,
      cpuThreads,
      reason: "\uACE0\uC0AC\uC591\uC73C\uB85C Pro(\uD655\uC7A5) \uAD6C\uC131\uC774 \uAD8C\uC7A5\uB429\uB2C8\uB2E4."
    };
  }
  getHardwareCapabilitySummaryForQa() {
    const profile = this.resolveHardwarePresetCeiling();
    const ceilingLabel = profile.ceiling === "fast_local" ? "Flash" : "Pro";
    const ramText = profile.ramGiB > 0 ? `${profile.ramGiB}GB` : "unknown";
    return `Hardware: RAM=${ramText}, CPU threads=${profile.cpuThreads || "unknown"} | Max preset=${ceilingLabel}. ${profile.reason}`;
  }
  clampPresetByHardware(requested) {
    const profile = this.resolveHardwarePresetCeiling();
    if (this.getPresetRank(requested) <= this.getPresetRank(profile.ceiling)) {
      return {
        effective: requested,
        note: ""
      };
    }
    const requestedLabel = requested === "fast_local" ? "Flash" : "Pro";
    const effectiveLabel = profile.ceiling === "fast_local" ? "Flash" : "Pro";
    return {
      effective: profile.ceiling,
      note: `Requested ${requestedLabel}, but hardware limit applied: ${effectiveLabel}. ${profile.reason}`
    };
  }
  scoreModelForPreset(modelName, preset, requireVision) {
    const lower = modelName.toLowerCase();
    if (requireVision && !VISION_MODEL_REGEX.test(lower)) {
      return -1e3;
    }
    const sizeB = extractModelSizeBillions(lower);
    if (sizeB === null) {
      return requireVision ? 2 : 4;
    }
    if (preset === "fast_local") {
      if (sizeB <= 9) {
        return 120 - Math.abs(sizeB - 7) * 6;
      }
      return 40 - (sizeB - 9) * 8;
    }
    if (preset === "balanced_local") {
      if (sizeB >= 7 && sizeB <= 20) {
        return 130 - Math.abs(sizeB - 13) * 4;
      }
      if (sizeB < 7) {
        return 70 - (7 - sizeB) * 6;
      }
      return 65 - (sizeB - 20) * 5;
    }
    if (sizeB >= 20) {
      return 150 - Math.abs(sizeB - 32) * 2;
    }
    return 75 - (20 - sizeB) * 4;
  }
  pickPresetModelFromOptions(options, preset, requireVision = false) {
    var _a, _b;
    const candidates = options.filter((option) => option.status !== "unavailable").map((option) => ({
      model: option.model,
      score: this.scoreModelForPreset(option.model, preset, requireVision) + (option.status === "recommended" ? 8 : 0)
    })).filter((item) => item.score > -900).sort((a, b) => b.score - a.score || a.model.localeCompare(b.model));
    return (_b = (_a = candidates[0]) == null ? void 0 : _a.model) != null ? _b : null;
  }
  pickEmbeddingModelForPreset(preset) {
    var _a, _b;
    const options = this.getEmbeddingModelOptions().filter((option) => option.status !== "unavailable");
    const ranked = options.map((option) => {
      const lower = option.model.toLowerCase();
      const sizeB = extractModelSizeBillions(lower);
      const isSmallHint = /(small|mini|tiny|lite|all-minilm|e5-small|nomic-embed-text)/i.test(lower);
      const isLargeHint = /(large|xl|xxl|mxbai-embed-large|e5-large|bge-large)/i.test(lower);
      let score = option.status === "recommended" ? 10 : 0;
      if (preset === "fast_local") {
        score += isSmallHint ? 18 : 0;
        score -= isLargeHint ? 8 : 0;
        if (sizeB !== null) {
          score += Math.max(-12, 10 - sizeB * 2);
        }
      } else if (preset === "balanced_local") {
        score += isSmallHint ? 6 : 0;
        score += isLargeHint ? 5 : 0;
        score += /(nomic|bge|e5|mxbai|gte)/i.test(lower) ? 4 : 0;
        if (sizeB !== null) {
          score += Math.max(-8, 8 - Math.abs(sizeB - 7) * 1.2);
        }
      } else {
        score += isLargeHint ? 18 : 0;
        score -= isSmallHint ? 3 : 0;
        if (sizeB !== null) {
          score += sizeB * 1.8;
        }
      }
      return { model: option.model, score };
    }).sort((a, b) => b.score - a.score || a.model.localeCompare(b.model));
    return (_b = (_a = ranked[0]) == null ? void 0 : _a.model) != null ? _b : "";
  }
  getRecommendedPresetOverrideModelForQa(preset, kind) {
    var _a, _b, _c;
    if (kind === "embedding") {
      return this.pickEmbeddingModelForPreset(preset);
    }
    if (kind === "vision") {
      const askVisionOptions = this.getRoleModelOptionsForQa("ask_vision");
      return (_a = this.pickPresetModelFromOptions(askVisionOptions, preset, true)) != null ? _a : "";
    }
    const textOptions = this.getOllamaModelOptions();
    return (_b = this.pickPresetModelFromOptions(textOptions, preset, false)) != null ? _b : "";
  }
  applyPresetAwareRoleModels(preset) {
    const baseModel = this.pickPresetModelFromOptions(this.getOllamaModelOptions(), preset, false) || this.settings.ollamaModel.trim();
    if (baseModel) {
      this.settings.ollamaModel = baseModel;
      this.settings.qaOllamaModel = baseModel;
    }
    let roleAssignedCount = 0;
    let visionModel = "";
    for (const config of ROLE_MODEL_SETTING_CONFIGS) {
      const options = this.getRoleModelOptionsForQa(config.role);
      const selected = this.pickPresetModelFromOptions(
        options,
        preset,
        config.role === "ask_vision"
      );
      if (!selected) {
        continue;
      }
      this.writeRoleModelSetting(config.key, selected);
      roleAssignedCount += 1;
      if (config.role === "ask_vision") {
        visionModel = selected;
      }
    }
    if (!visionModel) {
      this.settings.qaAskVisionModel = "";
    }
    return {
      baseModel: this.settings.ollamaModel.trim(),
      visionModel,
      roleAssignedCount
    };
  }
  async applyOneClickLocalPresetForQa(preset) {
    var _a;
    const presetClamp = this.clampPresetByHardware(preset);
    const effectivePreset = presetClamp.effective;
    const previousProvider = this.settings.provider;
    this.settings.ollamaBaseUrl = this.settings.ollamaBaseUrl.trim() || DEFAULT_SETTINGS.ollamaBaseUrl;
    this.settings.qaOllamaBaseUrl = this.settings.ollamaBaseUrl;
    this.settings.semanticOllamaBaseUrl = this.settings.semanticOllamaBaseUrl.trim() || this.settings.ollamaBaseUrl;
    this.settings.qaAllowNonLocalEndpoint = false;
    this.settings.qaAgentRequireApproval = true;
    this.settings.qaAgentAllowShellTool = false;
    this.settings.qaAgentShellFullAccess = false;
    this.settings.qaPreferChatApi = true;
    this.settings.qaThreadAutoSyncEnabled = true;
    this.settings.qaRoleModelAutoPickEnabled = true;
    this.settings.semanticAutoPickEnabled = true;
    this.settings.qaLocalPresetProfile = effectivePreset;
    let summary = "";
    if (effectivePreset === "fast_local") {
      this.settings.suggestionMode = true;
      this.settings.includeReasons = false;
      this.settings.analysisOnlyChangedNotes = true;
      this.settings.semanticLinkingEnabled = false;
      this.settings.qaTopK = 3;
      this.settings.qaMaxContextChars = 8e3;
      this.settings.qaStructureGuardEnabled = false;
      this.settings.qaAlwaysDetailedAnswer = false;
      this.settings.qaMinAnswerChars = 180;
      this.settings.qaRolePreset = "ask";
      this.settings.qaPipelinePreset = "legacy_auto";
      this.settings.qaConversationMode = "ask";
      this.settings.qaOrchestratorEnabled = false;
      this.settings.qaSafeguardPassEnabled = false;
      this.settings.qaIncludeSelectionInventory = false;
      this.settings.qaSelectionInventoryMaxFiles = 100;
      summary = "Flash preset applied: speed-first local mode (lightweight pipeline, short context, concise responses).";
    } else if (effectivePreset === "quality_local") {
      this.settings.suggestionMode = true;
      this.settings.includeReasons = true;
      this.settings.analysisOnlyChangedNotes = false;
      this.settings.semanticLinkingEnabled = true;
      this.settings.semanticTopK = Math.max(this.settings.semanticTopK, 36);
      this.settings.semanticMinSimilarity = Math.min(this.settings.semanticMinSimilarity, 0.2);
      this.settings.qaTopK = 8;
      this.settings.qaMaxContextChars = Math.max(this.settings.qaMaxContextChars, 22e3);
      this.settings.qaStructureGuardEnabled = true;
      this.settings.qaAlwaysDetailedAnswer = true;
      this.settings.qaMinAnswerChars = Math.max(this.settings.qaMinAnswerChars, 650);
      this.settings.qaRolePreset = "orchestrator";
      this.settings.qaPipelinePreset = "orchestrator_architect_coder_safeguard";
      this.settings.qaConversationMode = "orchestration";
      this.settings.qaOrchestratorEnabled = true;
      this.settings.qaSafeguardPassEnabled = true;
      this.settings.qaIncludeSelectionInventory = true;
      this.settings.qaSelectionInventoryMaxFiles = Math.max(
        this.settings.qaSelectionInventoryMaxFiles,
        400
      );
      summary = "Legacy Quality+ preset applied: quality-first local mode (semantic on, deep pipeline, extended context).";
    } else {
      this.settings.suggestionMode = true;
      this.settings.includeReasons = true;
      this.settings.analysisOnlyChangedNotes = false;
      this.settings.semanticLinkingEnabled = true;
      this.settings.qaTopK = 5;
      this.settings.qaMaxContextChars = 12e3;
      this.settings.qaStructureGuardEnabled = true;
      this.settings.qaAlwaysDetailedAnswer = true;
      this.settings.qaMinAnswerChars = 320;
      this.settings.qaRolePreset = "ask";
      this.settings.qaPipelinePreset = "orchestrator_safeguard";
      this.settings.qaConversationMode = "plan";
      this.settings.qaOrchestratorEnabled = false;
      this.settings.qaSafeguardPassEnabled = true;
      this.settings.qaIncludeSelectionInventory = true;
      this.settings.qaSelectionInventoryMaxFiles = Math.max(
        this.settings.qaSelectionInventoryMaxFiles,
        200
      );
      summary = "Pro preset applied: balanced local mode (semantic on, moderate context, safe defaults).";
    }
    const detected = await this.refreshOllamaDetection({
      notify: false,
      autoApply: true
    });
    const detectedModels = (_a = detected == null ? void 0 : detected.models) != null ? _a : [];
    const hasDetectedLocalModels = detectedModels.length > 0;
    let detectionSummary = "";
    if (hasDetectedLocalModels) {
      this.settings.provider = "ollama";
      const embeddingDetected = await this.refreshEmbeddingModelDetection({
        notify: false,
        autoApply: true
      });
      const modelLayout = this.applyPresetAwareRoleModels(effectivePreset);
      const presetEmbeddingModel = this.getRecommendedPresetOverrideModelForQa(effectivePreset, "embedding");
      if (presetEmbeddingModel) {
        this.settings.semanticOllamaModel = presetEmbeddingModel;
      } else if (embeddingDetected == null ? void 0 : embeddingDetected.recommended) {
        this.settings.semanticOllamaModel = embeddingDetected.recommended;
      }
      const manualOverrides = [];
      if (effectivePreset === "balanced_local") {
        const baseOverride = this.settings.qaBalancedPresetBaseModel.trim();
        const visionOverride = this.settings.qaBalancedPresetVisionModel.trim();
        const embeddingOverride = this.settings.qaBalancedPresetEmbeddingModel.trim();
        if (baseOverride) {
          this.settings.ollamaModel = baseOverride;
          this.settings.qaOllamaModel = baseOverride;
          manualOverrides.push(`base=${baseOverride}`);
        }
        if (visionOverride) {
          this.settings.qaAskVisionModel = visionOverride;
          manualOverrides.push(`vision=${visionOverride}`);
        }
        if (embeddingOverride) {
          this.settings.semanticOllamaModel = embeddingOverride;
          manualOverrides.push(`embedding=${embeddingOverride}`);
        }
      } else if (effectivePreset === "quality_local") {
        const baseOverride = this.settings.qaQualityPresetBaseModel.trim();
        const visionOverride = this.settings.qaQualityPresetVisionModel.trim();
        const embeddingOverride = this.settings.qaQualityPresetEmbeddingModel.trim();
        if (baseOverride) {
          this.settings.ollamaModel = baseOverride;
          this.settings.qaOllamaModel = baseOverride;
          manualOverrides.push(`base=${baseOverride}`);
        }
        if (visionOverride) {
          this.settings.qaAskVisionModel = visionOverride;
          manualOverrides.push(`vision=${visionOverride}`);
        }
        if (embeddingOverride) {
          this.settings.semanticOllamaModel = embeddingOverride;
          manualOverrides.push(`embedding=${embeddingOverride}`);
        }
      }
      const visionModel = modelLayout.visionModel || this.resolveVisionModelForImageAttachments();
      detectionSummary = `Detected ${detectedModels.length} local model(s). Auto-assigned base model=${this.settings.ollamaModel || "(none)"}, embedding=${this.settings.semanticOllamaModel || "(none)"}, vision=${visionModel || "(not detected)"}, role fields=${modelLayout.roleAssignedCount}.` + (manualOverrides.length > 0 ? ` Manual preset overrides: ${manualOverrides.join(", ")}.` : "");
    } else {
      this.settings.provider = previousProvider;
      detectionSummary = "No local model was detected. Provider was kept as-is. Start Ollama and install text/vision/embedding models, then re-run preset.";
    }
    await this.saveSettings();
    await this.refreshOpenQaWorkspaceViews();
    const clampNote = presetClamp.note ? ` ${presetClamp.note}` : "";
    return `${summary} ${detectionSummary}${clampNote}`.trim();
  }
  buildQaQuickCustomProfileSnapshot(label) {
    return {
      version: 1,
      savedAt: (/* @__PURE__ */ new Date()).toISOString(),
      label: label.trim() || "Quick custom profile",
      settings: {
        qaLocalPresetProfile: this.settings.qaLocalPresetProfile,
        ollamaModel: this.settings.ollamaModel,
        qaOllamaModel: this.settings.qaOllamaModel,
        semanticOllamaModel: this.settings.semanticOllamaModel,
        qaAskModel: this.settings.qaAskModel,
        qaAskVisionModel: this.settings.qaAskVisionModel,
        qaImageGeneratorModel: this.settings.qaImageGeneratorModel,
        qaCoderModel: this.settings.qaCoderModel,
        qaDebuggerModel: this.settings.qaDebuggerModel,
        qaArchitectModel: this.settings.qaArchitectModel,
        qaOrchestratorModel: this.settings.qaOrchestratorModel,
        qaSafeguardModel: this.settings.qaSafeguardModel,
        qaTopK: this.settings.qaTopK,
        qaMaxContextChars: this.settings.qaMaxContextChars,
        qaRolePreset: this.settings.qaRolePreset,
        qaPipelinePreset: this.settings.qaPipelinePreset,
        qaStructureGuardEnabled: this.settings.qaStructureGuardEnabled,
        qaAlwaysDetailedAnswer: this.settings.qaAlwaysDetailedAnswer,
        qaMinAnswerChars: this.settings.qaMinAnswerChars,
        qaRoleModelAutoPickEnabled: this.settings.qaRoleModelAutoPickEnabled,
        semanticAutoPickEnabled: this.settings.semanticAutoPickEnabled,
        qaBalancedPresetBaseModel: this.settings.qaBalancedPresetBaseModel,
        qaBalancedPresetVisionModel: this.settings.qaBalancedPresetVisionModel,
        qaBalancedPresetEmbeddingModel: this.settings.qaBalancedPresetEmbeddingModel,
        qaQualityPresetBaseModel: this.settings.qaQualityPresetBaseModel,
        qaQualityPresetVisionModel: this.settings.qaQualityPresetVisionModel,
        qaQualityPresetEmbeddingModel: this.settings.qaQualityPresetEmbeddingModel,
        qaAttachmentIngestRootPath: this.settings.qaAttachmentIngestRootPath
      }
    };
  }
  parseQaQuickCustomProfileSlot(raw) {
    const trimmed = raw.trim();
    if (!trimmed) {
      return null;
    }
    try {
      const parsed = JSON.parse(trimmed);
      if (!parsed || typeof parsed !== "object" || !parsed.settings) {
        return null;
      }
      if (typeof parsed.savedAt !== "string") {
        return null;
      }
      return parsed;
    } catch (e) {
      return null;
    }
  }
  getQaQuickCustomProfileSlotSummary(slotKey) {
    const parsed = this.parseQaQuickCustomProfileSlot(this.settings[slotKey]);
    if (!parsed) {
      return "\uC800\uC7A5\uB41C \uD504\uB85C\uD544 \uC5C6\uC74C";
    }
    const stamp = parsed.savedAt.replace("T", " ").replace("Z", " UTC");
    return `${parsed.label || "Custom"} \xB7 ${stamp}`;
  }
  async saveQaQuickCustomProfileSlot(slotKey, label) {
    const snapshot = this.buildQaQuickCustomProfileSnapshot(label);
    this.settings[slotKey] = JSON.stringify(snapshot);
    await this.saveSettings();
    return `${snapshot.label} \uC800\uC7A5 \uC644\uB8CC (${snapshot.savedAt})`;
  }
  async applyQaQuickCustomProfileSlot(slotKey) {
    var _a, _b, _c, _d, _e, _f, _g;
    const parsed = this.parseQaQuickCustomProfileSlot(this.settings[slotKey]);
    if (!parsed) {
      throw new Error("\uC800\uC7A5\uB41C \uCEE4\uC2A4\uD140 \uD504\uB85C\uD544\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
    }
    const next = parsed.settings;
    const roleValid = QA_ROLE_PRESET_OPTIONS.some((option) => option.value === next.qaRolePreset);
    const pipelineValid = QA_PIPELINE_PRESET_OPTIONS.some(
      (option) => option.value === next.qaPipelinePreset
    );
    this.settings.qaLocalPresetProfile = next.qaLocalPresetProfile;
    this.settings.ollamaModel = next.ollamaModel;
    this.settings.qaOllamaModel = next.qaOllamaModel;
    this.settings.semanticOllamaModel = next.semanticOllamaModel;
    this.settings.qaAskModel = next.qaAskModel;
    this.settings.qaAskVisionModel = next.qaAskVisionModel;
    this.settings.qaImageGeneratorModel = next.qaImageGeneratorModel;
    this.settings.qaCoderModel = next.qaCoderModel;
    this.settings.qaDebuggerModel = next.qaDebuggerModel || "";
    this.settings.qaArchitectModel = next.qaArchitectModel;
    this.settings.qaOrchestratorModel = next.qaOrchestratorModel;
    this.settings.qaSafeguardModel = next.qaSafeguardModel;
    this.settings.qaTopK = Math.max(1, Math.min(15, Math.floor(next.qaTopK || this.settings.qaTopK)));
    this.settings.qaMaxContextChars = Math.max(
      1200,
      Math.min(5e4, Math.floor(next.qaMaxContextChars || this.settings.qaMaxContextChars))
    );
    if (roleValid) {
      this.settings.qaRolePreset = next.qaRolePreset;
    }
    if (pipelineValid) {
      this.settings.qaPipelinePreset = next.qaPipelinePreset;
    }
    this.settings.qaStructureGuardEnabled = Boolean(next.qaStructureGuardEnabled);
    this.settings.qaAlwaysDetailedAnswer = Boolean(next.qaAlwaysDetailedAnswer);
    this.settings.qaMinAnswerChars = Math.max(
      60,
      Math.min(3e3, Math.floor(next.qaMinAnswerChars || this.settings.qaMinAnswerChars))
    );
    this.settings.qaRoleModelAutoPickEnabled = Boolean(next.qaRoleModelAutoPickEnabled);
    this.settings.semanticAutoPickEnabled = Boolean(next.semanticAutoPickEnabled);
    this.settings.qaBalancedPresetBaseModel = (_a = next.qaBalancedPresetBaseModel) != null ? _a : "";
    this.settings.qaBalancedPresetVisionModel = (_b = next.qaBalancedPresetVisionModel) != null ? _b : "";
    this.settings.qaBalancedPresetEmbeddingModel = (_c = next.qaBalancedPresetEmbeddingModel) != null ? _c : "";
    this.settings.qaQualityPresetBaseModel = (_d = next.qaQualityPresetBaseModel) != null ? _d : "";
    this.settings.qaQualityPresetVisionModel = (_e = next.qaQualityPresetVisionModel) != null ? _e : "";
    this.settings.qaQualityPresetEmbeddingModel = (_f = next.qaQualityPresetEmbeddingModel) != null ? _f : "";
    this.settings.qaAttachmentIngestRootPath = (0, import_obsidian4.normalizePath)(
      ((_g = next.qaAttachmentIngestRootPath) != null ? _g : "").trim() || this.settings.qaAttachmentIngestRootPath || DEFAULT_SETTINGS.qaAttachmentIngestRootPath
    );
    await this.saveSettings();
    await this.refreshOpenQaWorkspaceViews();
    return `${parsed.label || "Custom"} \uD504\uB85C\uD544\uC744 \uC801\uC6A9\uD588\uC2B5\uB2C8\uB2E4.`;
  }
  async applyRecommendedQuickSetupForQa() {
    const presetSummary = await this.applyOneClickLocalPresetForQa("balanced_local");
    await this.refreshOllamaDetection({ notify: false, autoApply: true });
    await this.refreshEmbeddingModelDetection({ notify: false, autoApply: true });
    await this.applyRecommendedRoleModelsForQa(false, true);
    this.settings.qaLocalPresetProfile = "balanced_local";
    await this.saveSettings();
    await this.refreshOpenQaWorkspaceViews();
    return `\uCD94\uCC9C \uC138\uD305 \uC801\uC6A9 \uC644\uB8CC: ${presetSummary}`;
  }
  async openSelectionForQa() {
    await this.openSelectionModal();
    await this.refreshOpenQaWorkspaceViews();
  }
  async clearSelectionForQa(notify) {
    this.settings.targetFilePaths = [];
    this.settings.targetFolderPaths = [];
    await this.saveSettings();
    await this.refreshOpenQaWorkspaceViews();
    if (notify) {
      this.notice("Target file/folder selection cleared.");
    }
  }
  async openCleanupKeyPickerForQa() {
    await this.openCleanupKeyPicker();
  }
  async runCleanupForQa(dryRun) {
    await this.runPropertyCleanup(dryRun);
  }
  getAgentShellFolderOptionsForQa() {
    const out = /* @__PURE__ */ new Set(["."]);
    const all = this.app.vault.getAllLoadedFiles();
    for (const entry of all) {
      if (!(entry instanceof import_obsidian4.TFolder)) {
        continue;
      }
      const normalized = (0, import_obsidian4.normalizePath)(entry.path.trim());
      if (!normalized || normalized === ".") {
        continue;
      }
      out.add(normalized);
    }
    return [...out].sort((a, b) => {
      const depthDiff = a.split("/").length - b.split("/").length;
      if (depthDiff !== 0) {
        return depthDiff;
      }
      return a.localeCompare(b);
    });
  }
  async scanSkillsFolderForQa(rootPath) {
    const target = (rootPath || "").trim();
    if (!target) {
      return { rootPath: "", skills: [], error: "Skills folder path is empty." };
    }
    try {
      const normalizedRoot = nodePath.resolve(target);
      const entries = await nodeFs.promises.readdir(normalizedRoot, { withFileTypes: true });
      const skills = [];
      for (const entry of entries) {
        if (!entry.isDirectory()) {
          continue;
        }
        const skillDir = nodePath.join(normalizedRoot, entry.name);
        const skillDocPath = nodePath.join(skillDir, "SKILL.md");
        try {
          const stat = await nodeFs.promises.stat(skillDocPath);
          if (!stat.isFile()) {
            continue;
          }
          const raw = await nodeFs.promises.readFile(skillDocPath, "utf8");
          const firstHeading = raw.split(/\r?\n/).find((line) => /^#\s+/.test(line.trim()));
          const summaryLine = raw.split(/\r?\n/).find(
            (line) => line.trim().length > 0 && !line.trim().startsWith("#")
          );
          skills.push({
            id: entry.name,
            folder: skillDir,
            docPath: skillDocPath,
            title: firstHeading ? firstHeading.replace(/^#\s+/, "").trim() : entry.name,
            summary: (summaryLine || "").trim()
          });
        } catch (e) {
        }
      }
      skills.sort((a, b) => a.id.localeCompare(b.id));
      return { rootPath: normalizedRoot, skills };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown skills scan error";
      return { rootPath: target, skills: [], error: message };
    }
  }
  getChatTranscriptRootPathForQa() {
    return this.settings.chatTranscriptRootPath.trim();
  }
  isQaThreadAutoSyncEnabledForQa() {
    return this.settings.qaThreadAutoSyncEnabled;
  }
  isSafeVaultRelativePath(path) {
    const normalized = (0, import_obsidian4.normalizePath)(path.trim());
    if (!normalized) {
      return false;
    }
    if (normalized.startsWith("/") || /^[A-Za-z]:/.test(normalized)) {
      return false;
    }
    const segments = normalized.split("/");
    if (segments.some((segment) => segment === "..")) {
      return false;
    }
    return true;
  }
  resolveSafeFolderPath(rawPath, fallback, label) {
    const normalized = (0, import_obsidian4.normalizePath)(rawPath.trim() || fallback);
    if (!this.isSafeVaultRelativePath(normalized)) {
      throw new Error(`${label} path must be a safe vault-relative folder path.`);
    }
    return normalized;
  }
  sanitizeVaultFolderPathForQa(rawPath, fallback, label) {
    return this.resolveSafeFolderPath(rawPath, fallback, label);
  }
  async setChatTranscriptRootPathForQa(path) {
    const next = this.resolveSafeFolderPath(path, "Omni Forge Chats", "Chat transcript");
    this.settings.chatTranscriptRootPath = next;
    await this.saveSettings();
    await this.refreshOpenQaWorkspaceViews();
  }
  async setBackupRootPathForQa(path) {
    const next = this.resolveSafeFolderPath(path, "Omni Forge Backups", "Backup root");
    this.settings.backupRootPath = next;
    await this.saveSettings();
  }
  async setMocPathForQa(path) {
    const raw = path.trim() || "MOC/Selected Knowledge MOC.md";
    const next = this.resolveSafeMarkdownPath(raw, "MOC");
    this.settings.mocPath = next;
    await this.saveSettings();
  }
  escapeYamlValue(value) {
    return value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
  }
  collectTopSourcePaths(messages, maxItems) {
    const bestByPath = /* @__PURE__ */ new Map();
    for (const message of messages) {
      if (message.role !== "assistant" || !message.sources) {
        continue;
      }
      for (const source of message.sources) {
        const prev = bestByPath.get(source.path);
        if (prev === void 0 || source.similarity > prev) {
          bestByPath.set(source.path, source.similarity);
        }
      }
    }
    return [...bestByPath.entries()].sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0])).slice(0, Math.max(1, maxItems)).map(([path]) => path);
  }
  normalizeThreadId(rawThreadId, fallbackDate) {
    const fallback = `chat-${formatBackupStamp(fallbackDate)}`;
    const trimmed = (rawThreadId != null ? rawThreadId : "").trim();
    if (!trimmed) {
      return fallback;
    }
    const normalized = trimmed.replace(/[^a-zA-Z0-9_-]+/g, "-").replace(/-+/g, "-").replace(/^[-_]+|[-_]+$/g, "");
    return normalized || fallback;
  }
  resolveSafeMarkdownPath(rawPath, label) {
    const normalized = (0, import_obsidian4.normalizePath)(rawPath.trim());
    if (!this.isSafeVaultRelativePath(normalized)) {
      throw new Error(`${label} path must be a safe vault-relative markdown path.`);
    }
    if (!normalized.toLowerCase().endsWith(".md")) {
      throw new Error(`${label} path must end with .md`);
    }
    return normalized;
  }
  async allocateTimestampedMocPath(basePath) {
    const safeBasePath = this.resolveSafeMarkdownPath(basePath, "MOC");
    const baseWithoutExt = safeBasePath.replace(/\.md$/i, "");
    const stamp = formatBackupStamp(/* @__PURE__ */ new Date());
    let outputPath = (0, import_obsidian4.normalizePath)(`${baseWithoutExt}-${stamp}.md`);
    let suffix = 1;
    while (await this.app.vault.adapter.exists(outputPath)) {
      outputPath = (0, import_obsidian4.normalizePath)(`${baseWithoutExt}-${stamp}-${suffix}.md`);
      suffix += 1;
    }
    return outputPath;
  }
  async allocateLocalQaThreadPath(threadId) {
    const folder = this.resolveSafeFolderPath(
      this.settings.chatTranscriptRootPath,
      "Omni Forge Chats",
      "Chat transcript"
    );
    let outputPath = (0, import_obsidian4.normalizePath)(`${folder}/${threadId}.md`);
    let suffix = 1;
    while (await this.app.vault.adapter.exists(outputPath)) {
      outputPath = (0, import_obsidian4.normalizePath)(`${folder}/${threadId}-${suffix}.md`);
      suffix += 1;
    }
    return outputPath;
  }
  buildLocalQaTranscriptMarkdown(params) {
    const { messages, threadId, createdAt, updatedAt } = params;
    const exportMessages = this.settings.qaShowSystemMessages ? messages : messages.filter((message) => message.role !== "system");
    const qaModel = this.getQaModelLabelForQa();
    const embeddingModel = this.getQaEmbeddingModelForQa();
    const selectedFiles = this.getSelectedFilesForQa().map((file) => file.path);
    const selectedFolders = this.getSelectedFolderPathsForQa().sort(
      (a, b) => a.localeCompare(b)
    );
    const topSourcePaths = this.collectTopSourcePaths(
      exportMessages,
      Math.max(1, this.settings.qaTopK)
    );
    const turns = exportMessages.filter(
      (item) => item.role === "user" || item.role === "assistant"
    );
    const lines = [];
    lines.push("---");
    lines.push('type: "omni-forge-chat"');
    lines.push(`thread_id: "${this.escapeYamlValue(threadId)}"`);
    lines.push(`created: "${createdAt}"`);
    lines.push(`updated: "${updatedAt}"`);
    lines.push(`provider: "${this.escapeYamlValue(this.settings.provider)}"`);
    lines.push(`qa_model: "${this.escapeYamlValue(qaModel)}"`);
    lines.push(`embedding_model: "${this.escapeYamlValue(embeddingModel || "(not set)")}"`);
    lines.push(`turn_count: ${turns.length}`);
    lines.push(`scope_total_files: ${selectedFiles.length}`);
    lines.push(`scope_total_folders: ${selectedFolders.length}`);
    lines.push("scope_files:");
    if (topSourcePaths.length === 0) {
      lines.push('  - "(none)"');
    } else {
      for (const path of topSourcePaths) {
        lines.push(`  - "${this.escapeYamlValue(path)}"`);
      }
    }
    lines.push("---");
    lines.push("");
    lines.push("# Local AI Chat Transcript");
    lines.push("");
    for (const message of exportMessages) {
      if (message.role === "system") {
        lines.push(`> [!note]- System (${message.timestamp})`);
        for (const line of message.text.split(/\r?\n/)) {
          lines.push(`> ${line}`);
        }
        lines.push("");
        continue;
      }
      if (message.role === "thinking") {
        lines.push(`> [!abstract]- Thinking (${message.timestamp})`);
        for (const line of message.text.split(/\r?\n/)) {
          lines.push(`> ${line}`);
        }
        lines.push("");
        continue;
      }
      const label = message.role === "assistant" ? "Assistant" : "User";
      lines.push(`## ${label} (${message.timestamp})`);
      lines.push(message.text);
      if (message.role === "assistant" && message.sources && message.sources.length > 0) {
        lines.push("");
        lines.push("Sources:");
        for (const source of message.sources) {
          lines.push(`- [[${source.path}]] (${formatSimilarity(source.similarity)})`);
        }
      }
      lines.push("");
    }
    return `${lines.join("\n").trim()}
`;
  }
  async syncLocalQaTranscript(input) {
    const now = /* @__PURE__ */ new Date();
    const updatedAt = now.toISOString();
    const createdDate = input.createdAt ? new Date(input.createdAt) : now;
    const createdAt = Number.isNaN(createdDate.getTime()) ? updatedAt : createdDate.toISOString();
    const threadId = this.normalizeThreadId(input.threadId, new Date(createdAt));
    const outputPath = input.threadPath ? this.resolveSafeMarkdownPath(input.threadPath, "Chat thread") : await this.allocateLocalQaThreadPath(threadId);
    const markdown = this.buildLocalQaTranscriptMarkdown({
      messages: input.messages,
      threadId,
      createdAt,
      updatedAt
    });
    await this.ensureParentFolder(outputPath);
    await this.app.vault.adapter.write(outputPath, markdown);
    return {
      path: outputPath,
      threadId,
      createdAt,
      updatedAt
    };
  }
  async saveLocalQaTranscript(messages) {
    const now = /* @__PURE__ */ new Date();
    const synced = await this.syncLocalQaTranscript({
      messages,
      threadId: `chat-${formatBackupStamp(now)}`,
      createdAt: now.toISOString()
    });
    return synced.path;
  }
  async applyRecommendedOllamaModel(notify) {
    var _a;
    if (!((_a = this.ollamaDetectionCache) == null ? void 0 : _a.recommended)) {
      if (notify) {
        this.notice("No recommended Ollama model found. Refresh detection first.");
      }
      return;
    }
    this.settings.ollamaModel = this.ollamaDetectionCache.recommended;
    await this.saveSettings();
    if (notify) {
      this.notice(`Ollama model set to recommended: ${this.settings.ollamaModel}`);
    }
  }
  async applyRecommendedEmbeddingModel(notify) {
    var _a;
    if (!((_a = this.embeddingDetectionCache) == null ? void 0 : _a.recommended)) {
      if (notify) {
        this.notice("No recommended embedding model found. Refresh detection first.");
      }
      return;
    }
    this.settings.semanticOllamaModel = this.embeddingDetectionCache.recommended;
    await this.saveSettings();
    if (notify) {
      this.notice(
        `Embedding model set to recommended: ${this.settings.semanticOllamaModel}`
      );
    }
  }
  async refreshOllamaDetection(options) {
    try {
      const detected = await detectOllamaModels(this.settings.ollamaBaseUrl);
      this.ollamaDetectionCache = detected;
      this.ollamaDetectionOptions = buildOllamaModelOptions(
        detected.models,
        detected.recommended
      );
      const modelListPreview = detected.models.length > 0 ? detected.models.slice(0, 5).join(", ") : "(none)";
      this.ollamaDetectionSummary = [
        `Detected: ${detected.models.length} model(s).`,
        `Current: ${this.settings.ollamaModel || "(not set)"}.`,
        `Recommended: ${detected.recommended || "(none)"}.`,
        `Reason: ${detected.reason}`,
        `Preview: ${modelListPreview}`
      ].join(" ");
      if (options.autoApply && detected.recommended) {
        const current = this.settings.ollamaModel.trim();
        if (current !== detected.recommended) {
          this.settings.ollamaModel = detected.recommended;
          this.settings.qaOllamaModel = detected.recommended;
          await this.saveSettings();
          if (options.notify) {
            this.notice(
              `Auto-selected Ollama model: ${detected.recommended} (${detected.reason})`
            );
          }
        }
      }
      if (options.autoApply && this.settings.qaRoleModelAutoPickEnabled) {
        await this.applyRecommendedRoleModelsForQa(false, false);
      }
      if (options.notify) {
        this.notice(this.ollamaDetectionSummary, 5e3);
      }
      return detected;
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown Ollama detection error";
      this.ollamaDetectionCache = null;
      this.ollamaDetectionOptions = [];
      this.ollamaDetectionSummary = `Detection failed: ${message}`;
      if (options.notify) {
        this.notice(`Ollama model detection failed: ${message}`);
      }
      return null;
    }
  }
  async refreshEmbeddingModelDetection(options) {
    const baseUrl = this.settings.semanticOllamaBaseUrl.trim() || this.settings.ollamaBaseUrl.trim();
    if (!baseUrl) {
      this.embeddingDetectionSummary = "Embedding detection skipped: base URL is empty.";
      if (options.notify) {
        this.notice(this.embeddingDetectionSummary);
      }
      return null;
    }
    try {
      const detected = await detectOllamaEmbeddingModels(baseUrl);
      this.embeddingDetectionCache = detected;
      this.embeddingDetectionOptions = buildOllamaEmbeddingModelOptions(
        detected.models,
        detected.recommended
      );
      const modelListPreview = detected.models.length > 0 ? detected.models.slice(0, 5).join(", ") : "(none)";
      this.embeddingDetectionSummary = [
        `Detected: ${detected.models.length} model(s).`,
        `Current: ${this.settings.semanticOllamaModel || "(not set)"}.`,
        `Recommended: ${detected.recommended || "(none)"}.`,
        `Reason: ${detected.reason}`,
        `Preview: ${modelListPreview}`
      ].join(" ");
      if (options.autoApply && detected.recommended) {
        const current = this.settings.semanticOllamaModel.trim();
        if (current !== detected.recommended) {
          this.settings.semanticOllamaModel = detected.recommended;
          await this.saveSettings();
          if (options.notify) {
            this.notice(
              `Auto-selected embedding model: ${detected.recommended} (${detected.reason})`
            );
          }
        }
      }
      if (options.notify) {
        this.notice(this.embeddingDetectionSummary, 5e3);
      }
      return detected;
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown embedding detection error";
      this.embeddingDetectionCache = null;
      this.embeddingDetectionOptions = [];
      this.embeddingDetectionSummary = `Embedding detection failed: ${message}`;
      if (options.notify) {
        this.notice(`Embedding model detection failed: ${message}`);
      }
      return null;
    }
  }
  async loadSettings() {
    const rawData = await this.loadData();
    const rawSettings = rawData && typeof rawData === "object" ? rawData : {};
    const hasRawKey = (key) => Object.prototype.hasOwnProperty.call(rawSettings, key);
    const readLegacySetting = (keys) => {
      for (const key of keys) {
        if (hasRawKey(key)) {
          return rawSettings[key];
        }
      }
      return void 0;
    };
    this.settings = Object.assign({}, DEFAULT_SETTINGS, rawSettings);
    if (!hasRawKey("analyzeLinkedScopeMode")) {
      const legacyAnalyzeLinkedScopeMode = readLegacySetting([
        "analyzeLinkedScope",
        "linkedScopeMode",
        "linkedAnalyzeScopeMode"
      ]);
      if (legacyAnalyzeLinkedScopeMode !== void 0) {
        this.settings.analyzeLinkedScopeMode = legacyAnalyzeLinkedScopeMode;
      }
    }
    if (!hasRawKey("relatedScopeMaxCandidates")) {
      const legacyRelatedScopeMaxCandidates = readLegacySetting([
        "linkedScopeMaxCandidates",
        "analyzeLinkedMaxCandidates",
        "linkedRelatedMaxCandidates"
      ]);
      if (legacyRelatedScopeMaxCandidates !== void 0) {
        this.settings.relatedScopeMaxCandidates = legacyRelatedScopeMaxCandidates;
      }
    }
    if (!hasRawKey("relatedScopeTimeBudgetMs")) {
      const legacyRelatedScopeTimeBudgetMs = readLegacySetting([
        "linkedScopeTimeBudgetMs",
        "analyzeLinkedTimeBudgetMs",
        "linkedRelatedTimeBudgetMs"
      ]);
      if (legacyRelatedScopeTimeBudgetMs !== void 0) {
        this.settings.relatedScopeTimeBudgetMs = legacyRelatedScopeTimeBudgetMs;
      }
    }
    if (!hasRawKey("autoCreateTargetFolders")) {
      const legacyAutoCreateTargetFolders = readLegacySetting([
        "folderReclassAutoCreateTargetFolders",
        "folderMoveAutoCreateTargetFolders",
        "autoCreateFoldersOnMove"
      ]);
      if (legacyAutoCreateTargetFolders !== void 0) {
        this.settings.autoCreateTargetFolders = legacyAutoCreateTargetFolders;
      }
    }
    if (!hasRawKey("applyMode")) {
      const legacyApplyMode = readLegacySetting([
        "folderReclassApplyMode",
        "folderMoveApplyMode",
        "folderMoveMode"
      ]);
      if (legacyApplyMode !== void 0) {
        this.settings.applyMode = legacyApplyMode;
      }
    }
    if (!hasRawKey("moveConflictPolicy")) {
      const legacyMoveConflictPolicy = readLegacySetting([
        "folderReclassMoveConflictPolicy",
        "folderMoveConflictPolicy",
        "folderConflictPolicy"
      ]);
      if (legacyMoveConflictPolicy !== void 0) {
        this.settings.moveConflictPolicy = legacyMoveConflictPolicy;
      }
    }
    if (this.settings.settingsViewMode !== "simple" && this.settings.settingsViewMode !== "full") {
      this.settings.settingsViewMode = DEFAULT_SETTINGS.settingsViewMode;
    }
    this.settings.settingsViewMode = "full";
    if (this.settings.settingsUiLanguage !== "ko" && this.settings.settingsUiLanguage !== "en" && this.settings.settingsUiLanguage !== "bilingual") {
      this.settings.settingsUiLanguage = DEFAULT_SETTINGS.settingsUiLanguage;
    }
    if (this.settings.settingsActiveTab !== "quick" && this.settings.settingsActiveTab !== "analyzed" && this.settings.settingsActiveTab !== "chat" && this.settings.settingsActiveTab !== "orchestration" && this.settings.settingsActiveTab !== "skills" && this.settings.settingsActiveTab !== "parser" && this.settings.settingsActiveTab !== "guide") {
      this.settings.settingsActiveTab = DEFAULT_SETTINGS.settingsActiveTab;
    }
    if (this.settings.settingsActiveTab === "models") {
      this.settings.settingsActiveTab = "chat";
    }
    if (this.settings.settingsActiveTab === "workflow") {
      this.settings.settingsActiveTab = "analyzed";
    }
    if (this.settings.settingsActiveTab === "advanced") {
      this.settings.settingsActiveTab = "guide";
    }
    if (this.settings.settingsActiveTab === "parser") {
      this.settings.settingsActiveTab = "chat";
    }
    if (!Array.isArray(this.settings.targetFilePaths)) {
      this.settings.targetFilePaths = [];
    }
    if (!Array.isArray(this.settings.targetFolderPaths)) {
      this.settings.targetFolderPaths = [];
    }
    if (!Number.isFinite(this.settings.selectionPathWidthPercent)) {
      this.settings.selectionPathWidthPercent = DEFAULT_SETTINGS.selectionPathWidthPercent;
    }
    if (!this.settings.backupRootPath) {
      this.settings.backupRootPath = DEFAULT_SETTINGS.backupRootPath;
    }
    try {
      this.settings.backupRootPath = this.resolveSafeFolderPath(
        this.settings.backupRootPath,
        DEFAULT_SETTINGS.backupRootPath,
        "Backup root"
      );
    } catch (e) {
      this.settings.backupRootPath = DEFAULT_SETTINGS.backupRootPath;
    }
    if (!this.settings.excludedFolderPatterns) {
      this.settings.excludedFolderPatterns = DEFAULT_SETTINGS.excludedFolderPatterns;
    }
    if (!Number.isFinite(this.settings.backupRetentionCount)) {
      this.settings.backupRetentionCount = DEFAULT_SETTINGS.backupRetentionCount;
    }
    if (!Number.isFinite(this.settings.semanticTopK)) {
      this.settings.semanticTopK = DEFAULT_SETTINGS.semanticTopK;
    }
    if (!Number.isFinite(this.settings.semanticMinSimilarity)) {
      this.settings.semanticMinSimilarity = DEFAULT_SETTINGS.semanticMinSimilarity;
    }
    if (!Number.isFinite(this.settings.semanticMaxChars)) {
      this.settings.semanticMaxChars = DEFAULT_SETTINGS.semanticMaxChars;
    }
    if (typeof this.settings.analysisOnlyChangedNotes !== "boolean") {
      this.settings.analysisOnlyChangedNotes = DEFAULT_SETTINGS.analysisOnlyChangedNotes;
    }
    if (typeof this.settings.forceAllToAllLinkedEnabled !== "boolean") {
      this.settings.forceAllToAllLinkedEnabled = DEFAULT_SETTINGS.forceAllToAllLinkedEnabled;
    }
    if (this.settings.analyzeLinkedScopeMode !== "selected_only" && this.settings.analyzeLinkedScopeMode !== "selected_plus_related" && this.settings.analyzeLinkedScopeMode !== "vault_sampled") {
      this.settings.analyzeLinkedScopeMode = DEFAULT_SETTINGS.analyzeLinkedScopeMode;
    }
    if (!Number.isFinite(this.settings.relatedScopeMaxCandidates)) {
      this.settings.relatedScopeMaxCandidates = DEFAULT_SETTINGS.relatedScopeMaxCandidates;
    }
    this.settings.relatedScopeMaxCandidates = Math.max(
      16,
      Math.min(
        LINKED_SCOPE_MAX_CANDIDATES_HARD,
        Math.floor(this.settings.relatedScopeMaxCandidates)
      )
    );
    if (!Number.isFinite(this.settings.relatedScopeTimeBudgetMs)) {
      this.settings.relatedScopeTimeBudgetMs = DEFAULT_SETTINGS.relatedScopeTimeBudgetMs;
    }
    this.settings.relatedScopeTimeBudgetMs = Math.max(
      50,
      Math.min(
        LINKED_SCOPE_TIME_BUDGET_MS_HARD,
        Math.floor(this.settings.relatedScopeTimeBudgetMs)
      )
    );
    if (typeof this.settings.autoCreateTargetFolders !== "boolean") {
      this.settings.autoCreateTargetFolders = DEFAULT_SETTINGS.autoCreateTargetFolders;
    }
    if (this.settings.applyMode !== "metadata_only" && this.settings.applyMode !== "move_only" && this.settings.applyMode !== "metadata_and_move") {
      this.settings.applyMode = DEFAULT_SETTINGS.applyMode;
    }
    if (this.settings.moveConflictPolicy !== "suffix" && this.settings.moveConflictPolicy !== "skip") {
      this.settings.moveConflictPolicy = DEFAULT_SETTINGS.moveConflictPolicy;
    }
    if (!Number.isFinite(this.settings.qaTopK)) {
      this.settings.qaTopK = DEFAULT_SETTINGS.qaTopK;
    }
    if (!Number.isFinite(this.settings.qaMaxContextChars)) {
      this.settings.qaMaxContextChars = DEFAULT_SETTINGS.qaMaxContextChars;
    }
    if (!this.settings.semanticOllamaBaseUrl) {
      this.settings.semanticOllamaBaseUrl = DEFAULT_SETTINGS.semanticOllamaBaseUrl;
    }
    if (!this.settings.semanticOllamaModel) {
      this.settings.semanticOllamaModel = DEFAULT_SETTINGS.semanticOllamaModel;
    }
    if (typeof this.settings.qaOllamaBaseUrl !== "string") {
      this.settings.qaOllamaBaseUrl = DEFAULT_SETTINGS.qaOllamaBaseUrl;
    }
    if (typeof this.settings.qaOllamaModel !== "string") {
      this.settings.qaOllamaModel = DEFAULT_SETTINGS.qaOllamaModel;
    }
    if (this.settings.qaChatModelFamily !== "local" && this.settings.qaChatModelFamily !== "cloud") {
      this.settings.qaChatModelFamily = DEFAULT_SETTINGS.qaChatModelFamily;
    }
    if (typeof this.settings.qaChatModelProfile !== "string") {
      this.settings.qaChatModelProfile = DEFAULT_SETTINGS.qaChatModelProfile;
    }
    const localProfiles = /* @__PURE__ */ new Set(["local-flash", "local-pro"]);
    const cloudProfiles = /* @__PURE__ */ new Set(["codex", "claude", "gemini"]);
    const allowedProfiles = this.settings.qaChatModelFamily === "cloud" ? cloudProfiles : localProfiles;
    if (!allowedProfiles.has(this.settings.qaChatModelProfile)) {
      this.settings.qaChatModelProfile = this.settings.qaChatModelFamily === "cloud" ? "codex" : "local-flash";
    }
    if (!Number.isFinite(this.settings.qaChatFontSize)) {
      this.settings.qaChatFontSize = DEFAULT_SETTINGS.qaChatFontSize;
    }
    this.settings.qaChatFontSize = Math.max(
      11,
      Math.min(22, Math.floor(this.settings.qaChatFontSize))
    );
    if (typeof this.settings.qaShowSystemMessages !== "boolean") {
      this.settings.qaShowSystemMessages = DEFAULT_SETTINGS.qaShowSystemMessages;
    }
    if (typeof this.settings.semanticAutoPickEnabled !== "boolean") {
      this.settings.semanticAutoPickEnabled = DEFAULT_SETTINGS.semanticAutoPickEnabled;
    }
    if (typeof this.settings.qaAllowNonLocalEndpoint !== "boolean") {
      this.settings.qaAllowNonLocalEndpoint = DEFAULT_SETTINGS.qaAllowNonLocalEndpoint;
    }
    if (typeof this.settings.oauthBridgeEnabled !== "boolean") {
      this.settings.oauthBridgeEnabled = DEFAULT_SETTINGS.oauthBridgeEnabled;
    }
    if (typeof this.settings.oauthBridgeBaseUrl !== "string") {
      this.settings.oauthBridgeBaseUrl = DEFAULT_SETTINGS.oauthBridgeBaseUrl;
    }
    if (typeof this.settings.oauthBridgeModel !== "string") {
      this.settings.oauthBridgeModel = DEFAULT_SETTINGS.oauthBridgeModel;
    }
    if (typeof this.settings.oauthEnabled !== "boolean") {
      this.settings.oauthEnabled = DEFAULT_SETTINGS.oauthEnabled;
    }
    if (typeof this.settings.oauthProviderPreset !== "string") {
      const providerHint = typeof this.settings.oauthProvider === "string" ? this.settings.oauthProvider.trim().toLowerCase() : "";
      this.settings.oauthProviderPreset = providerHint === "google" || providerHint === "auth0" ? providerHint : DEFAULT_SETTINGS.oauthProviderPreset;
    }
    this.settings.oauthProviderPreset = this.normalizeOAuthProviderPresetForQa(this.settings.oauthProviderPreset);
    if (typeof this.settings.oauthProvider !== "string") {
      this.settings.oauthProvider = DEFAULT_SETTINGS.oauthProvider;
    }
    if (typeof this.settings.oauthAuth0Domain !== "string") {
      this.settings.oauthAuth0Domain = DEFAULT_SETTINGS.oauthAuth0Domain;
    }
    this.settings.oauthAuth0Domain = this.sanitizeOAuthDomainForQa(this.settings.oauthAuth0Domain);
    if (typeof this.settings.oauthAuthUrl !== "string") {
      this.settings.oauthAuthUrl = DEFAULT_SETTINGS.oauthAuthUrl;
    }
    if (typeof this.settings.oauthTokenUrl !== "string") {
      this.settings.oauthTokenUrl = DEFAULT_SETTINGS.oauthTokenUrl;
    }
    if (typeof this.settings.oauthClientId !== "string") {
      this.settings.oauthClientId = DEFAULT_SETTINGS.oauthClientId;
    }
    if (typeof this.settings.oauthScopes !== "string") {
      this.settings.oauthScopes = DEFAULT_SETTINGS.oauthScopes;
    }
    if (typeof this.settings.oauthUsePkce !== "boolean") {
      this.settings.oauthUsePkce = DEFAULT_SETTINGS.oauthUsePkce;
    }
    if (typeof this.settings.oauthAccessToken !== "string") {
      this.settings.oauthAccessToken = DEFAULT_SETTINGS.oauthAccessToken;
    }
    if (typeof this.settings.oauthRefreshToken !== "string") {
      this.settings.oauthRefreshToken = DEFAULT_SETTINGS.oauthRefreshToken;
    }
    if (!Number.isFinite(Number(this.settings.oauthTokenExpiry))) {
      this.settings.oauthTokenExpiry = DEFAULT_SETTINGS.oauthTokenExpiry;
    }
    this.settings.oauthTokenExpiry = Math.max(0, Math.floor(Number(this.settings.oauthTokenExpiry) || 0));
    this.settings.oauthRedirectUri = this.normalizeOAuthRedirectUriForQa(this.settings.oauthRedirectUri);
    if (this.settings.qaChatModelFamily === "cloud" && !this.settings.qaAllowNonLocalEndpoint) {
      this.settings.qaAllowNonLocalEndpoint = true;
    }
    if (typeof this.settings.qaAllowedOutboundHosts !== "string") {
      this.settings.qaAllowedOutboundHosts = DEFAULT_SETTINGS.qaAllowedOutboundHosts;
    }
    if (this.settings.qaChatModelFamily === "cloud") {
      const cloudBase = toOpenAICompatibleBase(this.settings.openAIBaseUrl.trim() || DEFAULT_SETTINGS.openAIBaseUrl);
      if (!this.settings.qaOllamaBaseUrl.trim()) {
        this.settings.qaOllamaBaseUrl = cloudBase;
      }
      this.appendQaAllowedOutboundHostFromUrl(this.settings.qaOllamaBaseUrl || cloudBase);
      if (this.settings.oauthBridgeEnabled) {
        const oauthBase = this.settings.oauthBridgeBaseUrl.trim() || this.settings.openAIBaseUrl.trim() || DEFAULT_SETTINGS.openAIBaseUrl;
        this.appendQaAllowedOutboundHostFromUrl(oauthBase);
      }
    } else if (this.settings.qaOllamaModel.trim()) {
      this.syncQaCloudFamilyFromModelHint(this.settings.qaOllamaModel.trim());
    }
    if (typeof this.settings.qaPreferChatApi !== "boolean") {
      this.settings.qaPreferChatApi = DEFAULT_SETTINGS.qaPreferChatApi;
    }
    if (typeof this.settings.qaStructureGuardEnabled !== "boolean") {
      this.settings.qaStructureGuardEnabled = DEFAULT_SETTINGS.qaStructureGuardEnabled;
    }
    if (typeof this.settings.qaAlwaysDetailedAnswer !== "boolean") {
      this.settings.qaAlwaysDetailedAnswer = DEFAULT_SETTINGS.qaAlwaysDetailedAnswer;
    }
    if (!Number.isFinite(this.settings.qaMinAnswerChars)) {
      this.settings.qaMinAnswerChars = DEFAULT_SETTINGS.qaMinAnswerChars;
    }
    if (this.settings.qaPreferredResponseLanguage !== "auto" && this.settings.qaPreferredResponseLanguage !== "korean" && this.settings.qaPreferredResponseLanguage !== "english") {
      this.settings.qaPreferredResponseLanguage = DEFAULT_SETTINGS.qaPreferredResponseLanguage;
    }
    const presetProfile = this.settings.qaLocalPresetProfile;
    if (presetProfile !== "fast_local" && presetProfile !== "balanced_local" && presetProfile !== "quality_local" && presetProfile !== "custom") {
      this.settings.qaLocalPresetProfile = DEFAULT_SETTINGS.qaLocalPresetProfile;
    }
    if (this.settings.qaConversationMode !== "ask" && this.settings.qaConversationMode !== "plan" && this.settings.qaConversationMode !== "agent" && this.settings.qaConversationMode !== "orchestration") {
      this.settings.qaConversationMode = DEFAULT_SETTINGS.qaConversationMode;
    }
    if (typeof this.settings.qaQuickCustomProfileSlot1 !== "string") {
      this.settings.qaQuickCustomProfileSlot1 = DEFAULT_SETTINGS.qaQuickCustomProfileSlot1;
    }
    if (typeof this.settings.qaQuickCustomProfileSlot2 !== "string") {
      this.settings.qaQuickCustomProfileSlot2 = DEFAULT_SETTINGS.qaQuickCustomProfileSlot2;
    }
    if (typeof this.settings.qaQuickCustomProfileSlot3 !== "string") {
      this.settings.qaQuickCustomProfileSlot3 = DEFAULT_SETTINGS.qaQuickCustomProfileSlot3;
    }
    if (typeof this.settings.qaCustomSystemPrompt !== "string") {
      this.settings.qaCustomSystemPrompt = DEFAULT_SETTINGS.qaCustomSystemPrompt;
    }
    const rolePresetValid = QA_ROLE_PRESET_OPTIONS.some(
      (option) => option.value === this.settings.qaRolePreset
    );
    if (!rolePresetValid) {
      this.settings.qaRolePreset = DEFAULT_SETTINGS.qaRolePreset;
    }
    const pipelinePresetValid = QA_PIPELINE_PRESET_OPTIONS.some(
      (option) => option.value === this.settings.qaPipelinePreset
    );
    if (!pipelinePresetValid) {
      this.settings.qaPipelinePreset = DEFAULT_SETTINGS.qaPipelinePreset;
    }
    if (typeof this.settings.qaAskModel !== "string") {
      this.settings.qaAskModel = DEFAULT_SETTINGS.qaAskModel;
    }
    if (typeof this.settings.qaAskVisionModel !== "string") {
      this.settings.qaAskVisionModel = DEFAULT_SETTINGS.qaAskVisionModel;
    }
    if (typeof this.settings.qaImageGeneratorModel !== "string") {
      this.settings.qaImageGeneratorModel = DEFAULT_SETTINGS.qaImageGeneratorModel;
    }
    if (typeof this.settings.qaCoderModel !== "string") {
      this.settings.qaCoderModel = DEFAULT_SETTINGS.qaCoderModel;
    }
    if (typeof this.settings.qaDebuggerModel !== "string") {
      this.settings.qaDebuggerModel = DEFAULT_SETTINGS.qaDebuggerModel;
    }
    if (!this.settings.qaDebuggerModel.trim() && this.settings.qaCoderModel.trim()) {
      this.settings.qaDebuggerModel = this.settings.qaCoderModel.trim();
    }
    if (typeof this.settings.qaArchitectModel !== "string") {
      this.settings.qaArchitectModel = DEFAULT_SETTINGS.qaArchitectModel;
    }
    if (typeof this.settings.qaOrchestratorModel !== "string") {
      this.settings.qaOrchestratorModel = DEFAULT_SETTINGS.qaOrchestratorModel;
    }
    if (typeof this.settings.qaSafeguardModel !== "string") {
      this.settings.qaSafeguardModel = DEFAULT_SETTINGS.qaSafeguardModel;
    }
    if (typeof this.settings.qaBalancedPresetBaseModel !== "string") {
      this.settings.qaBalancedPresetBaseModel = DEFAULT_SETTINGS.qaBalancedPresetBaseModel;
    }
    if (typeof this.settings.qaBalancedPresetVisionModel !== "string") {
      this.settings.qaBalancedPresetVisionModel = DEFAULT_SETTINGS.qaBalancedPresetVisionModel;
    }
    if (typeof this.settings.qaBalancedPresetEmbeddingModel !== "string") {
      this.settings.qaBalancedPresetEmbeddingModel = DEFAULT_SETTINGS.qaBalancedPresetEmbeddingModel;
    }
    if (typeof this.settings.qaQualityPresetBaseModel !== "string") {
      this.settings.qaQualityPresetBaseModel = DEFAULT_SETTINGS.qaQualityPresetBaseModel;
    }
    if (typeof this.settings.qaQualityPresetVisionModel !== "string") {
      this.settings.qaQualityPresetVisionModel = DEFAULT_SETTINGS.qaQualityPresetVisionModel;
    }
    if (typeof this.settings.qaQualityPresetEmbeddingModel !== "string") {
      this.settings.qaQualityPresetEmbeddingModel = DEFAULT_SETTINGS.qaQualityPresetEmbeddingModel;
    }
    if (typeof this.settings.qaAskSystemPrompt !== "string") {
      this.settings.qaAskSystemPrompt = DEFAULT_SETTINGS.qaAskSystemPrompt;
    }
    if (typeof this.settings.qaAskVisionSystemPrompt !== "string") {
      this.settings.qaAskVisionSystemPrompt = DEFAULT_SETTINGS.qaAskVisionSystemPrompt;
    }
    if (typeof this.settings.qaImageGeneratorSystemPrompt !== "string") {
      this.settings.qaImageGeneratorSystemPrompt = DEFAULT_SETTINGS.qaImageGeneratorSystemPrompt;
    }
    if (typeof this.settings.qaCoderSystemPrompt !== "string") {
      this.settings.qaCoderSystemPrompt = DEFAULT_SETTINGS.qaCoderSystemPrompt;
    }
    if (typeof this.settings.qaDebuggerSystemPrompt !== "string") {
      this.settings.qaDebuggerSystemPrompt = DEFAULT_SETTINGS.qaDebuggerSystemPrompt;
    }
    if (typeof this.settings.qaArchitectSystemPrompt !== "string") {
      this.settings.qaArchitectSystemPrompt = DEFAULT_SETTINGS.qaArchitectSystemPrompt;
    }
    if (typeof this.settings.qaOrchestratorSystemPrompt !== "string") {
      this.settings.qaOrchestratorSystemPrompt = DEFAULT_SETTINGS.qaOrchestratorSystemPrompt;
    }
    if (typeof this.settings.qaSafeguardSystemPrompt !== "string") {
      this.settings.qaSafeguardSystemPrompt = DEFAULT_SETTINGS.qaSafeguardSystemPrompt;
    }
    const promptFields = [
      "qaCustomSystemPrompt",
      "qaAskSystemPrompt",
      "qaAskVisionSystemPrompt",
      "qaImageGeneratorSystemPrompt",
      "qaCoderSystemPrompt",
      "qaDebuggerSystemPrompt",
      "qaArchitectSystemPrompt",
      "qaOrchestratorSystemPrompt",
      "qaSafeguardSystemPrompt"
    ];
    const hasAnyPromptValue = promptFields.some((field) => {
      const value = this.settings[field];
      return typeof value === "string" && value.trim().length > 0;
    });
    if (!hasAnyPromptValue) {
      this.settings.qaCustomSystemPrompt = DEFAULT_SETTINGS.qaCustomSystemPrompt;
      this.settings.qaAskSystemPrompt = DEFAULT_SETTINGS.qaAskSystemPrompt;
      this.settings.qaAskVisionSystemPrompt = DEFAULT_SETTINGS.qaAskVisionSystemPrompt;
      this.settings.qaImageGeneratorSystemPrompt = DEFAULT_SETTINGS.qaImageGeneratorSystemPrompt;
      this.settings.qaCoderSystemPrompt = DEFAULT_SETTINGS.qaCoderSystemPrompt;
      this.settings.qaDebuggerSystemPrompt = DEFAULT_SETTINGS.qaDebuggerSystemPrompt;
      this.settings.qaArchitectSystemPrompt = DEFAULT_SETTINGS.qaArchitectSystemPrompt;
      this.settings.qaOrchestratorSystemPrompt = DEFAULT_SETTINGS.qaOrchestratorSystemPrompt;
      this.settings.qaSafeguardSystemPrompt = DEFAULT_SETTINGS.qaSafeguardSystemPrompt;
    }
    if (typeof this.settings.qaRoleModelAutoPickEnabled !== "boolean") {
      this.settings.qaRoleModelAutoPickEnabled = DEFAULT_SETTINGS.qaRoleModelAutoPickEnabled;
    }
    if (typeof this.settings.qaOrchestratorEnabled !== "boolean") {
      this.settings.qaOrchestratorEnabled = DEFAULT_SETTINGS.qaOrchestratorEnabled;
    }
    if (typeof this.settings.qaSafeguardPassEnabled !== "boolean") {
      this.settings.qaSafeguardPassEnabled = DEFAULT_SETTINGS.qaSafeguardPassEnabled;
    }
    if (typeof this.settings.qaIncludeSelectionInventory !== "boolean") {
      this.settings.qaIncludeSelectionInventory = DEFAULT_SETTINGS.qaIncludeSelectionInventory;
    }
    if (!Number.isFinite(this.settings.qaSelectionInventoryMaxFiles)) {
      this.settings.qaSelectionInventoryMaxFiles = DEFAULT_SETTINGS.qaSelectionInventoryMaxFiles;
    }
    if (typeof this.settings.qaThreadAutoSyncEnabled !== "boolean") {
      this.settings.qaThreadAutoSyncEnabled = DEFAULT_SETTINGS.qaThreadAutoSyncEnabled;
    }
    if (typeof this.settings.qaPdfAttachmentEnabled !== "boolean") {
      this.settings.qaPdfAttachmentEnabled = DEFAULT_SETTINGS.qaPdfAttachmentEnabled;
    }
    if (typeof this.settings.qaAgentToolModeEnabled !== "boolean") {
      this.settings.qaAgentToolModeEnabled = DEFAULT_SETTINGS.qaAgentToolModeEnabled;
    }
    if (typeof this.settings.qaAgentRequireApproval !== "boolean") {
      this.settings.qaAgentRequireApproval = DEFAULT_SETTINGS.qaAgentRequireApproval;
    }
    if (typeof this.settings.qaAgentAllowShellTool !== "boolean") {
      this.settings.qaAgentAllowShellTool = DEFAULT_SETTINGS.qaAgentAllowShellTool;
    }
    if (typeof this.settings.qaAgentShellFullAccess !== "boolean") {
      this.settings.qaAgentShellFullAccess = DEFAULT_SETTINGS.qaAgentShellFullAccess;
    }
    if (!Number.isFinite(this.settings.qaAgentShellTimeoutSec)) {
      this.settings.qaAgentShellTimeoutSec = DEFAULT_SETTINGS.qaAgentShellTimeoutSec;
    }
    this.settings.qaAgentShellTimeoutSec = Math.max(
      3,
      Math.min(300, Math.floor(this.settings.qaAgentShellTimeoutSec))
    );
    if (typeof this.settings.qaAgentShellCwdPath !== "string") {
      this.settings.qaAgentShellCwdPath = DEFAULT_SETTINGS.qaAgentShellCwdPath;
    }
    if (typeof this.settings.qaAgentPathAllowlist !== "string") {
      this.settings.qaAgentPathAllowlist = DEFAULT_SETTINGS.qaAgentPathAllowlist;
    }
    if (typeof this.settings.qaContextInChat !== "boolean") {
      this.settings.qaContextInChat = DEFAULT_SETTINGS.qaContextInChat;
    }
    if (typeof this.settings.qaRequireSelectionForSelectedAsk !== "boolean") {
      this.settings.qaRequireSelectionForSelectedAsk = DEFAULT_SETTINGS.qaRequireSelectionForSelectedAsk;
    }
    if (typeof this.settings.qaParserInboxWatchEnabled !== "boolean") {
      this.settings.qaParserInboxWatchEnabled = DEFAULT_SETTINGS.qaParserInboxWatchEnabled;
    }
    if (typeof this.settings.qaParserInboxFolder !== "string") {
      this.settings.qaParserInboxFolder = DEFAULT_SETTINGS.qaParserInboxFolder;
    }
    if (this.settings.qaParserIngestOutputFormat !== "xml" && this.settings.qaParserIngestOutputFormat !== "md") {
      this.settings.qaParserIngestOutputFormat = DEFAULT_SETTINGS.qaParserIngestOutputFormat;
    }
    if (this.settings.qaParserMode !== "fast" && this.settings.qaParserMode !== "detailed") {
      this.settings.qaParserMode = DEFAULT_SETTINGS.qaParserMode;
    }
    if (typeof this.settings.qaParserInboxCollapsedDefault !== "boolean") {
      this.settings.qaParserInboxCollapsedDefault = DEFAULT_SETTINGS.qaParserInboxCollapsedDefault;
    }
    this.settings.qaPdfAttachmentEnabled = true;
    if (typeof this.settings.qaAttachmentIngestRootPath !== "string") {
      this.settings.qaAttachmentIngestRootPath = DEFAULT_SETTINGS.qaAttachmentIngestRootPath;
    }
    this.settings.qaAttachmentIngestRootPath = (0, import_obsidian4.normalizePath)(
      this.settings.qaAttachmentIngestRootPath.trim() || DEFAULT_SETTINGS.qaAttachmentIngestRootPath
    );
    if (typeof this.settings.qaSkillsRootPath !== "string") {
      this.settings.qaSkillsRootPath = DEFAULT_SETTINGS.qaSkillsRootPath;
    }
    if (this.settings.qaAgentShellCwdPath.trim()) {
      try {
        this.settings.qaAgentShellCwdPath = this.sanitizeQaShellCwdPath(
          this.settings.qaAgentShellCwdPath
        );
      } catch (e) {
        this.settings.qaAgentShellCwdPath = DEFAULT_SETTINGS.qaAgentShellCwdPath;
      }
    }
    if (typeof this.settings.autoTagActiveNoteEnabled !== "boolean") {
      this.settings.autoTagActiveNoteEnabled = DEFAULT_SETTINGS.autoTagActiveNoteEnabled;
    }
    if (!Number.isFinite(this.settings.autoTagActiveNoteCooldownSec)) {
      this.settings.autoTagActiveNoteCooldownSec = DEFAULT_SETTINGS.autoTagActiveNoteCooldownSec;
    }
    if (typeof this.settings.watchNewNotesEnabled !== "boolean") {
      this.settings.watchNewNotesEnabled = DEFAULT_SETTINGS.watchNewNotesEnabled;
    }
    if (typeof this.settings.watchNewNotesFolders !== "string") {
      this.settings.watchNewNotesFolders = DEFAULT_SETTINGS.watchNewNotesFolders;
    }
    if (typeof this.settings.pr3ScopeRoots !== "string") {
      this.settings.pr3ScopeRoots = DEFAULT_SETTINGS.pr3ScopeRoots;
    }
    if (typeof this.settings.showPr3ScopeFingerprint !== "boolean") {
      this.settings.showPr3ScopeFingerprint = DEFAULT_SETTINGS.showPr3ScopeFingerprint;
    }
    if (typeof this.settings.chatTranscriptRootPath !== "string") {
      this.settings.chatTranscriptRootPath = DEFAULT_SETTINGS.chatTranscriptRootPath;
    }
    if (!this.settings.chatTranscriptRootPath.trim()) {
      this.settings.chatTranscriptRootPath = DEFAULT_SETTINGS.chatTranscriptRootPath;
    }
    if (typeof this.settings.cleanupReportRootPath !== "string") {
      this.settings.cleanupReportRootPath = DEFAULT_SETTINGS.cleanupReportRootPath;
    }
    if (!this.settings.cleanupReportRootPath.trim()) {
      this.settings.cleanupReportRootPath = DEFAULT_SETTINGS.cleanupReportRootPath;
    }
    if (typeof this.settings.propertyCleanupKeys !== "string") {
      this.settings.propertyCleanupKeys = DEFAULT_SETTINGS.propertyCleanupKeys;
    }
    if (typeof this.settings.propertyCleanupPrefixes !== "string") {
      this.settings.propertyCleanupPrefixes = DEFAULT_SETTINGS.propertyCleanupPrefixes;
    }
    if (typeof this.settings.propertyCleanupKeepKeys !== "string") {
      this.settings.propertyCleanupKeepKeys = DEFAULT_SETTINGS.propertyCleanupKeepKeys;
    }
    if (typeof this.settings.mocPath !== "string" || !this.settings.mocPath.trim()) {
      this.settings.mocPath = DEFAULT_SETTINGS.mocPath;
    }
    try {
      this.settings.mocPath = this.resolveSafeMarkdownPath(this.settings.mocPath, "MOC");
    } catch (e) {
      this.settings.mocPath = DEFAULT_SETTINGS.mocPath;
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  setStatus(text) {
    var _a;
    (_a = this.statusBarEl) == null ? void 0 : _a.setText(`Omni Forge: ${text}`);
  }
  notice(text, timeout = 3500) {
    if (!this.settings.showProgressNotices) {
      return;
    }
    new import_obsidian4.Notice(text, timeout);
  }
  parseSimpleList(raw) {
    return raw.split(/[\n,;]+/).map((item) => item.trim().toLowerCase()).filter((item) => item.length > 0);
  }
  readRawFrontmatterTags(frontmatter) {
    const value = frontmatter.tags;
    if (Array.isArray(value)) {
      return value.map((item) => typeof item === "string" ? item.trim() : "").filter((item) => item.length > 0);
    }
    if (typeof value === "string") {
      return value.split(",").map((item) => item.trim()).filter((item) => item.length > 0);
    }
    return [];
  }
  parseModelSizeB(modelName) {
    const lower = modelName.toLowerCase();
    const explicit = lower.match(/(\d+(?:\.\d+)?)\s*b\b/);
    if (explicit) {
      const size = Number.parseFloat(explicit[1]);
      if (Number.isFinite(size) && size > 0) {
        return size;
      }
    }
    const tag = lower.match(/:(\d+(?:\.\d+)?)(?:b|g)?$/);
    if (tag) {
      const size = Number.parseFloat(tag[1]);
      if (Number.isFinite(size) && size > 0) {
        return size;
      }
    }
    return null;
  }
  estimateRecommendedSelectionMax(modelName) {
    const sizeB = this.parseModelSizeB(modelName);
    let maxByModel = 120;
    if (sizeB !== null) {
      if (sizeB < 2) {
        maxByModel = 40;
      } else if (sizeB < 5) {
        maxByModel = 70;
      } else if (sizeB < 9) {
        maxByModel = 120;
      } else if (sizeB < 15) {
        maxByModel = 180;
      } else if (sizeB < 30) {
        maxByModel = 260;
      } else {
        maxByModel = 360;
      }
    }
    if (!this.settings.semanticLinkingEnabled || !this.settings.analyzeLinked) {
      maxByModel = Math.max(30, Math.floor(maxByModel * 0.7));
    }
    return maxByModel;
  }
  getAnalysisCachePath() {
    return (0, import_obsidian4.normalizePath)(
      `${this.app.vault.configDir}/plugins/omni-forge/${ANALYSIS_CACHE_FILE}`
    );
  }
  getSelectionDiffAuditLogPath() {
    return (0, import_obsidian4.normalizePath)(
      `${this.app.vault.configDir}/plugins/omni-forge/logs/${SELECTION_DIFF_AUDIT_LOG_FILE}`
    );
  }
  async appendSelectionDiffAuditLog(entry) {
    const payload = entry && typeof entry === "object" ? entry : {};
    const line = `${JSON.stringify(payload)}
`;
    const path = this.getSelectionDiffAuditLogPath();
    try {
      await this.ensureParentFolder(path);
      const exists = await this.app.vault.adapter.exists(path);
      if (!exists) {
        await this.app.vault.adapter.write(path, line);
        return;
      }
      const previous = await this.app.vault.adapter.read(path);
      await this.app.vault.adapter.write(path, `${previous}${line}`);
    } catch (error) {
    }
  }
  async cleanupLegacyCacheArtifacts() {
    const legacyFiles = [
      (0, import_obsidian4.normalizePath)("Omni Forge Cache/analysis-proposal-cache.json"),
      (0, import_obsidian4.normalizePath)("Omni Forge Cache/semantic-embedding-cache.json")
    ];
    for (const path of legacyFiles) {
      try {
        if (await this.app.vault.adapter.exists(path)) {
          await this.app.vault.adapter.remove(path);
        }
      } catch (e) {
      }
    }
    const legacyFolder = (0, import_obsidian4.normalizePath)("Omni Forge Cache");
    try {
      if (!await this.app.vault.adapter.exists(legacyFolder)) {
        return;
      }
      const listing = await this.app.vault.adapter.list(legacyFolder);
      if (listing.files.length === 0 && listing.folders.length === 0) {
        await this.app.vault.adapter.rmdir(legacyFolder, false);
      }
    } catch (e) {
    }
  }
  getProviderCacheSignature() {
    const modelLabel = getProviderModelLabel(this.settings);
    if (this.settings.oauthBridgeEnabled === true && isCloudProviderForOAuthBridge(this.settings.provider)) {
      const bridgeBase = resolveOAuthBridgeBaseUrl(this.settings);
      return `${this.settings.provider}::oauth-bridge::${bridgeBase}::${modelLabel}`;
    }
    if (this.settings.oauthEnabled === true && isCloudProviderForOAuthBridge(this.settings.provider)) {
      const oauthBase = toOpenAICompatibleBase(this.settings.openAIBaseUrl.trim() || DEFAULT_SETTINGS.openAIBaseUrl);
      return `${this.settings.provider}::oauth::${oauthBase}::${modelLabel}`;
    }
    switch (this.settings.provider) {
      case "ollama":
        return `ollama::${this.settings.ollamaBaseUrl.trim()}::${modelLabel}`;
      case "lmstudio":
        return `lmstudio::${this.settings.lmStudioBaseUrl.trim()}::${modelLabel}`;
      case "openai":
        return `openai::${this.settings.openAIBaseUrl.trim()}::${modelLabel}`;
      case "anthropic":
        return `anthropic::${modelLabel}`;
      case "gemini":
        return `gemini::${modelLabel}`;
      default:
        return `${this.settings.provider}::${modelLabel}`;
    }
  }
  hashString(input) {
    let hash = 2166136261;
    for (let i = 0; i < input.length; i += 1) {
      hash ^= input.charCodeAt(i);
      hash = Math.imul(hash, 16777619);
    }
    return (hash >>> 0).toString(16).padStart(8, "0");
  }
  buildAnalysisCacheKey(providerSignature, filePath) {
    return `${providerSignature}::${filePath}`;
  }
  buildAnalysisRequestSignature(providerSignature, request) {
    const payload = JSON.stringify({
      providerSignature,
      sourcePath: request.sourcePath,
      candidateLinkPaths: request.candidateLinkPaths,
      maxTags: request.maxTags,
      maxLinked: request.maxLinked,
      analyzeTags: request.analyzeTags,
      analyzeTopic: request.analyzeTopic,
      analyzeLinked: request.analyzeLinked,
      analyzeIndex: request.analyzeIndex,
      includeReasons: request.includeReasons
    });
    return this.hashString(payload);
  }
  buildAnalysisSettingsSignature(providerSignature) {
    const payload = JSON.stringify({
      providerSignature,
      maxTags: this.settings.maxTags,
      maxLinked: this.settings.maxLinked,
      analyzeTags: this.settings.analyzeTags,
      analyzeTopic: this.settings.analyzeTopic,
      analyzeLinked: this.settings.analyzeLinked,
      analyzeIndex: this.settings.analyzeIndex,
      includeReasons: this.settings.includeReasons,
      semanticLinkingEnabled: this.settings.semanticLinkingEnabled,
      semanticTopK: this.settings.semanticTopK,
      semanticMinSimilarity: this.settings.semanticMinSimilarity,
      semanticMaxChars: this.settings.semanticMaxChars,
      analyzeLinkedScopeMode: this.settings.analyzeLinkedScopeMode,
      relatedScopeMaxCandidates: this.settings.relatedScopeMaxCandidates,
      relatedScopeTimeBudgetMs: this.settings.relatedScopeTimeBudgetMs
    });
    return this.hashString(payload);
  }
  buildSelectionSignature(selectedFiles) {
    const payload = JSON.stringify(selectedFiles.map((file) => file.path));
    return this.hashString(payload);
  }
  canSkipByChangedOnlyMode(cache, cacheKey, file, settingsSignature, selectionSignature) {
    const entry = cache.entries[cacheKey];
    if (!entry) {
      return false;
    }
    if (entry.mtime !== file.stat.mtime || entry.size !== file.stat.size) {
      return false;
    }
    if (entry.settingsSignature !== settingsSignature) {
      return false;
    }
    if (entry.selectionSignature !== selectionSignature) {
      return false;
    }
    return true;
  }
  async loadAnalysisCache() {
    if (this.analysisCache) {
      return this.analysisCache;
    }
    const path = this.getAnalysisCachePath();
    const exists = await this.app.vault.adapter.exists(path);
    if (!exists) {
      this.analysisCache = {
        version: ANALYSIS_CACHE_VERSION,
        entries: {}
      };
      this.analysisCacheDirty = false;
      return this.analysisCache;
    }
    try {
      const raw = await this.app.vault.adapter.read(path);
      const parsed = JSON.parse(raw);
      const version = typeof parsed.version === "number" ? parsed.version : ANALYSIS_CACHE_VERSION;
      const entries = parsed.entries && typeof parsed.entries === "object" ? parsed.entries : {};
      if (version !== ANALYSIS_CACHE_VERSION) {
        this.analysisCache = {
          version: ANALYSIS_CACHE_VERSION,
          entries: {}
        };
      } else {
        this.analysisCache = {
          version,
          entries
        };
      }
      this.analysisCacheDirty = false;
      return this.analysisCache;
    } catch (e) {
      this.analysisCache = {
        version: ANALYSIS_CACHE_VERSION,
        entries: {}
      };
      this.analysisCacheDirty = false;
      return this.analysisCache;
    }
  }
  pruneAnalysisCache(cache) {
    const entries = Object.entries(cache.entries);
    if (entries.length <= ANALYSIS_CACHE_MAX_ENTRIES) {
      return;
    }
    entries.sort((a, b) => {
      var _a, _b, _c, _d;
      const aTime = Date.parse((_b = (_a = a[1]) == null ? void 0 : _a.updatedAt) != null ? _b : "") || 0;
      const bTime = Date.parse((_d = (_c = b[1]) == null ? void 0 : _c.updatedAt) != null ? _d : "") || 0;
      return aTime - bTime || a[0].localeCompare(b[0]);
    });
    const overflow = entries.length - ANALYSIS_CACHE_MAX_ENTRIES;
    for (let i = 0; i < overflow; i += 1) {
      delete cache.entries[entries[i][0]];
    }
  }
  async flushAnalysisCache() {
    if (!this.analysisCache || !this.analysisCacheDirty) {
      return;
    }
    this.pruneAnalysisCache(this.analysisCache);
    const path = this.getAnalysisCachePath();
    await this.ensureParentFolder(path);
    await this.app.vault.adapter.write(path, JSON.stringify(this.analysisCache));
    this.analysisCacheDirty = false;
  }
  getCachedAnalysisOutcome(cache, cacheKey, requestSignature, file, settingsSignature, selectionSignature) {
    const entry = cache.entries[cacheKey];
    if (!entry || entry.requestSignature !== requestSignature || entry.mtime !== file.stat.mtime || entry.size !== file.stat.size) {
      return null;
    }
    if (entry.settingsSignature !== settingsSignature || entry.selectionSignature !== selectionSignature) {
      entry.settingsSignature = settingsSignature;
      entry.selectionSignature = selectionSignature;
      entry.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
      this.analysisCacheDirty = true;
    }
    return {
      proposal: cloneMetadataProposal(entry.proposal),
      meta: {
        ...cloneSuggestionMeta(entry.meta),
        elapsedMs: 0
      }
    };
  }
  storeAnalysisOutcome(cache, cacheKey, requestSignature, settingsSignature, selectionSignature, file, outcome) {
    cache.entries[cacheKey] = {
      requestSignature,
      settingsSignature,
      selectionSignature,
      mtime: file.stat.mtime,
      size: file.stat.size,
      proposal: cloneMetadataProposal(outcome.proposal),
      meta: cloneSuggestionMeta(outcome.meta),
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    this.analysisCacheDirty = true;
  }
  parseFrontmatterFromContent(content) {
    const lines = content.split("\n");
    if (lines.length < 3 || lines[0].trim() !== "---") {
      return null;
    }
    let end = -1;
    for (let i = 1; i < lines.length; i += 1) {
      if (lines[i].trim() === "---") {
        end = i;
        break;
      }
    }
    if (end < 1) {
      return null;
    }
    const yamlRaw = lines.slice(1, end).join("\n").trim();
    if (!yamlRaw) {
      return {};
    }
    try {
      const parsed = (0, import_obsidian4.parseYaml)(yamlRaw);
      if (parsed && typeof parsed === "object") {
        return parsed;
      }
      return {};
    } catch (e) {
      return null;
    }
  }
  parseFrontmatterBlockFromContent(content) {
    const normalized = (content != null ? content : "").replace(/\r\n/g, "\n");
    const lines = normalized.split("\n");
    if (lines.length === 0 || lines[0].trim() !== "---") {
      return {
        normalizedText: normalized,
        exists: false,
        valid: true,
        error: "",
        frontmatter: {},
        blockText: "",
        bodyStartOffset: 0,
        bodyText: normalized
      };
    }
    let end = -1;
    for (let i = 1; i < lines.length; i += 1) {
      if (lines[i].trim() === "---") {
        end = i;
        break;
      }
    }
    if (end < 1) {
      return {
        normalizedText: normalized,
        exists: true,
        valid: false,
        error: "Unclosed frontmatter block.",
        frontmatter: {},
        blockText: normalized,
        bodyStartOffset: normalized.length,
        bodyText: ""
      };
    }
    let bodyStartOffset = 0;
    for (let i = 0; i <= end; i += 1) {
      bodyStartOffset += lines[i].length;
      if (i < lines.length - 1) {
        bodyStartOffset += 1;
      }
    }
    const blockText = normalized.slice(0, bodyStartOffset);
    const bodyText = normalized.slice(bodyStartOffset);
    const yamlRaw = lines.slice(1, end).join("\n").trim();
    if (!yamlRaw) {
      return {
        normalizedText: normalized,
        exists: true,
        valid: true,
        error: "",
        frontmatter: {},
        blockText,
        bodyStartOffset,
        bodyText
      };
    }
    try {
      const parsed = (0, import_obsidian4.parseYaml)(yamlRaw);
      const frontmatter = parsed && typeof parsed === "object" && !Array.isArray(parsed) ? parsed : {};
      return {
        normalizedText: normalized,
        exists: true,
        valid: true,
        error: "",
        frontmatter,
        blockText,
        bodyStartOffset,
        bodyText
      };
    } catch (error) {
      return {
        normalizedText: normalized,
        exists: true,
        valid: false,
        error: "Frontmatter YAML parse failed.",
        frontmatter: {},
        blockText,
        bodyStartOffset,
        bodyText
      };
    }
  }
  dedupeFrontmatterStringArray(values) {
    const seen = /* @__PURE__ */ new Set();
    const output = [];
    for (const value of values) {
      const normalized = value.trim();
      if (!normalized || seen.has(normalized)) {
        continue;
      }
      seen.add(normalized);
      output.push(normalized);
    }
    return output;
  }
  pickFrontmatterSingleString(value) {
    if (typeof value === "string") {
      const normalized = value.trim();
      return normalized.length > 0 ? normalized : void 0;
    }
    if (Array.isArray(value)) {
      for (const item of value) {
        if (typeof item !== "string") {
          continue;
        }
        const normalized = item.trim();
        if (normalized.length > 0) {
          return normalized;
        }
      }
    }
    return void 0;
  }
  pickFrontmatterSingleIndex(value) {
    if (typeof value === "number" && Number.isFinite(value)) {
      return value;
    }
    return this.pickFrontmatterSingleString(value);
  }
  normalizeFrontmatterGuardRecord(rawFrontmatter, createdValue, updatedIso) {
    const source = rawFrontmatter && typeof rawFrontmatter === "object" && !Array.isArray(rawFrontmatter) ? rawFrontmatter : {};
    const next = {};
    const linked = this.dedupeFrontmatterStringArray(toStringArray(source.linked));
    if (linked.length > 0) {
      next.linked = linked;
    }
    const tags = this.dedupeFrontmatterStringArray(toStringArray(source.tags));
    if (tags.length > 0) {
      next.tags = tags;
    }
    const topic = this.pickFrontmatterSingleString(source.topic);
    if (topic) {
      next.topic = topic;
    }
    const index = this.pickFrontmatterSingleIndex(source.index);
    if (index !== void 0) {
      next.index = index;
    }
    if (createdValue !== void 0 && createdValue !== null) {
      if (typeof createdValue === "string") {
        const created = createdValue.trim();
        if (created.length > 0) {
          next.created = created;
        }
      } else if (typeof createdValue === "number" && Number.isFinite(createdValue)) {
        next.created = createdValue;
      } else if (typeof createdValue === "boolean") {
        next.created = createdValue;
      }
    }
    next.updated = updatedIso;
    return next;
  }
  formatFrontmatterGuardScalar(value) {
    if (typeof value === "number" && Number.isFinite(value)) {
      return String(value);
    }
    if (typeof value === "boolean") {
      return value ? "true" : "false";
    }
    if (value === null) {
      return "null";
    }
    return JSON.stringify(String(value));
  }
  renderFrontmatterGuardBlock(frontmatter) {
    const lines = [];
    for (const key of FRONTMATTER_GUARD_ALLOWED_KEYS) {
      if (!Object.prototype.hasOwnProperty.call(frontmatter, key)) {
        continue;
      }
      const value = frontmatter[key];
      if (Array.isArray(value)) {
        const normalized = this.dedupeFrontmatterStringArray(
          value.map((item) => typeof item === "string" ? item : String(item))
        );
        if (normalized.length === 0) {
          continue;
        }
        lines.push(`${key}:`);
        for (const item of normalized) {
          lines.push(`  - ${this.formatFrontmatterGuardScalar(item)}`);
        }
        continue;
      }
      if (value === void 0) {
        continue;
      }
      lines.push(`${key}: ${this.formatFrontmatterGuardScalar(value)}`);
    }
    if (lines.length === 0) {
      return `---\n---`;
    }
    return `---\n${lines.join("\n")}\n---`;
  }
  runFrontmatterLintGuardAfterPatch(params) {
    const mode = params.mode === "selection" ? "selection" : "default";
    const beforeInfo = this.parseFrontmatterBlockFromContent(params.beforeText);
    const patchedInfo = this.parseFrontmatterBlockFromContent(params.patchedText);
    if (!beforeInfo.valid) {
      return {
        ok: false,
        error: "FrontmatterGuard blocked: current frontmatter YAML is invalid. Fix frontmatter and retry."
      };
    }
    if (!patchedInfo.valid) {
      return {
        ok: false,
        error: "FrontmatterGuard blocked: patched frontmatter YAML is invalid. Regenerate patch."
      };
    }
    const frontmatterChangedByPatch = beforeInfo.blockText !== patchedInfo.blockText;
    if (mode === "selection" && frontmatterChangedByPatch) {
      return {
        ok: false,
        error: "Selection mode blocks frontmatter edits. Regenerate patch without frontmatter changes."
      };
    }
    const beforeRecord = beforeInfo.frontmatter && typeof beforeInfo.frontmatter === "object" && !Array.isArray(beforeInfo.frontmatter) ? beforeInfo.frontmatter : {};
    const createdValue = Object.prototype.hasOwnProperty.call(beforeRecord, "created") ? beforeRecord.created : void 0;
    const normalizedRecord = this.normalizeFrontmatterGuardRecord(
      beforeRecord,
      createdValue,
      (/* @__PURE__ */ new Date()).toISOString()
    );
    for (const key of Object.keys(normalizedRecord)) {
      if (!FRONTMATTER_GUARD_ALLOWED_KEY_SET.has(key)) {
        delete normalizedRecord[key];
      }
    }
    const frontmatterBlock = this.renderFrontmatterGuardBlock(normalizedRecord);
    const bodyWithoutLeadingBreak = patchedInfo.bodyText.replace(/^\n/, "");
    const guardedText = `${frontmatterBlock}\n${bodyWithoutLeadingBreak}`;
    const guardedInfo = this.parseFrontmatterBlockFromContent(guardedText);
    if (!guardedInfo.valid) {
      return {
        ok: false,
        error: "FrontmatterGuard failed to produce valid frontmatter YAML."
      };
    }
    return {
      ok: true,
      text: guardedInfo.normalizedText,
      beforeBodyStartOffset: patchedInfo.bodyStartOffset,
      finalBodyStartOffset: guardedInfo.bodyStartOffset,
      bodyOffsetDelta: guardedInfo.bodyStartOffset - patchedInfo.bodyStartOffset,
      frontmatterChangedByPatch,
      guardApplied: guardedInfo.normalizedText !== patchedInfo.normalizedText
    };
  }
  mapOffsetAfterFrontmatterGuard(offset, beforeBodyStartOffset, bodyOffsetDelta) {
    const baseOffset = Number.isFinite(offset) ? Math.floor(offset) : 0;
    if (baseOffset >= beforeBodyStartOffset) {
      return baseOffset + bodyOffsetDelta;
    }
    return baseOffset;
  }
  async readFrontmatterSnapshot(file) {
    const raw = await this.app.vault.cachedRead(file);
    return this.parseFrontmatterFromContent(raw);
  }
  async collectCleanupKeyStats(files) {
    var _a;
    const counts = /* @__PURE__ */ new Map();
    for (const file of files) {
      const frontmatter = await this.readFrontmatterSnapshot(file);
      if (!frontmatter) {
        continue;
      }
      const keys = Object.keys(frontmatter).map((key) => key.trim().toLowerCase()).filter((key) => key.length > 0);
      const unique = new Set(keys);
      for (const key of unique) {
        counts.set(key, ((_a = counts.get(key)) != null ? _a : 0) + 1);
      }
    }
    return [...counts.entries()].map(([key, count]) => ({ key, count })).sort((a, b) => b.count - a.count || a.key.localeCompare(b.key));
  }
  async openCleanupKeyPicker() {
    const selectedFiles = this.getSelectedFiles();
    if (selectedFiles.length === 0) {
      this.notice("No target notes selected. Open selector first.");
      await this.openSelectionModal();
      return;
    }
    this.setStatus("scanning cleanup keys...");
    const keyStats = await this.collectCleanupKeyStats(selectedFiles);
    this.setStatus("idle");
    if (keyStats.length === 0) {
      this.notice("No frontmatter keys found in selected notes.");
      return;
    }
    const currentKeys = this.parseSimpleList(this.settings.propertyCleanupKeys);
    new CleanupKeyPickerModal(
      this.app,
      keyStats,
      currentKeys,
      async (selected) => {
        this.settings.propertyCleanupKeys = selected.join(", ");
        await this.saveSettings();
        this.notice(`Cleanup exact keys updated (${selected.length} selected).`, 5e3);
      }
    ).open();
  }
  isLocalEndpoint(urlText) {
    try {
      const parsed = new URL(urlText);
      const host = parsed.hostname.toLowerCase();
      return host === "localhost" || host === "127.0.0.1" || host === "::1" || host === "0.0.0.0";
    } catch (e) {
      return false;
    }
  }
  parseQaAllowedOutboundHosts() {
    return this.settings.qaAllowedOutboundHosts.split(/[\n,]/g).map((entry) => entry.trim().toLowerCase()).filter((entry) => entry.length > 0);
  }
  isHostAllowedByPolicy(hostname, allowlist) {
    const host = hostname.trim().toLowerCase();
    if (!host) {
      return false;
    }
    return allowlist.some((allowed) => host === allowed || host.endsWith(`.${allowed}`));
  }
  validateQaEndpointPolicy(qaBaseUrl) {
    if (this.isLocalEndpoint(qaBaseUrl)) {
      return null;
    }
    if (!this.settings.qaAllowNonLocalEndpoint) {
      return "Blocked by security policy: Q&A endpoint must be localhost unless explicitly allowed.";
    }
    let parsed;
    try {
      parsed = new URL(qaBaseUrl);
    } catch (e) {
      return `Blocked by security policy: invalid Q&A endpoint URL (${qaBaseUrl}).`;
    }
    const hostAllowlist = this.parseQaAllowedOutboundHosts();
    if (hostAllowlist.length === 0) {
      return "Blocked by security policy: non-local endpoint is enabled but outbound host allowlist is empty.";
    }
    if (!this.isHostAllowedByPolicy(parsed.hostname, hostAllowlist)) {
      return `Blocked by security policy: host '${parsed.hostname}' is not in outbound allowlist.`;
    }
    return null;
  }
  resolveQaBaseUrl() {
    if (this.settings.qaChatModelFamily === "cloud" && this.settings.oauthBridgeEnabled === true) {
      const oauthBase = this.settings.oauthBridgeBaseUrl.trim() || this.settings.openAIBaseUrl.trim() || DEFAULT_SETTINGS.openAIBaseUrl;
      if (oauthBase) {
        return oauthBase;
      }
    }
    const qa = this.settings.qaOllamaBaseUrl.trim();
    const fallback = this.settings.ollamaBaseUrl.trim();
    return qa || fallback;
  }
  resolveQaModel() {
    return this.resolveQaModelForRole(this.resolveQaPrimaryRole());
  }
  trimTextForContext(source, maxChars) {
    const collapsed = source.replace(/\s+/g, " ").trim();
    return collapsed.slice(0, Math.max(400, maxChars));
  }
  isAbortError(error) {
    if (!error) {
      return false;
    }
    if (typeof DOMException !== "undefined" && error instanceof DOMException) {
      return error.name === "AbortError";
    }
    if (error instanceof Error) {
      return error.name === "AbortError" || /aborted|abort/i.test(error.message);
    }
    return false;
  }
  emitQaEvent(onEvent, stage, message, options = {}) {
    if (!onEvent) {
      return;
    }
    onEvent({
      stage,
      message,
      detail: options.detail,
      thinkingChunk: options.thinkingChunk,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  tokenizeQuery(text) {
    return [...new Set(
      text.toLowerCase().split(/[\s,.;:!?()[\]{}"'<>\\/|`~!@#$%^&*+=_-]+/).map((token) => token.trim()).filter((token) => token.length >= 2)
    )];
  }
  countTermMatches(text, terms) {
    if (terms.length === 0) {
      return 0;
    }
    let matched = 0;
    for (const term of terms) {
      if (text.includes(term)) {
        matched += 1;
      }
    }
    return matched;
  }
  normalizeQaOpenSelectionContext(rawSelection, openFilePath = "") {
    if (!rawSelection || typeof rawSelection !== "object") {
      return null;
    }
    const openPath = (0, import_obsidian4.normalizePath)((openFilePath != null ? openFilePath : "").trim());
    const filePath = (0, import_obsidian4.normalizePath)(
      (typeof rawSelection.filePath === "string" ? rawSelection.filePath : openPath).trim()
    );
    if (!filePath || !this.isSafeVaultRelativePath(filePath)) {
      return null;
    }
    if (openPath && filePath !== openPath) {
      return null;
    }
    const fromOffset = Math.floor(Number(rawSelection.fromOffset));
    const toOffset = Math.floor(Number(rawSelection.toOffset));
    if (!Number.isFinite(fromOffset) || !Number.isFinite(toOffset)) {
      return null;
    }
    if (fromOffset < 0 || toOffset <= fromOffset) {
      return null;
    }
    const selectedText = typeof rawSelection.selectedText === "string" ? rawSelection.selectedText : "";
    if (!selectedText) {
      return null;
    }
    const capturedAt = typeof rawSelection.capturedAt === "string" ? rawSelection.capturedAt : (/* @__PURE__ */ new Date()).toISOString();
    const selectionHash = this.hashString(`${filePath}
${selectedText}`);
    return {
      filePath,
      fromOffset,
      toOffset,
      selectedText,
      selectionHash,
      capturedAt
    };
  }
  classifyTaskForQa(question, context) {
    const normalized = question.toLowerCase();
    if (context.hasSelection) {
      return "EDIT_NOTE";
    }
    if (/(pdf|xlsx|excel|엑셀|변환|convert|parser|파서|ingest)/i.test(normalized)) {
      return "DOC_PIPELINE";
    }
    if (/(링크|연결|graph|autolink|linking)/i.test(normalized)) {
      return "AUTOLINK_GRAPH";
    }
    if (/(만들어|게임|프로젝트|build|create|project|prototype)/i.test(normalized)) {
      return "GENERATE_PROJECT";
    }
    if (/(요약|정리|summary|summarize)/i.test(normalized)) {
      return "QA_CHAT";
    }
    if (/(export|내보내기|출력|ppt|pdf\s*출력)/i.test(normalized)) {
      return "EXPORT";
    }
    return "QA_CHAT";
  }
  resolveTaskRolePipelineForQa(taskType) {
    const configured = ROUTER_TASK_ROLE_PIPELINE[taskType];
    if (Array.isArray(configured) && configured.length > 0) {
      return [...configured];
    }
    return [...ROUTER_TASK_ROLE_PIPELINE.QA_CHAT];
  }
  mapTaskRolesToStagesForQa(roles) {
    const stages = [];
    for (const role of roles) {
      const stage = ROUTER_ROLE_STAGE_MAP[role];
      if (!stage) {
        continue;
      }
      if (!stages.includes(stage)) {
        stages.push(stage);
      }
    }
    return stages;
  }
  resolveRouterRoleModelForQa(role, qaModel) {
    const priorities = ROUTER_ROLE_MODEL_PRIORITY[role] || ["ask"];
    for (let index = 0; index < priorities.length; index += 1) {
      const roleKey = priorities[index];
      const model = this.resolveQaModelForRole(roleKey).trim();
      if (!model) {
        continue;
      }
      return {
        model,
        roleKey,
        usedFallback: index > 0
      };
    }
    return {
      model: qaModel,
      roleKey: "ask",
      usedFallback: true
    };
  }
  buildTaskRoutingForQa(question, context, qaModel) {
    const taskType = this.classifyTaskForQa(question, context);
    const roles = this.resolveTaskRolePipelineForQa(taskType);
    const modelUsed = [];
    let fallbackUsed = false;
    for (const role of roles) {
      const resolved = this.resolveRouterRoleModelForQa(role, qaModel);
      if (resolved.model) {
        modelUsed.push(resolved.model);
      }
      if (resolved.usedFallback) {
        fallbackUsed = true;
      }
    }
    return {
      taskType,
      roles,
      stages: this.mapTaskRolesToStagesForQa(roles),
      modelUsed: [...new Set(modelUsed)],
      fallbackUsed,
      safeguardPassed: false
    };
  }
  detectLocalQaIntent(question) {
    const normalized = question.toLowerCase();
    if (this.matchesGameBuildIntent(question)) {
      return "game_build";
    }
    if (/(출처|근거|source|sources|reference|references|링크만|links?\s+only|only\s+links|cite)/i.test(normalized)) {
      return "sources_only";
    }
    if (/(비교|차이|장단점|vs\b|versus|compare|comparison|trade[- ]?off|선택지)/i.test(normalized)) {
      return "comparison";
    }
    if (/(계획|플랜|로드맵|체크리스트|준비|실행|우선순위|plan|roadmap|checklist|todo|action\s+plan)/i.test(normalized)) {
      return "plan";
    }
    return "default";
  }
  resolveQaRetrievalCandidateK(intent, topK) {
    if (intent === "comparison" || intent === "plan") {
      return Math.max(topK * 8, 28);
    }
    if (intent === "sources_only") {
      return Math.max(topK * 5, 24);
    }
    return Math.max(topK * 6, 24);
  }
  resolveQaRerankTopK(intent, topK) {
    if (intent === "comparison" || intent === "plan") {
      return Math.max(topK * 3, topK + 4);
    }
    if (intent === "sources_only") {
      return Math.max(topK * 2, 6);
    }
    return Math.max(topK * 2, topK);
  }
  resolveQaContextCharLimit(intent) {
    if (intent === "comparison" || intent === "plan") {
      return Math.max(3200, this.settings.qaMaxContextChars);
    }
    if (intent === "sources_only") {
      return Math.max(2200, this.settings.qaMaxContextChars);
    }
    return Math.max(2e3, this.settings.qaMaxContextChars);
  }
  rerankQaHits(hits, question, topK) {
    const terms = this.tokenizeQuery(question);
    const scored = hits.map((hit) => {
      if (terms.length === 0) {
        return { ...hit, boosted: hit.similarity };
      }
      const lowerPath = hit.path.toLowerCase();
      const matched = this.countTermMatches(lowerPath, terms);
      const boost = Math.min(0.09, matched * 0.03);
      return {
        ...hit,
        boosted: hit.similarity + boost
      };
    });
    scored.sort((a, b) => b.boosted - a.boosted || a.path.localeCompare(b.path));
    return scored.slice(0, Math.max(1, topK)).map((item) => ({
      path: item.path,
      similarity: item.similarity
    }));
  }
  splitSourceIntoContextBlocks(source) {
    const normalized = source.replace(/\r\n/g, "\n");
    const rawBlocks = normalized.split(/\n{2,}/).map((block) => block.trim()).filter((block) => block.length > 0);
    const mergedBlocks = [];
    for (let i = 0; i < rawBlocks.length; i += 1) {
      let segment = rawBlocks[i];
      if (/^#{1,6}\s/.test(segment) && i + 1 < rawBlocks.length && !/^#{1,6}\s/.test(rawBlocks[i + 1])) {
        segment = `${segment}
${rawBlocks[i + 1]}`;
        i += 1;
      }
      if (segment.length <= 1700) {
        mergedBlocks.push(segment);
        continue;
      }
      const lines = segment.split("\n");
      let chunk = "";
      for (const line of lines) {
        const candidate = chunk ? `${chunk}
${line}` : line;
        if (candidate.length > 1200 && chunk.length > 0) {
          mergedBlocks.push(chunk.trim());
          chunk = line;
        } else {
          chunk = candidate;
        }
      }
      if (chunk.trim().length > 0) {
        mergedBlocks.push(chunk.trim());
      }
    }
    return mergedBlocks.map((text, index) => ({
      index,
      text,
      lower: text.toLowerCase(),
      heading: /^#{1,6}\s/.test(text)
    }));
  }
  extractRelevantSnippet(source, query, maxChars) {
    const terms = this.tokenizeQuery(query);
    const blocks = this.splitSourceIntoContextBlocks(source);
    if (terms.length === 0 || blocks.length === 0) {
      return this.trimTextForContext(source, maxChars);
    }
    const queryLower = query.trim().toLowerCase();
    const scored = blocks.map((block) => {
      let score = this.countTermMatches(block.lower, terms);
      if (block.heading) {
        score += 0.35;
      }
      if (queryLower.length >= 8 && block.lower.includes(queryLower.slice(0, 64))) {
        score += 0.6;
      }
      return { idx: block.index, score };
    }).filter((item) => item.score > 0);
    if (scored.length === 0) {
      return this.trimTextForContext(source, maxChars);
    }
    scored.sort((a, b) => b.score - a.score || a.idx - b.idx);
    const pickedIndexes = /* @__PURE__ */ new Set();
    for (const item of scored.slice(0, 10)) {
      pickedIndexes.add(item.idx);
      if (item.score >= 2.2 && item.idx > 0) {
        pickedIndexes.add(item.idx - 1);
      }
      if (item.score >= 2.2 && item.idx + 1 < blocks.length) {
        pickedIndexes.add(item.idx + 1);
      }
    }
    const ordered = [...pickedIndexes].sort((a, b) => a - b);
    let output = "";
    for (const idx of ordered) {
      const block = blocks[idx];
      if (!block || !block.text.trim()) {
        continue;
      }
      const segment = block.text.trimEnd();
      const candidate = output.length > 0 ? `${output}

---

${segment}` : segment;
      if (candidate.length > maxChars) {
        break;
      }
      output = candidate;
    }
    if (!output) {
      return this.trimTextForContext(source, maxChars);
    }
    return output;
  }
  hasMarkdownTable(answer) {
    const lines = answer.split("\n");
    for (let i = 0; i < lines.length - 1; i += 1) {
      const head = lines[i];
      const divider = lines[i + 1];
      if (!head.includes("|")) {
        continue;
      }
      if (/^\s*\|?\s*[-:]+\s*(\|\s*[-:]+\s*)+\|?\s*$/.test(divider.trim())) {
        return true;
      }
    }
    return false;
  }
  hasChecklist(answer) {
    return /^\s*[-*]\s+\[[ xX]\]\s+/m.test(answer);
  }
  hasSourceLinkList(answer) {
    var _a;
    const matches = answer.match(
      /^\s*[-*]\s+.*(\[\[[^\]]+\]\]|\[[^\]]+\]\([^)]+\)|https?:\/\/\S+)/gm
    );
    return ((_a = matches == null ? void 0 : matches.length) != null ? _a : 0) > 0;
  }
  hasGameOutputTemplate(answer) {
    const normalized = answer.replace(/\s+/g, " ").toLowerCase();
    const requiredSlots = [
      /(게임명|game\s*name)/i,
      /(목표|학습\s*목표|objective)/i,
      /(규칙|진행\s*규칙|rules?)/i,
      /(승리\s*조건|종료\s*조건|win\s*condition)/i,
      /(예시\s*라운드|샘플\s*라운드|example\s*round)/i
    ];
    return requiredSlots.every((pattern) => pattern.test(normalized));
  }
  needsQaStructureRepair(intent, answer) {
    if (intent === "game_build") {
      return !this.hasGameOutputTemplate(answer);
    }
    if (intent === "comparison") {
      return !this.hasMarkdownTable(answer);
    }
    if (intent === "plan") {
      return !this.hasChecklist(answer);
    }
    if (intent === "sources_only") {
      return !this.hasSourceLinkList(answer);
    }
    return false;
  }
  shouldPreferDetailedAnswer(question, intent) {
    const normalized = question.toLowerCase();
    if (/(짧게|간단히|한줄|brief|short|tl;dr|요약만)/i.test(normalized)) {
      return false;
    }
    if (intent === "sources_only") {
      return false;
    }
    if (this.settings.qaAlwaysDetailedAnswer) {
      return true;
    }
    if (intent === "comparison" || intent === "plan") {
      return true;
    }
    return normalized.length >= 18;
  }
  needsQaDepthRepair(intent, answer, preferDetailed) {
    var _a;
    if (!preferDetailed || intent === "sources_only") {
      return false;
    }
    const compact = answer.replace(/\s+/g, " ").trim();
    if (!compact) {
      return true;
    }
    const paragraphCount = answer.split(/\n{2,}/).map((chunk) => chunk.trim()).filter((chunk) => chunk.length > 0).length;
    const bulletCount = ((_a = answer.match(/^\s*[-*]\s+/gm)) != null ? _a : []).length;
    const minChars = Math.max(140, this.settings.qaMinAnswerChars);
    if (compact.length < minChars) {
      return true;
    }
    if (paragraphCount < 2 && bulletCount < 4) {
      return true;
    }
    return false;
  }
  getQaConversationModeInstruction() {
    switch (this.settings.qaConversationMode) {
      case "plan":
        return "Conversation mode: Plan. Prioritize execution checklist, sequencing, and risk-aware planning.";
      case "agent":
        return "Conversation mode: Agent. When user asks to create/edit files or run commands, propose executable omni-forge-actions JSON.";
      case "orchestration":
        return "Conversation mode: Orchestration. Coordinate sub-roles and produce build-ready artifacts; include runnable code for software/game tasks.";
      case "ask":
      default:
        return "Conversation mode: Ask. Provide direct, source-grounded answers with practical clarity.";
    }
  }
  getQaContractLines(intent, preferDetailed, mode = this.settings.qaConversationMode, question = "") {
    const normalizedMode = mode === "plan" || mode === "agent" || mode === "orchestration" ? mode : "ask";
    const gameBuildRequested = this.matchesGameBuildIntent(question) || intent === "game_build";
    if (gameBuildRequested) {
      return [
        "Output contract (Game build):",
        "- Keep final output as a game artifact, not QA audit/report format.",
        "- Use this exact section order with markdown headings:",
        "  1) 게임명",
        "  2) 목표",
        "  3) 규칙",
        "  4) 승리조건",
        "  5) 예시 라운드",
        "- If selected-note evidence is irrelevant or insufficient, still provide a playable draft and mark assumptions as '가정'.",
        "- Add minimal runnable loop/pseudocode when implementation is requested."
      ];
    }
    if (intent === "sources_only") {
      return [
        "Output contract:",
        "- Return source links only (bullet list).",
        "- No extra narrative unless required for missing evidence."
      ];
    }
    if (normalizedMode === "agent") {
      return [
        "Output contract (Agent mode):",
        "- If user requests file/system actions, include exactly ONE `omni-forge-actions` code block with strict JSON.",
        "- Prefer concrete actions (`write_note`, `append_note`, `delete_note`, `read_note`, `list_folder`, `run_shell`) over long prose.",
        "- Keep non-action explanation short and operational.",
        "- If no action is needed, respond concisely without action block."
      ];
    }
    if (normalizedMode === "orchestration") {
      const gameLine = gameBuildRequested ? "- For game requests, include a minimal playable loop, file structure, and run/test commands." : "- Include implementation artifacts (file layout + runnable code) whenever coding is requested.";
      return [
        "Output contract (Orchestration mode):",
        "- Start with objective/scope in 2-3 sentences.",
        "- Provide phased execution plan with dependencies and completion criteria.",
        "- Include role routing summary (architect/coder/debugger/safeguard).",
        gameLine,
        "- End with immediate next 3 actions."
      ];
    }
    if (normalizedMode === "plan" || intent === "plan") {
      return [
        "Output contract:",
        "- Start with 2-3 sentence overview.",
        "- Include a checklist using '- [ ]' format.",
        "- Add priority or order hints for each checklist item.",
        "- Add short rationale for critical steps and risks."
      ];
    }
    if (intent === "comparison") {
      return [
        "Output contract:",
        "- Start with 2-3 sentence conclusion.",
        "- Include at least one markdown table for comparison.",
        "- After the table, add key trade-offs and recommendation.",
        "- If information is missing, fill with '\uC815\uBCF4 \uBD80\uC871' and explain briefly."
      ];
    }
    if (preferDetailed) {
      return [
        "Output contract:",
        "- Start with a direct answer in 2-4 sentences.",
        "- Then provide detailed explanation with either:",
        "  a) 2+ short paragraphs, or",
        "  b) 1 short paragraph + 4+ bullet points.",
        "- Use short section headings when it improves readability.",
        "- Include practical implications or next actions when relevant.",
        "- Avoid one-line answers unless user explicitly asks for brevity."
      ];
    }
    return [
      "Output contract:",
      "- Start with a direct answer in 1-3 sentences.",
      "- Add concise synthesis only when useful."
    ];
  }
  buildLocalQaSourceContext(sourceBlocks) {
    return sourceBlocks.map((item, index) => {
      const sourceType = item.path.startsWith("[ATTACHMENT-") || item.content.startsWith("Attachment document (PRIMARY EVIDENCE)") ? "attachment" : "selected-note";
      return `Source ${index + 1}
Type: ${sourceType}
Path: ${item.path}
Similarity: ${formatSimilarity(item.similarity)}
Content:
${item.content}`;
    }).join("\n\n---\n\n");
  }
  shouldIncludeSelectionInventory(question, selectedCount, intent) {
    if (!this.settings.qaIncludeSelectionInventory) {
      return false;
    }
    if (selectedCount >= 80) {
      return true;
    }
    if (intent === "comparison" || intent === "plan") {
      return true;
    }
    const normalized = question.toLowerCase();
    if (/(전체|모든|파일\s*목록|목록|리스트|요약표|테이블|표로|all\s+files?|file\s+list|inventory|table)/i.test(
      normalized
    )) {
      return true;
    }
    return false;
  }
  buildSelectionInventoryContext(files) {
    var _a, _b;
    const maxFiles = Math.max(20, Math.min(600, this.settings.qaSelectionInventoryMaxFiles));
    const charBudget = Math.max(1800, Math.min(12e3, Math.floor(this.settings.qaMaxContextChars * 0.6)));
    const lines = [];
    lines.push(`Total selected files: ${files.length}`);
    lines.push("Listed files: 0");
    lines.push("");
    let listed = 0;
    for (const file of files.slice(0, maxFiles)) {
      const frontmatter = (_b = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) != null ? _b : {};
      const tags = this.readRawFrontmatterTags(frontmatter).slice(0, 6).join(", ");
      const topic = typeof frontmatter.topic === "string" ? frontmatter.topic.trim() : "";
      const index = typeof frontmatter.index === "string" ? frontmatter.index.trim() : "";
      const row = `- path=${file.path} | size=${file.stat.size} | mtime=${new Date(file.stat.mtime).toISOString()} | tags=${tags || "(none)"} | topic=${topic || "(none)"} | index=${index || "(none)"}`;
      const nextText = [...lines, row].join("\n");
      if (nextText.length > charBudget) {
        break;
      }
      lines.push(row);
      listed += 1;
    }
    if (files.length > listed) {
      lines.push("");
      lines.push(`...and ${files.length - listed} more selected files not listed.`);
    }
    lines[1] = `Listed files: ${listed}`;
    return lines.join("\n");
  }
  isOrchestrationTask(question, intent) {
    if (intent === "plan" || intent === "comparison") {
      return true;
    }
    const normalized = question.toLowerCase();
    return /(계획서|보고서|ppt|슬라이드|발표|수업|교안|학습\s*게임|게임\s*개발|roadmap|plan|report|presentation|slides|lesson|game\s*design|project\s*plan)/i.test(normalized);
  }
  matchesGameBuildIntent(question) {
    const normalized = question.toLowerCase();
    return /(학습\s*게임|게임\s*개발|게임\s*만들|게임\s*구현|게임용\s*앱|게임\s*앱|앱\s*만들|앱\s*개발|game\s*(design|dev|development|prototype|build|loop|app)|build\s*(a\s*)?game|create\s*(a\s*)?game|simple\s*game|pygame|phaser|unity|godot)/i.test(
      normalized
    );
  }
  isGameBuildTask(question) {
    return this.matchesGameBuildIntent(question);
  }
  isLikelyAgentMutationTask(question) {
    const normalized = question.toLowerCase();
    if (/(frontmatter|yaml|메타데이터|속성값)/i.test(normalized)) {
      return true;
    }
    return /(삭제|지워|제거|수정|편집|바꿔|변경|추가|생성|작성|만들|저장|이동|복사|rename|remove|delete|edit|modify|update|write|append|create|implement|build|generate)/i.test(
      normalized
    );
  }
  hasMutatingQaActionInAnswer(answer, question, qaModel) {
    const parsed = this.parseQaAgentActionPlanFromAnswer({
      answer,
      question,
      model: qaModel
    });
    if (!parsed.plan) {
      return false;
    }
    return parsed.plan.actions.some(
      (action) => action.type === "write_note" || action.type === "append_note" || action.type === "delete_note" || action.type === "apply_selection_diff" || action.type === "run_shell"
    );
  }
  parseSelectionDiffContractDiff(rawDiffText) {
    const raw = (rawDiffText != null ? rawDiffText : "").replace(/\r\n/g, "\n");
    const rawTrimmed = raw.trim();
    if (!rawTrimmed) {
      return {
        ok: false,
        error: "diff is empty."
      };
    }
    if (/^```/m.test(rawTrimmed)) {
      return {
        ok: false,
        error: "Diff-only contract violation: markdown code fences are not allowed."
      };
    }
    const normalized = this.normalizeUnifiedDiffText(rawDiffText);
    if (!normalized) {
      return {
        ok: false,
        error: "diff is empty."
      };
    }
    const lines = normalized.split("\n");
    const headerCount = lines.reduce(
      (count, line) => count + (line.trim() === CODER_PROMPT_CONTRACT_SELECTION_HEADER ? 1 : 0),
      0
    );
    if (headerCount !== 1) {
      return {
        ok: false,
        error: `Diff header must appear exactly once: ${CODER_PROMPT_CONTRACT_SELECTION_HEADER}.`
      };
    }
    let firstNonEmptyIndex = -1;
    for (let index = 0; index < lines.length; index += 1) {
      if (lines[index].trim().length > 0) {
        firstNonEmptyIndex = index;
        break;
      }
    }
    if (firstNonEmptyIndex < 0 || lines[firstNonEmptyIndex].trim() !== CODER_PROMPT_CONTRACT_SELECTION_HEADER) {
      return {
        ok: false,
        error: `Diff header must be ${CODER_PROMPT_CONTRACT_SELECTION_HEADER}.`
      };
    }
    const bodyLines = lines.slice(firstNonEmptyIndex + 1);
    while (bodyLines.length > 0 && bodyLines[0].trim().length === 0) {
      bodyLines.shift();
    }
    while (bodyLines.length > 0 && bodyLines[bodyLines.length - 1].trim().length === 0) {
      bodyLines.pop();
    }
    if (bodyLines.length === 0) {
      return {
        ok: false,
        error: "No @@ hunk found in unified diff."
      };
    }
    if (!bodyLines[0].startsWith("@@")) {
      return {
        ok: false,
        error: "Unified diff must start with @@ hunk after CURRENT_SELECTION header."
      };
    }
    const pathHeaderPattern = /^(diff --git\s|index\s+[0-9a-f]+\.\.[0-9a-f]+|---\s+\S|\+\+\+\s+\S)/i;
    for (const line of bodyLines) {
      const trimmed = line.trim();
      if (pathHeaderPattern.test(trimmed)) {
        return {
          ok: false,
          error: "Path-based multi-file diff is not allowed."
        };
      }
      if (line.startsWith("@@")) {
        continue;
      }
      if (line.startsWith("\\ No newline at end of file")) {
        continue;
      }
      const prefix = line.slice(0, 1);
      if (prefix === " " || prefix === "+" || prefix === "-") {
        continue;
      }
      return {
        ok: false,
        error: "Diff-only contract violation: non-diff text detected."
      };
    }
    const diffBody = bodyLines.join("\n");
    const parsedDiff = this.parseUnifiedDiffHunks(diffBody);
    if (parsedDiff.error) {
      return {
        ok: false,
        error: parsedDiff.error
      };
    }
    return {
      ok: true,
      diffBody,
      diffWithHeader: `${CODER_PROMPT_CONTRACT_SELECTION_HEADER}
${diffBody}`,
      parsedDiff
    };
  }
  detectFrontmatterMutationInSelectionDiff(selectionText, diffBody, parsedDiff = null) {
    const applied = this.applySelectionPatchWithPatchApplier(
      selectionText != null ? selectionText : "",
      diffBody,
      parsedDiff
    );
    if (!applied.ok) {
      return {
        ok: false,
        error: applied.error || "Failed to apply unified diff to selection."
      };
    }
    const guardResult = this.runFrontmatterLintGuardAfterPatch({
      beforeText: selectionText != null ? selectionText : "",
      patchedText: applied.text,
      mode: "selection"
    });
    if (!guardResult.ok) {
      return {
        ok: false,
        error: guardResult.error || "Frontmatter changes are blocked in selection mode."
      };
    }
    return {
      ok: true,
      applyMode: applied.mode || "strict",
      changedLines: applied.changedLines
    };
  }
  validateSelectionDiffActionAgainstOpenSelection(action, openSelection) {
    if (!openSelection) {
      return {
        ok: false,
        error: "apply_selection_diff requires active open selection context."
      };
    }
    if (!action || action.type !== "apply_selection_diff") {
      return {
        ok: false,
        error: "Action type must be apply_selection_diff."
      };
    }
    const scopeRoot = (0, import_obsidian4.normalizePath)(nodePath.posix.dirname(openSelection.filePath || "") || ".");
    const scopedVault = new ScopedVault([scopeRoot]);
    let normalizedPath = openSelection.filePath;
    try {
      normalizedPath = scopedVault.assertPathInScope(
        (action.path != null ? action.path : openSelection.filePath) || openSelection.filePath,
        "apply_selection_diff.path"
      );
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      return {
        ok: false,
        error: message
      };
    }
    if (normalizedPath !== openSelection.filePath) {
      return {
        ok: false,
        error: `apply_selection_diff path mismatch (${normalizedPath} != ${openSelection.filePath}).`
      };
    }
    const expectedHash = typeof action.expectedSelectionHash === "string" ? action.expectedSelectionHash.trim() : "";
    if (!expectedHash) {
      return {
        ok: false,
        error: "expectedSelectionHash is required."
      };
    }
    const currentHash = typeof openSelection.selectionHash === "string" ? openSelection.selectionHash.trim() : "";
    if (currentHash && expectedHash !== currentHash) {
      return {
        ok: false,
        error: "Selection hash mismatch. Re-open and reselect target range."
      };
    }
    const contractDiff = this.parseSelectionDiffContractDiff(action.diff || "");
    if (!contractDiff.ok) {
      return {
        ok: false,
        error: contractDiff.error || "Invalid unified diff."
      };
    }
    const rangeCheck = this.validateSelectionDiffRange(contractDiff.parsedDiff, openSelection.selectedText || "");
    if (!rangeCheck.ok) {
      return {
        ok: false,
        error: rangeCheck.error || "Diff exceeds selection range."
      };
    }
    const limits = this.resolveSelectionDiffLimits(action);
    const limitCheck = this.validateSelectionDiffLimits(contractDiff.parsedDiff, limits);
    if (!limitCheck.ok) {
      return {
        ok: false,
        error: limitCheck.error || "Diff exceeds patch limits.",
        limits,
        limitCheck
      };
    }
    const frontmatterCheck = this.detectFrontmatterMutationInSelectionDiff(
      openSelection.selectedText || "",
      contractDiff.diffBody,
      contractDiff.parsedDiff,
      { allowFuzzy: Boolean(action.allowFuzzy) }
    );
    if (!frontmatterCheck.ok) {
      return {
        ok: false,
        error: frontmatterCheck.error || "Frontmatter changes are blocked."
      };
    }
    return {
      ok: true,
      diffBody: contractDiff.diffBody,
      diffWithHeader: contractDiff.diffWithHeader,
      parsedDiff: contractDiff.parsedDiff,
      limits,
      limitCheck
    };
  }
  buildSelectionDiffActionAnswerFromContractDiff(openSelection, diffWithHeader) {
    const payload = {
      actions: [
        {
          type: "apply_selection_diff",
          path: openSelection.filePath,
          expectedSelectionHash: openSelection.selectionHash,
          diff: diffWithHeader,
          allowFuzzy: false,
          maxChangedLines: MAX_SELECTION_DIFF_CHANGED_LINES,
          maxHunks: MAX_SELECTION_DIFF_HUNKS
        }
      ]
    };
    return `\`\`\`omni-forge-actions
${JSON.stringify(payload, null, 2)}
\`\`\``;
  }
  hasValidSelectionDiffActionInAnswer(answer, question, qaModel, openSelection) {
    const parsed = this.parseQaAgentActionPlanFromAnswer({
      answer,
      question,
      model: qaModel
    });
    if (!parsed.plan || !openSelection) {
      return false;
    }
    if (parsed.answerWithoutPlan.trim().length > 0) {
      return false;
    }
    if (parsed.plan.actions.length !== 1) {
      return false;
    }
    const action = parsed.plan.actions[0];
    const validation = this.validateSelectionDiffActionAgainstOpenSelection(action, openSelection);
    return validation.ok;
  }
  hasRunnableGameScaffold(answer) {
    const hasCodeFence = /```[a-zA-Z0-9_-]*\n[\s\S]*?```/.test(answer);
    if (!hasCodeFence) {
      return false;
    }
    return /(파일\s*구조|file\s*structure|index\.html|main\.js|game\.js|app\.js|package\.json|실행\s*방법|run\s*command|npm\s+run|python\s+\w+\.py)/i.test(
      answer
    );
  }
  describeOrchestrationModelTrace(stages, baseModel) {
    const orderedRoles = ["orchestrator", "architect", "coder", "debugger", "safeguard"];
    const included = orderedRoles.filter((role) => stages.includes(role));
    const parts = [`base=${baseModel || "(empty)"}`];
    for (const role of included) {
      parts.push(`${role}=${this.resolveQaModelForRole(role) || baseModel || "(empty)"}`);
    }
    return parts.join(" | ");
  }
  async ensureAgentMutatingActionPlan(params) {
    const {
      question,
      draftAnswer,
      sourceBlocks,
      qaBaseUrl,
      qaModel,
      openFilePath,
      onEvent,
      abortSignal
    } = params;
    this.emitQaEvent(
      onEvent,
      "warning",
      "Agent mode: mutating intent detected but no executable mutation action found. Retrying action planner."
    );
    const activeLine = openFilePath ? `Active open markdown file: ${openFilePath}` : "Active open markdown file: (none)";
    const systemPrompt = [
      "You are an action planner for Obsidian file operations.",
      "Return markdown only.",
      "First include 1 short sentence in Korean.",
      "Then include exactly ONE `omni-forge-actions` fenced block with strict JSON.",
      "For mutating requests, include at least one of: write_note, append_note, delete_note, run_shell.",
      "Do NOT return read-only plans for edit/delete/create requests.",
      "If user says this note/current note/이 노트, use the active open markdown file path provided.",
      "Never emit multiple action blocks."
    ].join("\n");
    const userPrompt = [
      `Question: ${question}`,
      activeLine,
      "",
      "Current draft answer:",
      draftAnswer,
      "",
      "Source excerpts:",
      this.buildLocalQaSourceContext(sourceBlocks)
    ].join("\n");
    try {
      const completion = await this.requestLocalQaCompletion({
        qaBaseUrl,
        qaModel,
        systemPrompt,
        userPrompt,
        history: [],
        onEvent,
        abortSignal
      });
      const split = splitThinkingBlocks(completion.answer);
      const candidate = split.answer.trim() || completion.answer.trim();
      if (!candidate) {
        this.emitQaEvent(onEvent, "warning", "Agent action retry returned empty output.");
        return draftAnswer;
      }
      if (!this.hasMutatingQaActionInAnswer(candidate, question, qaModel)) {
        this.emitQaEvent(
          onEvent,
          "warning",
          "Agent action retry still has no mutating action; keeping original answer."
        );
        return draftAnswer;
      }
      this.emitQaEvent(onEvent, "generation", "Agent action planner retry applied");
      return candidate;
    } catch (error) {
      if (this.isAbortError(error)) {
        throw error;
      }
      const message = error instanceof Error ? error.message : "Unknown agent action retry error";
      this.emitQaEvent(onEvent, "warning", "Agent action retry failed", { detail: message });
      return draftAnswer;
    }
  }
  async ensureSelectionDiffActionPlan(params) {
    const {
      question,
      draftAnswer,
      sourceBlocks,
      qaBaseUrl,
      qaModel,
      openFilePath,
      openSelection,
      routingLog,
      onEvent,
      abortSignal
    } = params;
    if (!openSelection) {
      return draftAnswer;
    }
    if (this.hasValidSelectionDiffActionInAnswer(draftAnswer, question, qaModel, openSelection)) {
      return draftAnswer;
    }
    this.emitQaEvent(
      onEvent,
      "warning",
      "EDIT_NOTE task requires apply_selection_diff with unified diff. Retrying coder planner."
    );
    const coderPrimary = this.resolveRouterRoleModelForQa("Coder", qaModel).model || qaModel;
    const coderFallback = this.resolveRouterRoleModelForQa("Architect", qaModel).model;
    const attemptModels = [coderPrimary].filter((model) => typeof model === "string" && model.trim().length > 0);
    if (coderFallback && !attemptModels.includes(coderFallback)) {
      attemptModels.push(coderFallback);
    }
    if (attemptModels.length < 2 && qaModel && !attemptModels.includes(qaModel)) {
      attemptModels.push(qaModel);
    }
    if (attemptModels.length < 2 && attemptModels[0]) {
      attemptModels.push(attemptModels[0]);
    }
    const maxAttempts = Math.min(2, attemptModels.length);
    const selectionPreview = this.trimQaToolText(openSelection.selectedText, MAX_SELECTION_DIFF_CONTEXT_CHARS);
    const systemPrompt = [
      `You are Omni-Forge Coder running Coder Prompt Contract ${CODER_PROMPT_CONTRACT_VERSION} for EDIT_NOTE.`,
      "Output unified diff only.",
      "Do not output prose, JSON, explanation, or any non-diff text.",
      "Do not wrap output in markdown code fences.",
      "Use exactly one selection header line, then unified diff hunks.",
      `The first non-empty line MUST be ${CODER_PROMPT_CONTRACT_SELECTION_HEADER}.`,
      "After the header, output only @@ hunks with standard diff line prefixes (space/+/-).",
      "Path headers are forbidden: diff --git, index, ---, +++.",
      "Patch scope is CURRENT_SELECTION only.",
      "Frontmatter edits are forbidden. Regenerate patch without frontmatter changes.",
      "Do not emit multiple alternatives."
    ].join("\n");
    const userPrompt = [
      `[CODER_PROMPT_CONTRACT_${CODER_PROMPT_CONTRACT_VERSION}]`,
      "TASK=EDIT_NOTE",
      `ACTIVE_FILE=${openFilePath || openSelection.filePath}`,
      `SELECTION_FILE=${openSelection.filePath}`,
      `SELECTION_RANGE=${openSelection.fromOffset}-${openSelection.toOffset}`,
      `SELECTION_HASH=${openSelection.selectionHash}`,
      `HEADER=${CODER_PROMPT_CONTRACT_SELECTION_HEADER}`,
      `MAX_CHANGED_LINES=${MAX_SELECTION_DIFF_CHANGED_LINES}`,
      `MAX_HUNKS=${MAX_SELECTION_DIFF_HUNKS}`,
      "",
      "[REQUEST]",
      question,
      "",
      "[CURRENT_SELECTION]",
      "```text",
      selectionPreview,
      "```",
      "",
      "[SOURCE_EXCERPTS]",
      this.buildLocalQaSourceContext(sourceBlocks),
      "",
      "[OUTPUT_TEMPLATE]",
      `${CODER_PROMPT_CONTRACT_SELECTION_HEADER}`,
      "@@ -oldStart,oldCount +newStart,newCount @@",
      " <space/context>",
      "-old line",
      "+new line"
    ].join("\n");
    let lastCandidate = draftAnswer;
    for (let attempt = 0; attempt < maxAttempts; attempt += 1) {
      const model = attemptModels[attempt];
      if (!model) {
        continue;
      }
      if (attempt > 0 && routingLog && typeof routingLog === "object") {
        routingLog.fallbackUsed = true;
      }
      try {
        this.emitQaEvent(
          onEvent,
          "generation",
          `Selection-diff planner attempt ${attempt + 1}/${maxAttempts} (${model})`
        );
        const completion = await this.requestLocalQaCompletion({
          qaBaseUrl,
          qaModel: model,
          systemPrompt,
          userPrompt,
          history: [],
          onEvent,
          abortSignal
        });
        const split = splitThinkingBlocks(completion.answer);
        const candidate = split.answer.trim() || completion.answer.trim();
        if (!candidate) {
          continue;
        }
        lastCandidate = candidate;
        if (routingLog && typeof routingLog === "object" && !routingLog.modelUsed.includes(model)) {
          routingLog.modelUsed.push(model);
        }
        const contractDiff = this.parseSelectionDiffContractDiff(candidate);
        if (!contractDiff.ok) {
          this.emitQaEvent(onEvent, "warning", "Selection-diff contract violation", {
            detail: contractDiff.error || "Output must be unified diff only."
          });
          continue;
        }
        const validation = this.validateSelectionDiffActionAgainstOpenSelection(
          {
            type: "apply_selection_diff",
            path: openSelection.filePath,
            expectedSelectionHash: openSelection.selectionHash,
            diff: contractDiff.diffWithHeader,
            maxChangedLines: MAX_SELECTION_DIFF_CHANGED_LINES,
            maxHunks: MAX_SELECTION_DIFF_HUNKS
          },
          openSelection
        );
        if (!validation.ok) {
          this.emitQaEvent(onEvent, "warning", "Selection-diff contract validation failed", {
            detail: validation.error || "Failed contract validation."
          });
          continue;
        }
        const wrappedAnswer = this.buildSelectionDiffActionAnswerFromContractDiff(
          openSelection,
          contractDiff.diffWithHeader
        );
        lastCandidate = wrappedAnswer;
        if (this.hasValidSelectionDiffActionInAnswer(wrappedAnswer, question, qaModel, openSelection)) {
          if (attempt > 0) {
            this.emitQaEvent(onEvent, "warning", "Selection-diff planner used fallback model.");
          }
          this.emitQaEvent(onEvent, "generation", "Selection-diff planner retry applied");
          return wrappedAnswer;
        }
      } catch (error) {
        if (this.isAbortError(error)) {
          throw error;
        }
        const message = error instanceof Error ? error.message : "Unknown selection-diff planner error";
        this.emitQaEvent(onEvent, "warning", "Selection-diff planner attempt failed", {
          detail: message
        });
      }
    }
    this.emitQaEvent(
      onEvent,
      "warning",
      "Selection-diff planner failed to produce valid unified diff action."
    );
    return lastCandidate || draftAnswer;
  }
  async applyGameBuildScaffoldPass(params) {
    const { question, answer, sourceBlocks, qaBaseUrl, onEvent, abortSignal } = params;
    let passModel = this.resolvePassModelOrWarn("coder", onEvent);
    if (!passModel) {
      passModel = this.resolvePassModelOrWarn("orchestrator", onEvent);
    }
    if (!passModel) {
      return answer;
    }
    this.emitQaEvent(onEvent, "generation", `Running game scaffold pass (${passModel})`);
    const systemPrompt = [
      "You are a game scaffold builder.",
      "Return markdown only.",
      "Produce runnable starter code with minimal playable loop.",
      "Must include: objective, file structure, full code blocks per file, run/test commands.",
      "Prefer simple web stack (HTML/CSS/JS) unless user requested another engine.",
      "Keep scope to a 20-minute learning game when user requests educational game."
    ].join("\n");
    const userPrompt = [
      `Question: ${question}`,
      "",
      "Draft answer:",
      answer,
      "",
      "Source excerpts:",
      this.buildLocalQaSourceContext(sourceBlocks)
    ].join("\n");
    try {
      const improved = await this.requestLocalQaCompletion({
        qaBaseUrl,
        qaModel: passModel,
        systemPrompt,
        userPrompt,
        history: [],
        abortSignal
      });
      const split = splitThinkingBlocks(improved.answer);
      const normalized = split.answer.trim() || improved.answer.trim();
      if (normalized.length > 0 && this.hasRunnableGameScaffold(normalized)) {
        this.emitQaEvent(onEvent, "generation", "Game scaffold pass applied");
        return normalized;
      }
      this.emitQaEvent(onEvent, "warning", "Game scaffold pass returned non-runnable structure");
      return answer;
    } catch (error) {
      if (this.isAbortError(error)) {
        throw error;
      }
      const message = error instanceof Error ? error.message : "Unknown game scaffold error";
      this.emitQaEvent(onEvent, "warning", "Game scaffold pass failed", { detail: message });
      return answer;
    }
  }
  resolveQaPrimaryRole() {
    return this.settings.qaRolePreset;
  }
  getQaRoleModelOverride(role) {
    switch (role) {
      case "ask":
        return this.settings.qaAskModel;
      case "ask_vision":
        return this.settings.qaAskVisionModel;
      case "image_generator":
        return this.settings.qaImageGeneratorModel;
      case "coder":
        return this.settings.qaCoderModel;
      case "debugger":
        return this.settings.qaDebuggerModel;
      case "architect":
        return this.settings.qaArchitectModel;
      case "orchestrator":
        return this.settings.qaOrchestratorModel;
      case "safeguard":
        return this.settings.qaSafeguardModel;
      default:
        return "";
    }
  }
  resolveQaModelForRole(role) {
    const roleModel = this.getQaRoleModelOverride(role).trim();
    const qa = this.settings.qaOllamaModel.trim();
    const fallback = this.settings.ollamaModel.trim();
    if (this.getQaChatModelFamilyForQa() === "cloud") {
      return qa || roleModel || fallback;
    }
    return roleModel || qa || fallback;
  }
  isVisionCapableModel(modelName) {
    return VISION_MODEL_REGEX.test(modelName.toLowerCase());
  }
  resolveVisionModelForImageAttachments() {
    var _a;
    const detected = this.getDetectedOllamaModelNames();
    const isDetectedOrUnknown = (model) => detected.length === 0 || detected.includes(model);
    const explicitVision = this.settings.qaAskVisionModel.trim();
    if (explicitVision && this.isVisionCapableModel(explicitVision) && isDetectedOrUnknown(explicitVision)) {
      return explicitVision;
    }
    const roleOptions = this.getRoleModelOptionsForQa("ask_vision");
    const recommendedVision = roleOptions.filter((option) => option.status !== "unavailable").map((option) => option.model).sort((a, b) => {
      const aLlamaVision = /llama3\.2-vision/i.test(a);
      const bLlamaVision = /llama3\.2-vision/i.test(b);
      if (aLlamaVision !== bLlamaVision) {
        return aLlamaVision ? -1 : 1;
      }
      return a.localeCompare(b);
    }).find(
      (model) => this.isVisionCapableModel(model) && isDetectedOrUnknown(model)
    );
    if (recommendedVision) {
      return recommendedVision;
    }
    const qaModel = this.settings.qaOllamaModel.trim();
    if (qaModel && this.isVisionCapableModel(qaModel) && isDetectedOrUnknown(qaModel)) {
      return qaModel;
    }
    const baseModel = this.settings.ollamaModel.trim();
    if (baseModel && this.isVisionCapableModel(baseModel) && isDetectedOrUnknown(baseModel)) {
      return baseModel;
    }
    const detectedVision = detected.filter((name) => this.isVisionCapableModel(name)).sort((a, b) => {
      const aLlamaVision = /llama3\.2-vision/i.test(a);
      const bLlamaVision = /llama3\.2-vision/i.test(b);
      if (aLlamaVision !== bLlamaVision) {
        return aLlamaVision ? -1 : 1;
      }
      return a.localeCompare(b);
    });
    return (_a = detectedVision[0]) != null ? _a : null;
  }
  shouldUseLightweightQaPipeline(question, intent) {
    const mode = this.settings.qaConversationMode;
    if (mode === "orchestration" || mode === "plan") {
      return false;
    }
    if (mode === "agent") {
      return true;
    }
    if (intent === "plan" || intent === "comparison") {
      return false;
    }
    const normalized = question.trim().toLowerCase();
    if (!normalized) {
      return true;
    }
    if (normalized.length > 120 || normalized.includes("\n")) {
      return false;
    }
    const complexitySignals = /(계획서|보고서|로드맵|발표|아키텍처|구조|구현|리팩터|디버그|오류 분석|체크리스트|단계별|pipeline|orchestrator|roadmap|report|architecture|design|debug|refactor|checklist|step[- ]by[- ]step|trade[- ]?off)/i;
    if (complexitySignals.test(normalized)) {
      return false;
    }
    const directQuestionSignals = /(무엇|뭐야|뜻|정의|요약|간단|짧게|한줄|차이|why|what is|meaning|summary|brief|quick answer|difference)/i;
    if (directQuestionSignals.test(normalized)) {
      return true;
    }
    return normalized.split(/\s+/).length <= 14;
  }
  shouldRunOrchestratorPassLegacy(question, intent) {
    if (this.settings.qaRolePreset === "orchestrator") {
      return true;
    }
    if (!this.settings.qaOrchestratorEnabled) {
      return false;
    }
    return this.isOrchestrationTask(question, intent);
  }
  shouldRunSafeguardPassLegacy(question, intent) {
    if (this.settings.qaRolePreset === "safeguard") {
      return true;
    }
    if (this.settings.qaSafeguardPassEnabled) {
      return true;
    }
    const normalized = question.toLowerCase();
    if (intent === "comparison" || intent === "plan") {
      return true;
    }
    return /(보안|security|개인정보|privacy|위험|risk|규정|compliance|정책|safety)/i.test(normalized);
  }
  shouldRunRolePresetRefinementForRole(role) {
    return role === "coder" || role === "architect" || role === "debugger";
  }
  resolveLegacyAutoPipelineStages(question, intent) {
    const stages = [];
    if (this.shouldRunRolePresetRefinementForRole(this.settings.qaRolePreset)) {
      if (this.settings.qaRolePreset === "architect") {
        stages.push("architect");
      } else if (this.settings.qaRolePreset === "debugger") {
        stages.push("debugger");
      } else {
        stages.push("coder");
      }
    }
    if (this.shouldRunOrchestratorPassLegacy(question, intent)) {
      stages.push("orchestrator");
    }
    if (this.shouldRunSafeguardPassLegacy(question, intent)) {
      stages.push("safeguard");
    }
    return [...new Set(stages)];
  }
  resolveOrchestratorAutoRouteStages(question, intent) {
    const stages = ["orchestrator"];
    const normalized = question.toLowerCase();
    const debugSignals = /(버그|오류|에러|예외|실패|고장|재현|원인|로그|debug|bug|error|exception|trace|crash|failure)/i;
    const codingSignals = /(코드|구현|함수|클래스|리팩터|테스트|스크립트|쿼리|api|endpoint|typescript|javascript|python|sql|regex|algorithm|implement|code|refactor|test|게임|game|gameplay|unity|godot|pygame|phaser)/i;
    const architectureSignals = /(아키텍처|설계|구조|시스템|모듈|컴포넌트|인터페이스|확장성|trade[- ]?off|architecture|design|scalability|boundary|topology|pattern)/i;
    const safeguardSignals = /(보안|개인정보|규정|정책|위험|컴플라이언스|security|privacy|compliance|policy|risk|safety)/i;
    const wantsDebug = debugSignals.test(normalized);
    const wantsGameBuild = this.matchesGameBuildIntent(question);
    const wantsCoding = codingSignals.test(normalized) || wantsGameBuild;
    const wantsArchitecture = architectureSignals.test(normalized) || wantsGameBuild || intent === "plan" || intent === "comparison";
    const wantsSafeguard = safeguardSignals.test(normalized);
    if (wantsArchitecture) {
      stages.push("architect");
    }
    if (wantsDebug) {
      stages.push("debugger");
    } else if (wantsCoding) {
      stages.push("coder");
    }
    if (wantsGameBuild) {
      stages.push("coder");
    }
    if (wantsSafeguard || intent === "plan" || intent === "comparison" || this.settings.qaSafeguardPassEnabled || stages.length === 1) {
      stages.push("safeguard");
    }
    return [...new Set(stages)];
  }
  resolveQaPipelineStages(question, intent) {
    switch (this.settings.qaPipelinePreset) {
      case "orchestrator_safeguard":
        return ["orchestrator", "safeguard"];
      case "orchestrator_auto_route":
        return this.resolveOrchestratorAutoRouteStages(question, intent);
      case "orchestrator_coder_safeguard":
        return ["orchestrator", "coder", "safeguard"];
      case "orchestrator_architect_safeguard":
        return ["orchestrator", "architect", "safeguard"];
      case "orchestrator_architect_coder_safeguard":
        return ["orchestrator", "architect", "coder", "safeguard"];
      case "legacy_auto":
      default:
        return this.resolveLegacyAutoPipelineStages(question, intent);
    }
  }
  buildRolePresetRefinementInstruction(role) {
    switch (role) {
      case "coder":
        return "Refine draft as a Coder: produce implementation-ready steps, concrete code/data structure guidance, and verification checklist.";
      case "architect":
        return "Refine draft as an Architect: emphasize design options, trade-offs, interface boundaries, phased rollout, and maintainability.";
      case "debugger":
        return "Refine draft as a Debugger: prioritize reproducible diagnosis path, likely root causes, test matrix, and rollback-safe fixes.";
      default:
        return "Refine draft while preserving factual grounding.";
    }
  }
  getQaRolePresetInstruction(role) {
    switch (role) {
      case "orchestrator":
        return "Role preset: Orchestrator. Break work into phases, dependencies, risks, and clear execution order.";
      case "coder":
        return "Role preset: Coder. For EDIT_NOTE tasks, output unified diff only with CURRENT_SELECTION header, no path headers, and no frontmatter edits.";
      case "debugger":
        return "Role preset: Debugger. Prioritize root-cause analysis, reproducible checks, and verification steps.";
      case "architect":
        return "Role preset: Architect. Emphasize system design trade-offs, interfaces, scalability, and maintainability.";
      case "safeguard":
        return "Role preset: Safeguard. Prioritize security, privacy, and failure-mode analysis before recommendations.";
      case "ask_vision":
        return "Role preset: Ask (Vision). Prefer descriptions suitable for image-aware models while staying source-grounded.";
      case "image_generator":
        return "Role preset: Image generator. Describe prompts/specs for image generation, but keep claims grounded in sources.";
      case "ask":
      default:
        return "Role preset: Ask. Balanced assistant mode with concise, useful structure.";
    }
  }
  getQaRoleSystemPrompt(role) {
    return this.getQaRoleSystemPromptForQa(role).trim();
  }
  getQaPreferredLanguageInstruction() {
    switch (this.settings.qaPreferredResponseLanguage) {
      case "korean":
        return "Always answer in Korean unless user explicitly requests another language.";
      case "english":
        return "Always answer in English unless user explicitly requests another language.";
      case "auto":
      default:
        return "Use the same language as the user's question.";
    }
  }
  isLikelyKoreanResponse(text) {
    var _a, _b;
    const value = text.trim();
    if (!value) {
      return false;
    }
    const hangulMatches = (_a = value.match(/[가-힣]/g)) != null ? _a : [];
    const latinMatches = (_b = value.match(/[A-Za-z]/g)) != null ? _b : [];
    if (hangulMatches.length >= 18) {
      return true;
    }
    if (hangulMatches.length === 0) {
      return false;
    }
    return hangulMatches.length >= Math.max(8, Math.floor(latinMatches.length * 0.35));
  }
  async enforcePreferredLanguageIfNeeded(params) {
    const { answer, question, qaBaseUrl, qaModel, onEvent, abortSignal } = params;
    const trimmed = answer.trim();
    if (!trimmed || this.settings.qaPreferredResponseLanguage !== "korean") {
      return answer;
    }
    if (this.isLikelyKoreanResponse(trimmed)) {
      return answer;
    }
    this.emitQaEvent(
      onEvent,
      "warning",
      "Answer language drift detected; retrying final output in Korean."
    );
    const systemPrompt = [
      "You are a strict Korean localization editor.",
      "Return Korean only.",
      "Preserve markdown structure, bullet order, checkboxes, tables, and source citations.",
      "Do not add new facts; if uncertain keep original uncertainty wording.",
      "Keep code blocks and inline code as-is unless plain-language comments require translation.",
      "Output only the localized final answer."
    ].join("\n");
    const userPrompt = [
      `Original user question: ${question}`,
      "",
      "Rewrite the following answer in Korean:",
      trimmed
    ].join("\n");
    try {
      const localized = await this.requestLocalQaCompletion({
        qaBaseUrl,
        qaModel,
        systemPrompt,
        userPrompt,
        history: [],
        onEvent,
        abortSignal
      });
      const split = splitThinkingBlocks(localized.answer);
      const normalized = split.answer.trim() || localized.answer.trim();
      if (normalized && this.isLikelyKoreanResponse(normalized)) {
        this.emitQaEvent(onEvent, "generation", "Korean language guard applied");
        return normalized;
      }
      this.emitQaEvent(onEvent, "warning", "Korean language guard did not improve output");
      return answer;
    } catch (error) {
      if (this.isAbortError(error)) {
        throw error;
      }
      const message = error instanceof Error ? error.message : "Unknown language guard error";
      this.emitQaEvent(onEvent, "warning", "Korean language guard failed", {
        detail: message
      });
      return answer;
    }
  }
  getQaAgentToolInstructionLines() {
    if (!this.settings.qaAgentToolModeEnabled) {
      return [];
    }
    const allowlist = this.parseQaAgentAbsoluteAllowlist();
    const fullAccess = this.settings.qaAgentShellFullAccess;
    const allowlistText = allowlist.length > 0 ? allowlist.join(", ") : "(vault only)";
    const shellLine = this.settings.qaAgentAllowShellTool ? "- run_shell: execute a local shell command (`command` required, `cwd` optional)." : "- run_shell: unavailable (disabled by settings).";
    const shellScopeLine = fullAccess ? "Shell access scope: FULL ACCESS enabled (danger). Any absolute cwd is allowed." : `Shell allowlist roots: ${allowlistText}`;
    return [
      "Agent tool mode is enabled.",
      shellScopeLine,
      "If an action is required, append ONE fenced code block using language `omni-forge-actions` and strict JSON:",
      '{ "actions": [ ... ] }',
      "Supported actions:",
      "- read_note: read file content (`path` required; vault-relative or allowed absolute path).",
      "- write_note: overwrite/create file (`path`, `content` required; vault-relative or allowed absolute path).",
      "- append_note: append to file (`path`, `content` required; vault-relative or allowed absolute path).",
      "- delete_note: delete file (`path` required; vault-relative or allowed absolute path).",
      '- list_folder: list folder (`path` required; use "." for vault root, or allowed absolute path).',
      "- apply_selection_diff: apply unified diff to CURRENT open selection only (`diff` required, `path` optional).",
      `- apply_selection_diff diff must start with header line: ${CODER_PROMPT_CONTRACT_SELECTION_HEADER}.`,
      "- apply_selection_diff must be selection-only patch: no `diff --git`, `---`, `+++` path headers.",
      "- apply_selection_diff default is strict dry-run; fuzzy apply is blocked unless `allowFuzzy: true` is explicitly set.",
      shellLine,
      "Action schema examples:",
      '{ "type": "read_note", "path": "Projects/TODO.md" }',
      '{ "type": "read_note", "path": "/absolute/path/project/README.md" }',
      '{ "type": "write_note", "path": "Projects/plan.md", "content": "# Plan" }',
      '{ "type": "append_note", "path": "Daily/2026-02-16.md", "content": "\\n- done" }',
      '{ "type": "delete_note", "path": "Daily/old-note.md" }',
      '{ "type": "list_folder", "path": "." }',
      `{ "type": "apply_selection_diff", "path": "Notes/active.md", "expectedSelectionHash": "abcd1234", "diff": "${CODER_PROMPT_CONTRACT_SELECTION_HEADER}\\n@@ -1,2 +1,2 @@\\n-old\\n+new", "allowFuzzy": false }`,
      '{ "type": "run_shell", "command": "npm run check", "cwd": "obsidian-plugin/omni-forge", "timeoutSec": 20 }',
      "If prompt includes an active open markdown file path and user says 'this note/current note/이 노트', use that exact path.",
      `For selection edits, use apply_selection_diff + unified diff with ${CODER_PROMPT_CONTRACT_SELECTION_HEADER} header. Do not rewrite whole file.`,
      "Diff must stay inside given selection range. If out-of-range, or if frontmatter would change, regenerate diff.",
      "For frontmatter delete requests, propose actionable write/delete steps. Avoid read-only plans.",
      "When actions are included, keep non-action answer brief and focused.",
      "Never include multiple action blocks."
    ];
  }
  buildLocalQaSystemPrompt(intent, preferDetailed, hasSourceContext, roleOverride, question = "") {
    const role = roleOverride != null ? roleOverride : this.resolveQaPrimaryRole();
    const toneLine = preferDetailed ? "Keep tone natural, direct, and sufficiently detailed." : "Keep tone natural, direct, and concise.";
    return [
      "You are a local-note assistant for Obsidian.",
      hasSourceContext ? "Answer only from the provided sources." : "No note sources were provided for this turn. You may answer from general knowledge with explicit uncertainty notes.",
      this.getQaPreferredLanguageInstruction(),
      this.getQaConversationModeInstruction(),
      ...this.getQaAgentToolInstructionLines(),
      this.getQaRolePresetInstruction(role),
      toneLine,
      "Output in markdown.",
      hasSourceContext ? "When making claims, cite source paths inline in parentheses." : "Do not fabricate source citations when no source context is provided.",
      "If evidence is insufficient, state it clearly and do not invent facts.",
      ...this.getQaContractLines(intent, preferDetailed, this.settings.qaConversationMode, question),
      this.getQaRoleSystemPrompt(role) ? `Role system prompt (${role}):
${this.getQaRoleSystemPrompt(role)}` : "",
      this.settings.qaCustomSystemPrompt.trim() ? `Custom system prompt:
${this.settings.qaCustomSystemPrompt.trim()}` : ""
    ].filter((line) => line.length > 0).join("\n");
  }
  buildLocalQaUserPrompt(question, sourceContext, selectionInventoryContext, attachmentLabels = [], activeOpenFilePath = "", activeOpenSelection = null) {
    const sourceBlock = sourceContext.trim() || "(no source excerpts provided)";
    const hasVisionAttachment = attachmentLabels.some(
      (label) => label.startsWith("[IMG]") || label.startsWith("[PDF]")
    );
    const attachmentBlock = attachmentLabels.length > 0 ? [
      "",
      "Attachments for this turn (highest priority evidence):",
      ...attachmentLabels.map((label) => `- ${label}`)
    ] : [];
    const attachmentPriorityLine = attachmentLabels.length > 0 ? "Priority rule (strict): treat attachments as PRIMARY evidence. Use selected-note excerpts only as SECONDARY fallback when attachment evidence is missing." : "";
    const imageHandlingLine = hasVisionAttachment ? "Image/PDF attachments are already included in this request. Do not ask user for local file paths." : "";
    const activeFilePath = activeOpenFilePath.trim();
    const activeFileBlock = activeFilePath ? [
      "",
      `Active open markdown file: ${activeFilePath}`,
      "If user says 'this note/current note/이 노트', treat it as the active open markdown file path above."
    ] : [];
    const selectionTextRaw = activeOpenSelection && typeof activeOpenSelection.selectedText === "string" ? activeOpenSelection.selectedText : "";
    const selectionPreview = selectionTextRaw ? this.trimQaToolText(selectionTextRaw, MAX_SELECTION_DIFF_CONTEXT_CHARS) : "";
    const selectionBlock = activeOpenSelection && selectionPreview ? [
      "",
      `Active open selection target: ${activeOpenSelection.filePath}`,
      `Selection range (offset): ${activeOpenSelection.fromOffset}-${activeOpenSelection.toOffset}`,
      `Selection hash: ${activeOpenSelection.selectionHash}`,
      `For EDIT_NOTE tasks, return unified diff with ${CODER_PROMPT_CONTRACT_SELECTION_HEADER} header that applies ONLY to this selected text.`,
      "If any hunk goes outside this selection range, or frontmatter would change, regenerate diff. Never use path-based multi-file diff headers.",
      "Selected text (PRIMARY edit target):",
      "```text",
      selectionPreview,
      "```"
    ] : [];
    const inventoryBlock = (selectionInventoryContext == null ? void 0 : selectionInventoryContext.trim()) ? ["", "Selection inventory metadata:", selectionInventoryContext.trim()] : [];
    return [
      `Question: ${question}`,
      "",
      attachmentPriorityLine,
      imageHandlingLine,
      ...activeFileBlock,
      ...selectionBlock,
      "Sources:",
      sourceBlock,
      ...attachmentBlock,
      ...inventoryBlock
    ].filter((line) => line.length > 0).join("\n");
  }
  buildLocalQaGeneratePrompt(systemPrompt, userPrompt, history) {
    const historyText = history.length > 0 ? history.slice(-6).map(
      (turn) => `${turn.role === "assistant" ? "Assistant" : "User"}: ${turn.text}`
    ).join("\n") : "(none)";
    return [
      "System instructions:",
      systemPrompt,
      "",
      "Conversation so far:",
      historyText,
      "",
      userPrompt
    ].join("\n");
  }
  buildLocalQaChatMessages(systemPrompt, userPrompt, history, userImages = []) {
    const messages = [
      { role: "system", content: systemPrompt }
    ];
    for (const turn of history.slice(-6)) {
      messages.push({
        role: turn.role,
        content: turn.text
      });
    }
    messages.push({
      role: "user",
      content: userPrompt,
      images: userImages.length > 0 ? userImages : void 0
    });
    return messages;
  }
  extractQaTextFromUnknownContent(content) {
    if (typeof content === "string") {
      return content;
    }
    if (Array.isArray(content)) {
      return content.map((item) => this.extractQaTextFromUnknownContent(item)).filter((item) => item.length > 0).join("\n");
    }
    if (!content || typeof content !== "object") {
      return "";
    }
    const parsed = content;
    if (typeof parsed.text === "string") {
      return parsed.text;
    }
    if (typeof parsed.output_text === "string") {
      return parsed.output_text;
    }
    if (typeof parsed.content === "string") {
      return parsed.content;
    }
    if (Array.isArray(parsed.content)) {
      return this.extractQaTextFromUnknownContent(parsed.content);
    }
    if (typeof parsed.message === "string") {
      return parsed.message;
    }
    if (typeof parsed.input_text === "string") {
      return parsed.input_text;
    }
    return "";
  }
  buildCloudQaMessages(systemPrompt, userPrompt, history) {
    const messages = [
      { role: "system", content: systemPrompt }
    ];
    for (const turn of history.slice(-6)) {
      messages.push({
        role: turn.role,
        content: turn.text
      });
    }
    messages.push({
      role: "user",
      content: userPrompt
    });
    return messages;
  }
  async resolveCodexCliExecutable() {
    if (await this.isShellCommandAvailable("codex")) {
      return "codex";
    }
    const absoluteCandidates = [
      "/Users/piman/.local/bin/codex",
      "/opt/homebrew/bin/codex",
      "/usr/local/bin/codex"
    ];
    for (const candidate of absoluteCandidates) {
      try {
        await nodeFs.promises.access(candidate);
        return candidate;
      } catch (e) {
      }
    }
    return null;
  }
  async requestCodexCliCompletion(params) {
    const {
      qaModel,
      systemPrompt,
      userPrompt,
      history,
      onToken,
      onEvent,
      abortSignal
    } = params;
    if (abortSignal == null ? void 0 : abortSignal.aborted) {
      throw new DOMException("The operation was aborted.", "AbortError");
    }
    const codexBin = await this.resolveCodexCliExecutable();
    if (!codexBin) {
      throw new Error("codex CLI is not available on PATH. Install Codex CLI or set OpenAI API key.");
    }
    const historyText = history.length > 0 ? history.slice(-6).map(
      (turn) => `${turn.role === "assistant" ? "Assistant" : "User"}: ${turn.text}`
    ).join("\n") : "(none)";
    const prompt = [
      "System instructions:",
      systemPrompt,
      "",
      "Conversation so far:",
      historyText,
      "",
      userPrompt
    ].join("\n");
    const tempRoot = await nodeFs.promises.mkdtemp(
      nodePath.join(nodeOs.tmpdir(), "omni-forge-codex-")
    );
    try {
      const promptPath = nodePath.join(tempRoot, "prompt.txt");
      const outputPath = nodePath.join(tempRoot, "answer.txt");
      await nodeFs.promises.writeFile(promptPath, prompt, "utf8");
      const command = [
        this.shellQuoteArg(codexBin),
        "exec",
        "--skip-git-repo-check",
        "--model",
        this.shellQuoteArg(qaModel),
        "--output-last-message",
        this.shellQuoteArg(outputPath),
        "-",
        "<",
        this.shellQuoteArg(promptPath)
      ].join(" ");
      this.emitQaEvent(onEvent, "generation", "Using local codex CLI fallback (codex exec)");
      const result = await execAsync(command, {
        timeout: 24e4,
        maxBuffer: 8 * 1024 * 1024
      });
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        throw new DOMException("The operation was aborted.", "AbortError");
      }
      let answer = "";
      try {
        answer = (await nodeFs.promises.readFile(outputPath, "utf8")).trim();
      } catch (e) {
      }
      if (!answer) {
        answer = (result.stdout || "").trim();
      }
      if (!answer) {
        throw new Error("codex exec returned empty output.");
      }
      onToken == null ? void 0 : onToken(answer);
      return {
        answer,
        thinking: "",
        endpoint: "codex-exec"
      };
    } finally {
      await nodeFs.promises.rm(tempRoot, { recursive: true, force: true }).catch(() => {
      });
    }
  }
  extractCloudChatCompletionAnswer(payload) {
    var _a, _b, _c, _d;
    const firstChoice = Array.isArray(payload == null ? void 0 : payload.choices) ? payload.choices[0] : null;
    const messageText = this.extractQaTextFromUnknownContent((_a = firstChoice == null ? void 0 : firstChoice.message) == null ? void 0 : _a.content).trim();
    if (messageText) {
      return messageText;
    }
    const choiceText = this.extractQaTextFromUnknownContent(firstChoice == null ? void 0 : firstChoice.text).trim();
    if (choiceText) {
      return choiceText;
    }
    const outputText = this.extractQaTextFromUnknownContent(payload == null ? void 0 : payload.output_text).trim();
    if (outputText) {
      return outputText;
    }
    const deltaText = this.extractQaTextFromUnknownContent(
      (_d = (_c = (_b = firstChoice == null ? void 0 : firstChoice.delta) == null ? void 0 : _b.content) != null ? _c : firstChoice == null ? void 0 : firstChoice.delta) != null ? _d : ""
    ).trim();
    return deltaText;
  }
  extractCloudResponsesAnswer(payload) {
    const outputText = this.extractQaTextFromUnknownContent(payload == null ? void 0 : payload.output_text).trim();
    if (outputText) {
      return outputText;
    }
    if (Array.isArray(payload == null ? void 0 : payload.output)) {
      const merged = payload.output.map((item) => this.extractQaTextFromUnknownContent(item == null ? void 0 : item.content)).filter((item) => item.length > 0).join("\n").trim();
      if (merged) {
        return merged;
      }
    }
    if (Array.isArray(payload == null ? void 0 : payload.data)) {
      const merged = payload.data.map((item) => this.extractQaTextFromUnknownContent(item == null ? void 0 : item.output)).filter((item) => item.length > 0).join("\n").trim();
      if (merged) {
        return merged;
      }
    }
    return this.extractCloudChatCompletionAnswer(payload);
  }
  summarizeCloudErrorPayloadForQa(rawPayload) {
    const raw = typeof rawPayload === "string" ? rawPayload.trim() : "";
    if (!raw) {
      return "";
    }
    try {
      const parsed = JSON.parse(raw);
      const detail = [
        parsed == null ? void 0 : parsed.error_description,
        parsed == null ? void 0 : parsed.error,
        parsed == null ? void 0 : parsed.message,
        (parsed == null ? void 0 : parsed.error) && typeof parsed.error === "object" ? parsed.error.message : ""
      ].find((value) => typeof value === "string" && value.trim().length > 0);
      if (typeof detail === "string" && detail.trim()) {
        const compact = detail.trim().replace(/\s+/g, " ");
        return compact.length > 180 ? `${compact.slice(0, 180)}...` : compact;
      }
    } catch (e) {
    }
    const compactRaw = raw.replace(/\s+/g, " ");
    return compactRaw.length > 180 ? `${compactRaw.slice(0, 180)}...` : compactRaw;
  }
  async requestCloudQaCompletion(params) {
    const {
      qaBaseUrl,
      qaModel,
      systemPrompt,
      userPrompt,
      history,
      images,
      onToken,
      onEvent,
      abortSignal
    } = params;
    const oauthBridgeEnabled = this.settings.oauthBridgeEnabled === true;
    const oauthEnabled = this.settings.oauthEnabled === true;
    if (oauthEnabled) {
      await this.tryAutoOAuthLoginForQa("requestCloudQaCompletion");
    }
    const oauthBridgeBase = this.settings.oauthBridgeBaseUrl.trim();
    const requestBase = oauthBridgeEnabled ? oauthBridgeBase || qaBaseUrl : qaBaseUrl;
    const base = toOpenAICompatibleBase(requestBase);
    const headers = {
      "Content-Type": "application/json"
    };
    const profile = this.getQaChatModelProfileForQa();
    const configuredProfileModel = (profile === "claude" ? this.settings.anthropicModel : profile === "gemini" ? this.settings.geminiModel : this.settings.openAIModel).trim();
    const oauthBridgeModel = this.settings.oauthBridgeModel.trim();
    const effectiveModel = oauthBridgeModel || configuredProfileModel || qaModel;
    if (!effectiveModel) {
      throw new Error("Cloud model is empty.");
    }
    const apiKey = (profile === "claude" ? this.settings.anthropicApiKey : profile === "gemini" ? this.settings.geminiApiKey : this.settings.openAIApiKey).trim() || this.settings.openAIApiKey.trim();
    let baseHost = "";
    try {
      baseHost = new URL(base).hostname.toLowerCase();
    } catch (e) {
      baseHost = "";
    }
    const isOpenAiPublicHost = baseHost === "api.openai.com" || baseHost.endsWith(".openai.com");
    const oauthPreset = this.normalizeOAuthProviderPresetForQa(this.settings.oauthProviderPreset);
    if (oauthEnabled && oauthPreset === "google" && !oauthBridgeEnabled && isOpenAiPublicHost) {
      throw new Error(
        "OAuth transport mismatch: Google OAuth token cannot be used directly with api.openai.com in this plugin. Enable OAuth bridge mode or change OpenAI base URL to your OAuth-compatible OpenAI-style endpoint."
      );
    }
    if (!oauthBridgeEnabled && !oauthEnabled && !apiKey && isOpenAiPublicHost) {
      if (profile === "codex") {
        throw new Error(
          "OpenAI codex cloud requires API key in Omni-Forge. OAuth-only mode cannot call api.openai.com directly in this plugin; use local mode or configure a local OpenAI-compatible bridge."
        );
      }
      throw new Error(
        "Cloud request blocked: API key is empty for OpenAI host. Set API key or use a local OpenAI-compatible bridge URL."
      );
    }
    if (oauthEnabled) {
      const oauthHeaders = await this.getOAuthAuthHeadersForQa();
      Object.assign(headers, oauthHeaders);
    } else if (apiKey) {
      headers.Authorization = `Bearer ${apiKey}`;
      headers["x-api-key"] = apiKey;
    }
    if (images && images.length > 0) {
      this.emitQaEvent(
        onEvent,
        "warning",
        "Cloud bridge request is using text/OCR context only for attachments."
      );
    }
    this.emitQaEvent(
      onEvent,
      "generation",
      `Cloud profile=${profile || "codex"}, model=${effectiveModel}${oauthBridgeEnabled ? ", oauthBridge=on" : ""}${oauthEnabled ? ", oauth=on" : ""}`
    );
    const messages = this.buildCloudQaMessages(systemPrompt, userPrompt, history);
    try {
      this.emitQaEvent(onEvent, "generation", "Using OpenAI-compatible /chat/completions endpoint");
      const chatResponse = await fetch(`${base}/chat/completions`, {
        method: "POST",
        headers,
        signal: abortSignal,
        body: JSON.stringify({
          model: effectiveModel,
          messages,
          stream: false
        })
      });
      if (!chatResponse.ok) {
        const errorRaw = await chatResponse.text().catch(() => "");
        const detail = this.summarizeCloudErrorPayloadForQa(errorRaw);
        throw new Error(`Cloud chat completion failed: ${chatResponse.status}${detail ? ` (${detail})` : ""}`);
      }
      const chatRaw = await chatResponse.text();
      let chatPayload = {};
      try {
        chatPayload = chatRaw ? JSON.parse(chatRaw) : {};
      } catch (e) {
        chatPayload = {};
      }
      const answer = this.extractCloudChatCompletionAnswer(chatPayload).trim() || chatRaw.trim();
      if (answer) {
        onToken == null ? void 0 : onToken(answer);
        return {
          answer,
          thinking: "",
          endpoint: "chat.completions"
        };
      }
      throw new Error("Cloud chat completion returned an empty answer.");
    } catch (error) {
      if (this.isAbortError(error)) {
        throw error;
      }
      const message = error instanceof Error ? error.message : "Unknown cloud chat completion error";
      this.emitQaEvent(onEvent, "warning", "Falling back to /responses endpoint", {
        detail: message
      });
    }
    const responsesInput = messages.map((message) => ({
      role: message.role,
      content: [
        {
          type: "input_text",
          text: this.extractQaTextFromUnknownContent(message.content)
        }
      ]
    }));
    const responsesResponse = await fetch(`${base}/responses`, {
      method: "POST",
      headers,
      signal: abortSignal,
      body: JSON.stringify({
        model: effectiveModel,
        input: responsesInput
      })
    });
    if (!responsesResponse.ok) {
      const errorRaw = await responsesResponse.text().catch(() => "");
      const detail = this.summarizeCloudErrorPayloadForQa(errorRaw);
      throw new Error(`Cloud responses request failed: ${responsesResponse.status}${detail ? ` (${detail})` : ""}`);
    }
    const responsesRaw = await responsesResponse.text();
    let responsesPayload = {};
    try {
      responsesPayload = responsesRaw ? JSON.parse(responsesRaw) : {};
    } catch (e) {
      responsesPayload = {};
    }
    const answer = this.extractCloudResponsesAnswer(responsesPayload).trim() || responsesRaw.trim();
    if (!answer) {
      throw new Error("Cloud responses endpoint returned an empty answer.");
    }
    onToken == null ? void 0 : onToken(answer);
    return {
      answer,
      thinking: "",
      endpoint: "responses"
    };
  }
  extractOllamaTokenChunk(payload) {
    let token = "";
    let thinking = "";
    const message = payload.message;
    if (message && typeof message === "object") {
      const parsed = message;
      if (typeof parsed.content === "string") {
        token = parsed.content;
      }
      if (typeof parsed.thinking === "string") {
        thinking = parsed.thinking;
      }
    }
    if (!token && typeof payload.response === "string") {
      token = payload.response;
    }
    if (!thinking && typeof payload.thinking === "string") {
      thinking = payload.thinking;
    }
    return { token, thinking };
  }
  async consumeOllamaJsonLineStream(body, onToken, onEvent, abortSignal) {
    const reader = body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    let answer = "";
    let thinking = "";
    const throwIfAborted = () => {
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        throw new DOMException("The operation was aborted.", "AbortError");
      }
    };
    const cancelReaderOnAbort = () => {
      void reader.cancel("aborted").catch(() => {
      });
    };
    abortSignal == null ? void 0 : abortSignal.addEventListener("abort", cancelReaderOnAbort, { once: true });
    const consumeLine = (line) => {
      throwIfAborted();
      if (!line) {
        return;
      }
      try {
        const parsed = JSON.parse(line);
        const chunk = this.extractOllamaTokenChunk(parsed);
        if (chunk.thinking) {
          thinking += chunk.thinking;
          this.emitQaEvent(onEvent, "thinking", "Model thinking chunk", {
            thinkingChunk: chunk.thinking
          });
        }
        if (chunk.token) {
          answer += chunk.token;
          onToken == null ? void 0 : onToken(chunk.token);
        }
      } catch (e) {
      }
    };
    try {
      while (true) {
        throwIfAborted();
        const { done, value } = await reader.read();
        throwIfAborted();
        if (done) {
          break;
        }
        buffer += decoder.decode(value, { stream: true });
        let lineBreakIndex = buffer.indexOf("\n");
        while (lineBreakIndex >= 0) {
          const line = buffer.slice(0, lineBreakIndex).trim();
          buffer = buffer.slice(lineBreakIndex + 1);
          consumeLine(line);
          lineBreakIndex = buffer.indexOf("\n");
        }
      }
      const tail = buffer.trim();
      if (tail) {
        consumeLine(tail);
      }
    } finally {
      abortSignal == null ? void 0 : abortSignal.removeEventListener("abort", cancelReaderOnAbort);
    }
    return { answer, thinking };
  }
  async requestLocalQaGenerate(params) {
    const {
      qaBaseUrl,
      qaModel,
      prompt,
      images,
      onToken,
      onEvent,
      abortSignal
    } = params;
    const base = qaBaseUrl.replace(/\/$/, "");
    if (onToken) {
      const streamResponse = await fetch(`${base}/api/generate`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        signal: abortSignal,
        body: JSON.stringify({
          model: qaModel,
          prompt,
          images: images && images.length > 0 ? images : void 0,
          stream: true
        })
      });
      if (!streamResponse.ok || !streamResponse.body) {
        throw new Error(`Local Q&A request failed: ${streamResponse.status}`);
      }
      return this.consumeOllamaJsonLineStream(
        streamResponse.body,
        onToken,
        onEvent,
        abortSignal
      );
    }
    if (abortSignal) {
      const response2 = await fetch(`${base}/api/generate`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        signal: abortSignal,
        body: JSON.stringify({
          model: qaModel,
          prompt,
          images: images && images.length > 0 ? images : void 0,
          stream: false
        })
      });
      if (!response2.ok) {
        throw new Error(`Local Q&A request failed: ${response2.status}`);
      }
      const raw = await response2.text();
      let parsed2 = {};
      try {
        parsed2 = raw ? JSON.parse(raw) : {};
      } catch (e) {
        parsed2 = {};
      }
      const chunk2 = this.extractOllamaTokenChunk(parsed2);
      const answer2 = chunk2.token.trim() || raw.trim();
      return {
        answer: answer2,
        thinking: chunk2.thinking.trim()
      };
    }
    const response = await (0, import_obsidian4.requestUrl)({
      url: `${base}/api/generate`,
      method: "POST",
      contentType: "application/json",
      body: JSON.stringify({
        model: qaModel,
        prompt,
        images: images && images.length > 0 ? images : void 0,
        stream: false
      }),
      throw: false
    });
    if (response.status >= 300) {
      throw new Error(`Local Q&A request failed: ${response.status}`);
    }
    const parsed = response.json && typeof response.json === "object" ? response.json : {};
    const chunk = this.extractOllamaTokenChunk(parsed);
    const answer = chunk.token.trim() || response.text.trim();
    return {
      answer,
      thinking: chunk.thinking.trim()
    };
  }
  async requestLocalQaChat(params) {
    const {
      qaBaseUrl,
      qaModel,
      systemPrompt,
      userPrompt,
      history,
      images,
      onToken,
      onEvent,
      abortSignal
    } = params;
    const messages = this.buildLocalQaChatMessages(systemPrompt, userPrompt, history, images);
    const base = qaBaseUrl.replace(/\/$/, "");
    if (onToken) {
      const streamResponse = await fetch(`${base}/api/chat`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        signal: abortSignal,
        body: JSON.stringify({
          model: qaModel,
          messages,
          stream: true
        })
      });
      if (!streamResponse.ok || !streamResponse.body) {
        throw new Error(`Local Q&A chat request failed: ${streamResponse.status}`);
      }
      return this.consumeOllamaJsonLineStream(
        streamResponse.body,
        onToken,
        onEvent,
        abortSignal
      );
    }
    if (abortSignal) {
      const response2 = await fetch(`${base}/api/chat`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        signal: abortSignal,
        body: JSON.stringify({
          model: qaModel,
          messages,
          stream: false
        })
      });
      if (!response2.ok) {
        throw new Error(`Local Q&A chat request failed: ${response2.status}`);
      }
      const raw = await response2.text();
      let parsed2 = {};
      try {
        parsed2 = raw ? JSON.parse(raw) : {};
      } catch (e) {
        parsed2 = {};
      }
      const chunk2 = this.extractOllamaTokenChunk(parsed2);
      const answer2 = chunk2.token.trim() || raw.trim();
      return {
        answer: answer2,
        thinking: chunk2.thinking.trim()
      };
    }
    const response = await (0, import_obsidian4.requestUrl)({
      url: `${base}/api/chat`,
      method: "POST",
      contentType: "application/json",
      body: JSON.stringify({
        model: qaModel,
        messages,
        stream: false
      }),
      throw: false
    });
    if (response.status >= 300) {
      throw new Error(`Local Q&A chat request failed: ${response.status}`);
    }
    const parsed = response.json && typeof response.json === "object" ? response.json : {};
    const chunk = this.extractOllamaTokenChunk(parsed);
    const answer = chunk.token.trim() || response.text.trim();
    return {
      answer,
      thinking: chunk.thinking.trim()
    };
  }
  async requestLocalQaCompletion(params) {
    const {
      qaBaseUrl,
      qaModel,
      systemPrompt,
      userPrompt,
      history,
      images,
      onToken,
      onEvent,
      abortSignal
    } = params;
    const hasImages = Boolean(images && images.length > 0);
    if (this.getQaChatModelFamilyForQa() === "cloud") {
      return this.requestCloudQaCompletion({
        qaBaseUrl,
        qaModel,
        systemPrompt,
        userPrompt,
        history,
        images,
        onToken,
        onEvent,
        abortSignal
      });
    }
    if (hasImages) {
      this.emitQaEvent(
        onEvent,
        "generation",
        "Image attachments detected; using /api/generate endpoint"
      );
    } else if (this.settings.qaPreferChatApi) {
      try {
        this.emitQaEvent(onEvent, "generation", "Using /api/chat endpoint");
        const chatResult = await this.requestLocalQaChat({
          qaBaseUrl,
          qaModel,
          systemPrompt,
          userPrompt,
          history,
          images,
          onToken,
          onEvent,
          abortSignal
        });
        if (chatResult.answer.trim()) {
          return {
            ...chatResult,
            endpoint: "chat"
          };
        }
        this.emitQaEvent(onEvent, "warning", "/api/chat returned an empty answer", {
          detail: "Fallback to /api/generate"
        });
      } catch (error) {
        if (this.isAbortError(error)) {
          throw error;
        }
        const message = error instanceof Error ? error.message : "Unknown /api/chat error";
        this.emitQaEvent(onEvent, "warning", "Falling back to /api/generate", {
          detail: message
        });
      }
    }
    this.emitQaEvent(onEvent, "generation", "Using /api/generate endpoint");
    const prompt = this.buildLocalQaGeneratePrompt(systemPrompt, userPrompt, history);
    let generateResult;
    try {
      generateResult = await this.requestLocalQaGenerate({
        qaBaseUrl,
        qaModel,
        prompt,
        images,
        onToken,
        onEvent,
        abortSignal
      });
    } catch (error) {
      if (this.isAbortError(error)) {
        throw error;
      }
      if (images && images.length > 0) {
        const message = error instanceof Error ? error.message : "Unknown image generate error";
        this.emitQaEvent(onEvent, "warning", "Image input failed; retrying without images", {
          detail: message
        });
        generateResult = await this.requestLocalQaGenerate({
          qaBaseUrl,
          qaModel,
          prompt,
          images: [],
          onToken,
          onEvent,
          abortSignal
        });
      } else {
        throw error;
      }
    }
    return {
      ...generateResult,
      endpoint: "generate"
    };
  }
  buildSourceOnlyFallback(sourceBlocks) {
    const lines = sourceBlocks.slice(0, 8).map((item) => `- [[${item.path}]] (${formatSimilarity(item.similarity)})`);
    return lines.length > 0 ? lines.join("\n") : "- (no sources)";
  }
  async repairQaStructureIfNeeded(params) {
    const {
      intent,
      answer,
      question,
      preferDetailed,
      sourceBlocks,
      qaBaseUrl,
      qaModel,
      onEvent,
      abortSignal
    } = params;
    if (!this.settings.qaStructureGuardEnabled) {
      return answer;
    }
    const needsStructure = this.needsQaStructureRepair(intent, answer);
    const needsDepth = this.needsQaDepthRepair(intent, answer, preferDetailed);
    if (!needsStructure && !needsDepth) {
      return answer;
    }
    this.emitQaEvent(onEvent, "generation", "Applying structured output guard");
    const sourceContext = this.buildLocalQaSourceContext(sourceBlocks);
    const systemPrompt = [
      "You are a markdown structure normalizer for local-note answers.",
      "Keep language identical to the draft answer.",
      "Do not add facts not present in draft answer or provided source excerpts.",
      "Preserve source path citations whenever possible.",
      "Return markdown only.",
      ...this.getQaContractLines(intent, preferDetailed, this.settings.qaConversationMode, question)
    ].join("\n");
    const userPrompt = [
      `Question: ${question}`,
      "",
      "Draft answer:",
      answer,
      "",
      "Source excerpts:",
      sourceContext
    ].join("\n");
    try {
      const repaired = await this.requestLocalQaCompletion({
        qaBaseUrl,
        qaModel,
        systemPrompt,
        userPrompt,
        history: [],
        abortSignal
      });
      const split = splitThinkingBlocks(repaired.answer);
      const normalized = split.answer.trim() || repaired.answer.trim();
      const stillNeedsStructure = this.needsQaStructureRepair(intent, normalized);
      const stillNeedsDepth = this.needsQaDepthRepair(intent, normalized, preferDetailed);
      if (normalized && !stillNeedsStructure && !stillNeedsDepth) {
        this.emitQaEvent(onEvent, "generation", "Structured output guard applied");
        return normalized;
      }
      this.emitQaEvent(onEvent, "warning", "Structured output guard could not enforce format");
    } catch (error) {
      if (this.isAbortError(error)) {
        throw error;
      }
      const message = error instanceof Error ? error.message : "Unknown structure guard error";
      this.emitQaEvent(onEvent, "warning", "Structured output guard failed", {
        detail: message
      });
    }
    if (intent === "sources_only") {
      return this.buildSourceOnlyFallback(sourceBlocks);
    }
    return answer;
  }
  resolvePassModelOrWarn(role, onEvent) {
    let model = this.resolveQaModelForRole(role).trim();
    if (!model) {
      this.emitQaEvent(onEvent, "warning", `Skipping ${role} pass: model is empty`);
      return null;
    }
    const isCloudFamily = this.getQaChatModelFamilyForQa() === "cloud";
    if (isCloudFamily) {
      return model;
    }
    const detected = this.getDetectedOllamaModelNames();
    if (detected.length > 0 && !this.hasDetectedOllamaModel(model)) {
      const fallback = this.resolveDetectedRoleFallbackModel(role);
      if (fallback) {
        this.emitQaEvent(
          onEvent,
          "warning",
          `Pass model not detected (${model}); fallback to ${fallback}`
        );
        model = fallback;
      } else {
        this.emitQaEvent(
          onEvent,
          "warning",
          `Skipping ${role} pass: model not detected (${model})`
        );
        return null;
      }
    }
    if (!isOllamaModelAllowedForQaRole(role, model)) {
      this.emitQaEvent(
        onEvent,
        "warning",
        `Skipping ${role} pass: model is not suitable (${model})`
      );
      return null;
    }
    return model;
  }
  async applyOrchestratorPass(params) {
    const { question, answer, sourceBlocks, qaBaseUrl, onEvent, abortSignal } = params;
    const passModel = this.resolvePassModelOrWarn("orchestrator", onEvent);
    if (!passModel) {
      return answer;
    }
    const roleSystemPrompt = this.getQaRoleSystemPrompt("orchestrator");
    const gameBuildRequested = this.matchesGameBuildIntent(question);
    this.emitQaEvent(onEvent, "generation", `Running orchestrator pass (${passModel})`);
    const systemPrompt = [
      "You are an orchestration editor for local-note answers.",
      "Task: convert draft into execution-ready output without inventing facts.",
      "Keep language aligned with user's preference.",
      "Return markdown only.",
      "When evidence is missing, explicitly mark as '\uC815\uBCF4 \uBD80\uC871'.",
      gameBuildRequested ? "For game-creation requests, preserve game artifact structure (게임명/목표/규칙/승리조건/예시 라운드) and do NOT convert to audit/report summary." : "",
      "Use this structure when suitable:",
      "- Objective and scope",
      "- Core findings",
      "- Execution plan/checklist",
      "- Role coordination summary (architect/coder/debugger/safeguard: responsibility, output, handoff, unresolved)",
      "- Deliverables (report/PPT/materials/code)",
      "- If task requests software/game creation, include runnable scaffold code and file layout.",
      "- Risks and safeguards",
      "- Next actions",
      roleSystemPrompt ? `Role system prompt (orchestrator):
${roleSystemPrompt}` : ""
    ].join("\n");
    const userPrompt = [
      `Question: ${question}`,
      "",
      "Draft answer:",
      answer,
      "",
      "Source excerpts:",
      this.buildLocalQaSourceContext(sourceBlocks)
    ].join("\n");
    try {
      const improved = await this.requestLocalQaCompletion({
        qaBaseUrl,
        qaModel: passModel,
        systemPrompt,
        userPrompt,
        history: [],
        abortSignal
      });
      const split = splitThinkingBlocks(improved.answer);
      const normalized = split.answer.trim() || improved.answer.trim();
      if (normalized.length > 0) {
        this.emitQaEvent(onEvent, "generation", "Orchestrator pass applied");
        return normalized;
      }
      this.emitQaEvent(onEvent, "warning", "Orchestrator pass returned empty output");
      return answer;
    } catch (error) {
      if (this.isAbortError(error)) {
        throw error;
      }
      const message = error instanceof Error ? error.message : "Unknown orchestrator error";
      this.emitQaEvent(onEvent, "warning", "Orchestrator pass failed", { detail: message });
      return answer;
    }
  }
  async applyRolePresetRefinementPass(params) {
    const { role, question, answer, sourceBlocks, qaBaseUrl, onEvent, abortSignal } = params;
    const passModel = this.resolvePassModelOrWarn(role, onEvent);
    if (!passModel) {
      return answer;
    }
    const roleSystemPrompt = this.getQaRoleSystemPrompt(role);
    this.emitQaEvent(onEvent, "generation", `Running ${role} refinement (${passModel})`);
    const systemPrompt = [
      "You are a role-specialized editor for local-note answers.",
      "Keep output factual and grounded in provided sources.",
      "Do not invent facts. Mark uncertain points as '\uC815\uBCF4 \uBD80\uC871'.",
      this.buildRolePresetRefinementInstruction(role),
      "Return markdown only.",
      roleSystemPrompt ? `Role system prompt (${role}):
${roleSystemPrompt}` : ""
    ].join("\n");
    const userPrompt = [
      `Question: ${question}`,
      "",
      "Draft answer:",
      answer,
      "",
      "Source excerpts:",
      this.buildLocalQaSourceContext(sourceBlocks)
    ].join("\n");
    try {
      const rewritten = await this.requestLocalQaCompletion({
        qaBaseUrl,
        qaModel: passModel,
        systemPrompt,
        userPrompt,
        history: [],
        abortSignal
      });
      const split = splitThinkingBlocks(rewritten.answer);
      const normalized = split.answer.trim() || rewritten.answer.trim();
      if (normalized.length > 0) {
        this.emitQaEvent(onEvent, "generation", `${role} refinement applied`);
        return normalized;
      }
      this.emitQaEvent(onEvent, "warning", `${role} refinement returned empty output`);
      return answer;
    } catch (error) {
      if (this.isAbortError(error)) {
        throw error;
      }
      const message = error instanceof Error ? error.message : "Unknown role refinement error";
      this.emitQaEvent(onEvent, "warning", `${role} refinement failed`, {
        detail: message
      });
      return answer;
    }
  }
  async applySafeguardPass(params) {
    const { question, answer, sourceBlocks, qaBaseUrl, onEvent, abortSignal } = params;
    const passModel = this.resolvePassModelOrWarn("safeguard", onEvent);
    if (!passModel) {
      return answer;
    }
    const roleSystemPrompt = this.getQaRoleSystemPrompt("safeguard");
    const gameBuildRequested = this.matchesGameBuildIntent(question);
    this.emitQaEvent(onEvent, "generation", `Running safeguard verification (${passModel})`);
    const systemPrompt = [
      "You are a safeguard verifier for local-note answers.",
      "Validate draft strictly against provided source excerpts.",
      "Remove unsupported claims and overconfident wording.",
      "Keep useful structure but prefer factual correctness and safety.",
      "If evidence is missing, keep statement conservative and explicit.",
      "Preserve source-path citations whenever possible.",
      gameBuildRequested ? "For game-creation requests, keep final answer in game artifact format (게임명/목표/규칙/승리조건/예시 라운드); do not rewrite as risk/audit report." : "",
      "Return final markdown answer only.",
      roleSystemPrompt ? `Role system prompt (safeguard):
${roleSystemPrompt}` : ""
    ].join("\n");
    const userPrompt = [
      `Question: ${question}`,
      "",
      "Draft answer:",
      answer,
      "",
      "Source excerpts:",
      this.buildLocalQaSourceContext(sourceBlocks)
    ].join("\n");
    try {
      const verified = await this.requestLocalQaCompletion({
        qaBaseUrl,
        qaModel: passModel,
        systemPrompt,
        userPrompt,
        history: [],
        abortSignal
      });
      const split = splitThinkingBlocks(verified.answer);
      const normalized = split.answer.trim() || verified.answer.trim();
      if (normalized.length > 0) {
        this.emitQaEvent(onEvent, "generation", "Safeguard verification applied");
        return normalized;
      }
      this.emitQaEvent(onEvent, "warning", "Safeguard pass returned empty output");
      return answer;
    } catch (error) {
      if (this.isAbortError(error)) {
        throw error;
      }
      const message = error instanceof Error ? error.message : "Unknown safeguard error";
      this.emitQaEvent(onEvent, "warning", "Safeguard pass failed", { detail: message });
      return answer;
    }
  }
  async openLocalQaChatModal() {
    await this.openLocalQaWorkspaceView();
  }
  parseQaAgentApprovalCommand(question) {
    const normalized = question.trim().toLowerCase();
    if (!normalized) {
      return null;
    }
    if (/^(\/approve|approve|승인|실행)$/.test(normalized)) {
      return "approve";
    }
    if (/^(\/deny|deny|거부|취소|\/cancel|cancel)$/.test(normalized)) {
      return "deny";
    }
    return null;
  }
  normalizeQaAgentAction(raw) {
    if (!raw || typeof raw !== "object") {
      return null;
    }
    const parsed = raw;
    if (typeof parsed.type !== "string") {
      return null;
    }
    const type = parsed.type.trim();
    const allowedTypes = [
      "read_note",
      "write_note",
      "append_note",
      "delete_note",
      "list_folder",
      "apply_selection_diff",
      "run_shell"
    ];
    if (!allowedTypes.includes(type)) {
      return null;
    }
    const action = { type };
    if (typeof parsed.path === "string") {
      action.path = parsed.path.trim();
    }
    if (typeof parsed.content === "string") {
      action.content = parsed.content;
    }
    if (typeof parsed.command === "string") {
      action.command = parsed.command.trim();
    }
    if (typeof parsed.diff === "string") {
      action.diff = parsed.diff;
    } else if (typeof parsed.patch === "string") {
      action.diff = parsed.patch;
    }
    if (typeof parsed.expectedSelectionHash === "string") {
      action.expectedSelectionHash = parsed.expectedSelectionHash.trim();
    }
    if (typeof parsed.expectedSelectionText === "string") {
      action.expectedSelectionText = parsed.expectedSelectionText;
    }
    if (typeof parsed.cwd === "string") {
      action.cwd = parsed.cwd.trim();
    }
    if (typeof parsed.timeoutSec === "number" && Number.isFinite(parsed.timeoutSec)) {
      action.timeoutSec = Math.floor(parsed.timeoutSec);
    }
    if (typeof parsed.maxChangedLines === "number" && Number.isFinite(parsed.maxChangedLines)) {
      action.maxChangedLines = Math.max(1, Math.floor(parsed.maxChangedLines));
    }
    if (typeof parsed.maxHunks === "number" && Number.isFinite(parsed.maxHunks)) {
      action.maxHunks = Math.max(1, Math.floor(parsed.maxHunks));
    }
    if (typeof parsed.allowFuzzy === "boolean") {
      action.allowFuzzy = parsed.allowFuzzy;
    }
    return action;
  }
  summarizeQaAgentAction(action) {
    switch (action.type) {
      case "read_note":
        return `read_note path=${action.path || "(missing)"}`;
      case "write_note":
        return `write_note path=${action.path || "(missing)"}`;
      case "append_note":
        return `append_note path=${action.path || "(missing)"}`;
      case "delete_note":
        return `delete_note path=${action.path || "(missing)"}`;
      case "list_folder":
        return `list_folder path=${action.path || "(missing)"}`;
      case "apply_selection_diff":
        return `apply_selection_diff path=${action.path || "(selection-context)"}${action.allowFuzzy ? " allowFuzzy=true" : ""}`;
      case "run_shell":
        return `run_shell command=${action.command || "(missing)"}`;
      default:
        return action.type;
    }
  }
  parseQaAgentActionPlanFromAnswer(params) {
    var _a, _b;
    const { answer, question, model } = params;
    const blockRegex = /```omni-forge-actions\s*([\s\S]*?)```/i;
    const match = blockRegex.exec(answer);
    const answerWithoutPlan = answer.replace(blockRegex, "").trim();
    if (!match) {
      return { answerWithoutPlan: answer.trim(), plan: null };
    }
    const jsonText = (_b = (_a = match[1]) == null ? void 0 : _a.trim()) != null ? _b : "";
    if (!jsonText) {
      return {
        answerWithoutPlan,
        plan: null,
        warning: "Agent action block is empty."
      };
    }
    try {
      const parsed = JSON.parse(jsonText);
      const rawActions = Array.isArray(parsed.actions) ? parsed.actions : null;
      if (!rawActions || rawActions.length === 0) {
        return {
          answerWithoutPlan,
          plan: null,
          warning: "Agent action block has no actions array."
        };
      }
      const normalized = rawActions.map((item) => this.normalizeQaAgentAction(item)).filter((item) => Boolean(item));
      if (normalized.length === 0) {
        return {
          answerWithoutPlan,
          plan: null,
          warning: "Agent action block contains unsupported action types."
        };
      }
      const capped = normalized.slice(0, 8);
      const plan = {
        id: `qa-actions-${formatBackupStamp(/* @__PURE__ */ new Date())}`,
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        model,
        question,
        actions: capped
      };
      const warning = normalized.length > capped.length ? `Action count exceeded limit. Only first ${capped.length} actions were kept.` : void 0;
      return {
        answerWithoutPlan,
        plan,
        warning
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown JSON parse error";
      return {
        answerWithoutPlan,
        plan: null,
        warning: `Agent action JSON parse failed: ${message}`
      };
    }
  }
  buildQaActionApprovalText(plan) {
    const lines = [
      "### Agent action plan / \uC5D0\uC774\uC804\uD2B8 \uC561\uC158 \uACC4\uD68D",
      `Plan ID: ${plan.id}`,
      `Proposed by model: ${plan.model}`,
      `Created: ${plan.createdAt}`,
      ""
    ];
    for (let index = 0; index < plan.actions.length; index += 1) {
      lines.push(`${index + 1}. ${this.summarizeQaAgentAction(plan.actions[index])}`);
    }
    lines.push("");
    lines.push("\uC2E4\uD589\uD558\uB824\uBA74 `\uC2B9\uC778` \uB610\uB294 `/approve` \uB97C \uC785\uB825\uD558\uC138\uC694.");
    lines.push("\uCDE8\uC18C\uD558\uB824\uBA74 `\uAC70\uBD80` \uB610\uB294 `/deny` \uB97C \uC785\uB825\uD558\uC138\uC694.");
    return lines.join("\n");
  }
  trimQaToolText(text, maxChars) {
    const normalized = text != null ? text : "";
    if (normalized.length <= maxChars) {
      return normalized;
    }
    return `${normalized.slice(0, maxChars)}
...(truncated ${normalized.length - maxChars} chars)`;
  }
  normalizeUnifiedDiffText(rawDiff) {
    return this.getPatchParser().normalizeUnifiedDiffText(rawDiff);
  }
  getPatchParser() {
    if (!this.patchParser) {
      this.patchParser = new PatchParser();
    }
    return this.patchParser;
  }
  getPatchApplier() {
    if (!this.patchApplier) {
      this.patchApplier = new PatchApplier(this.getPatchParser());
    }
    return this.patchApplier;
  }
  resolveSelectionDiffLimits(action = {}) {
    const requestedChangedLines = typeof action.maxChangedLines === "number" && Number.isFinite(action.maxChangedLines) ? action.maxChangedLines : MAX_SELECTION_DIFF_CHANGED_LINES;
    const requestedHunks = typeof action.maxHunks === "number" && Number.isFinite(action.maxHunks) ? action.maxHunks : MAX_SELECTION_DIFF_HUNKS;
    return {
      maxChangedLines: Math.max(1, Math.min(MAX_SELECTION_DIFF_CHANGED_LINES, Math.floor(requestedChangedLines))),
      maxHunks: Math.max(1, Math.min(MAX_SELECTION_DIFF_HUNKS, Math.floor(requestedHunks)))
    };
  }
  validateSelectionDiffLimits(parsedDiff, limits) {
    return this.getPatchParser().validateLimits(parsedDiff, limits);
  }
  parseUnifiedDiffHunks(diffText) {
    return this.getPatchParser().parse(diffText);
  }
  countParsedUnifiedDiffChangedLines(parsedDiff) {
    return this.getPatchParser().countChangedLines(parsedDiff);
  }
  countUnifiedDiffChangedLines(diffText) {
    const parsed = this.parseUnifiedDiffHunks(diffText);
    if (parsed.error) {
      return 0;
    }
    return this.countParsedUnifiedDiffChangedLines(parsed);
  }
  isValidUnifiedDiff(diffText) {
    const parsed = this.parseUnifiedDiffHunks(diffText);
    if (parsed.error) {
      return false;
    }
    return this.countParsedUnifiedDiffChangedLines(parsed) > 0;
  }
  validateSelectionDiffRange(parsedDiff, selectionText) {
    return this.getPatchParser().validateSelectionRange(parsedDiff, selectionText);
  }
  buildPatchPreviewSummaryFromParsedDiff(parsedDiff) {
    if (!parsedDiff || parsedDiff.error) {
      return {
        added: 0,
        removed: 0,
        context: 0,
        hunks: 0,
        changed: 0
      };
    }
    let added = 0;
    let removed = 0;
    let context = 0;
    for (const hunk of parsedDiff.hunks) {
      for (const line of hunk.lines) {
        if (line.prefix === "+") {
          added += 1;
        } else if (line.prefix === "-") {
          removed += 1;
        } else {
          context += 1;
        }
      }
    }
    return {
      added,
      removed,
      context,
      hunks: parsedDiff.hunks.length,
      changed: added + removed
    };
  }
  estimatePatchPreviewRisk(params) {
    const reasons = [];
    let score = 0;
    if (params.applyMode === "fuzzy") {
      score += 4;
      reasons.push("Fuzzy 전략은 문맥 오인 가능성이 있어 추가 확인이 필요합니다.");
    }
    if (params.changed >= 120) {
      score += 3;
      reasons.push("변경 줄 수가 큽니다.");
    } else if (params.changed >= 60) {
      score += 2;
      reasons.push("변경 규모가 중간 이상입니다.");
    } else if (params.changed >= 24) {
      score += 1;
    }
    if (params.hunks >= 6) {
      score += 2;
      reasons.push("Hunk 수가 많습니다.");
    } else if (params.hunks >= 3) {
      score += 1;
    }
    if (params.removed >= Math.max(18, params.added * 2)) {
      score += 1;
      reasons.push("삭제 비중이 높습니다.");
    }
    let level = "low";
    if (score >= 6) {
      level = "high";
    } else if (score >= 3) {
      level = "medium";
    }
    if (params.applyMode === "fuzzy" && level !== "high") {
      level = "high";
    }
    const requireExtraConfirm = level === "high" || params.applyMode === "fuzzy";
    let warningTitle = "주의: Patch 검토 필요";
    if (params.applyMode === "fuzzy") {
      warningTitle = "주의: Fuzzy Patch 적용";
    } else if (level === "high") {
      warningTitle = "주의: 고위험 Patch";
    } else if (level === "medium") {
      warningTitle = "주의: 중위험 Patch";
    }
    const warningDetail = reasons.length > 0 ? reasons.join(" ") : "적용 전 변경 내용을 다시 확인하세요.";
    return {
      level,
      reasons,
      requireExtraConfirm,
      warningTitle,
      warningDetail
    };
  }
  buildPatchPreviewModel(params) {
    const {
      filePath,
      fromOffset,
      toOffset,
      parsedDiff,
      applyMode,
      strictError
    } = params;
    const summaryBase = this.buildPatchPreviewSummaryFromParsedDiff(parsedDiff);
    const risk = this.estimatePatchPreviewRisk({
      applyMode,
      changed: summaryBase.changed,
      hunks: summaryBase.hunks,
      added: summaryBase.added,
      removed: summaryBase.removed
    });
    const badges = [
      "selection-only",
      applyMode === "fuzzy" ? "fuzzy" : "strict",
      `risk:${risk.level}`
    ];
    if (risk.requireExtraConfirm) {
      badges.push("confirm-required");
    }
    const hunks = (parsedDiff && !parsedDiff.error ? parsedDiff.hunks : []).map((hunk, index) => {
      let added = 0;
      let removed = 0;
      let context = 0;
      for (const line of hunk.lines) {
        if (line.prefix === "+") {
          added += 1;
        } else if (line.prefix === "-") {
          removed += 1;
        } else {
          context += 1;
        }
      }
      const header = `@@ -${hunk.oldStart},${hunk.oldCount} +${hunk.newStart},${hunk.newCount} @@`;
      const label = `#${index + 1} ${hunk.oldStart}:${hunk.oldCount} -> ${hunk.newStart}:${hunk.newCount}`;
      const searchText = `${label}
${header}
${hunk.lines.map((line) => `${line.prefix}${line.text}`).join("\n")}`.toLowerCase();
      return {
        id: `hunk-${index + 1}`,
        index: index + 1,
        header,
        label,
        added,
        removed,
        context,
        lines: hunk.lines.map((line) => ({
          prefix: line.prefix,
          text: line.text
        })),
        searchText
      };
    });
    const strategyParts = [
      applyMode === "fuzzy" ? "PatchApplier: strict -> fuzzy" : "PatchApplier: strict"
    ];
    if (strictError && applyMode === "fuzzy") {
      strategyParts.push(`strict 실패: ${this.trimQaToolText(strictError, 160)}`);
    }
    const dryRunSummary = params.dryRunSummary && typeof params.dryRunSummary === "object" ? params.dryRunSummary : null;
    const guardResult = params.guardResult && typeof params.guardResult === "object" ? params.guardResult : null;
    const canApply = typeof params.canApply === "boolean" ? params.canApply : true;
    if (dryRunSummary && !dryRunSummary.ok) {
      badges.push("dryrun-failed");
    }
    if (guardResult && !guardResult.ok) {
      badges.push("guard-failed");
    }
    const blockReason = canApply ? "" : this.trimQaToolText(
      guardResult && !guardResult.ok ? guardResult.error || "Frontmatter guard failed." : dryRunSummary && !dryRunSummary.ok ? dryRunSummary.error || "Patch dry-run failed." : "Patch apply is blocked by PR-0 guard.",
      240
    );
    return {
      title: "Patch Preview / 선택영역 패치 미리보기",
      scopeText: `Scope: ${filePath} | offset ${fromOffset}-${toOffset}`,
      strategyText: `Strategy: ${strategyParts.join(" | ")}`,
      riskLevel: risk.level,
      warningTitle: risk.warningTitle,
      warningDetail: risk.warningDetail,
      requireExtraConfirm: risk.requireExtraConfirm,
      summary: {
        added: summaryBase.added,
        removed: summaryBase.removed,
        hunks: summaryBase.hunks,
        changed: summaryBase.changed,
        badges
      },
      dryRunSummary,
      guardResult,
      canApply,
      blockReason,
      hunks
    };
  }
  applyParsedUnifiedDiffStrictToText(sourceText, parsedDiff) {
    return this.getPatchApplier().applyStrict(sourceText, parsedDiff);
  }
  applyParsedUnifiedDiffFuzzyToText(sourceText, parsedDiff) {
    return this.getPatchApplier().applyFuzzy(sourceText, parsedDiff);
  }
  applySelectionPatchWithPatchApplier(sourceText, diffText, parsedDiff = null, options = {}) {
    const parsed = parsedDiff || this.parseUnifiedDiffHunks(diffText);
    if (parsed.error) {
      return {
        ok: false,
        mode: "none",
        error: parsed.error,
        changedLines: 0,
        strictError: parsed.error,
        fuzzyError: ""
      };
    }
    const rangeCheck = this.validateSelectionDiffRange(parsed, sourceText);
    if (!rangeCheck.ok) {
      return {
        ok: false,
        mode: "none",
        error: rangeCheck.error || "Diff exceeds selection range.",
        changedLines: this.countParsedUnifiedDiffChangedLines(parsed),
        strictError: rangeCheck.error || "",
        fuzzyError: "",
        outOfRange: true
      };
    }
    const strictResult = this.getPatchApplier().applyStrict(sourceText, parsed);
    if (strictResult.ok) {
      return {
        ...strictResult,
        mode: "strict",
        strictError: "",
        fuzzyError: ""
      };
    }
    const allowFuzzy = Boolean(options && options.allowFuzzy === true);
    if (!allowFuzzy) {
      return {
        ok: false,
        mode: "none",
        error: `Strict apply failed: ${strictResult.error || "unknown"} (fuzzy disabled).`,
        changedLines: this.countParsedUnifiedDiffChangedLines(parsed),
        strictError: strictResult.error || "",
        fuzzyError: "Fuzzy apply disabled. Set allowFuzzy=true to opt-in."
      };
    }
    const fuzzyResult = this.getPatchApplier().applyFuzzy(sourceText, parsed);
    if (fuzzyResult.ok) {
      return {
        ...fuzzyResult,
        mode: "fuzzy",
        strictError: strictResult.error || "",
        fuzzyError: ""
      };
    }
    return {
      ok: false,
      mode: "none",
      error: `Strict apply failed: ${strictResult.error || "unknown"} | Fuzzy apply failed: ${fuzzyResult.error || "unknown"}`,
      changedLines: this.countParsedUnifiedDiffChangedLines(parsed),
      strictError: strictResult.error || "",
      fuzzyError: fuzzyResult.error || ""
    };
  }
  applyUnifiedDiffToText(sourceText, diffText) {
    const parsed = this.parseUnifiedDiffHunks(diffText);
    return this.applyParsedUnifiedDiffStrictToText(sourceText, parsed);
  }
  resolveOpenMarkdownEditorForPath(filePath) {
    const normalized = (0, import_obsidian4.normalizePath)((filePath != null ? filePath : "").trim());
    if (!normalized) {
      return null;
    }
    const leaves = this.app.workspace.getLeavesOfType("markdown");
    for (const leaf of leaves) {
      const view = leaf.view;
      if (!(view instanceof import_obsidian4.MarkdownView)) {
        continue;
      }
      const file = view.file;
      if (!(file instanceof import_obsidian4.TFile) || file.extension !== "md") {
        continue;
      }
      if (file.path !== normalized || !view.editor) {
        continue;
      }
      return {
        view,
        editor: view.editor
      };
    }
    return null;
  }
  buildSelectionScopeRoots(filePath) {
    const normalized = (0, import_obsidian4.normalizePath)((filePath != null ? filePath : "").trim());
    if (!normalized) {
      return ["."];
    }
    const root = (0, import_obsidian4.normalizePath)(nodePath.posix.dirname(normalized) || ".");
    return [root || "."];
  }
  summarizePr0GuardResult(rawGuard) {
    return {
      ok: Boolean(rawGuard && rawGuard.ok),
      error: rawGuard && typeof rawGuard.error === "string" ? rawGuard.error : "",
      guardApplied: Boolean(rawGuard && rawGuard.guardApplied),
      frontmatterChangedByPatch: Boolean(rawGuard && rawGuard.frontmatterChangedByPatch)
    };
  }
  summarizePr0DryRunResult(rawDryRun, allowFuzzy) {
    return {
      ok: Boolean(rawDryRun && rawDryRun.ok),
      mode: rawDryRun && typeof rawDryRun.mode === "string" ? rawDryRun.mode : "none",
      changedLines: rawDryRun && Number.isFinite(rawDryRun.changedLines) ? rawDryRun.changedLines : 0,
      error: rawDryRun && typeof rawDryRun.error === "string" ? rawDryRun.error : "",
      strictError: rawDryRun && typeof rawDryRun.strictError === "string" ? rawDryRun.strictError : "",
      fuzzyError: rawDryRun && typeof rawDryRun.fuzzyError === "string" ? rawDryRun.fuzzyError : "",
      allowFuzzy: Boolean(allowFuzzy)
    };
  }
  async applyPatchFlow(scope, patchPayload) {
    const selection = scope && scope.selection ? scope.selection : null;
    if (!selection) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: "No active open selection snapshot is available.",
        audit: { resultCode: "REJECTED" }
      };
    }
    const scopeRoots = Array.isArray(scope == null ? void 0 : scope.scopeRoots) && scope.scopeRoots.length > 0 ? scope.scopeRoots : this.buildSelectionScopeRoots(selection.filePath);
    let scopedVault;
    try {
      scopedVault = new ScopedVault(scopeRoots);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: message,
        audit: {
          scopeRoots,
          resultCode: "REJECTED"
        }
      };
    }
    const allowFuzzy = Boolean(patchPayload && patchPayload.allowFuzzy === true);
    let targetPath = "";
    try {
      targetPath = scopedVault.assertPathInScope(
        (((patchPayload == null ? void 0 : patchPayload.path) != null ? patchPayload.path : selection.filePath) || selection.filePath),
        "apply_selection_diff.path"
      );
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: message,
        audit: {
          targetPath,
          scopeRoots,
          resultCode: "REJECTED"
        }
      };
    }
    if (targetPath !== selection.filePath) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: `Target path mismatch. selection=${selection.filePath}, action=${targetPath}`,
        audit: {
          targetPath,
          scopeRoots,
          resultCode: "REJECTED"
        }
      };
    }
    const editorContext = this.resolveOpenMarkdownEditorForPath(targetPath);
    if (!editorContext) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: "Target markdown note is not open in editor.",
        audit: {
          targetPath,
          scopeRoots,
          resultCode: "REJECTED"
        }
      };
    }
    const editor = editorContext.editor;
    const readSelectionSnapshot = () => {
      const fullText = editor.getValue();
      if (selection.toOffset > fullText.length || selection.fromOffset < 0 || selection.fromOffset >= selection.toOffset) {
        return {
          ok: false,
          error: "Selection offsets are out of current editor range."
        };
      }
      const selectedText = fullText.slice(selection.fromOffset, selection.toOffset);
      const selectionHash = this.hashString(`${selection.filePath}
${selectedText}`);
      return {
        ok: true,
        fullText,
        selectedText,
        selectionHash
      };
    };
    const initialSnapshot = readSelectionSnapshot();
    if (!initialSnapshot.ok) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: initialSnapshot.error,
        audit: {
          targetPath,
          scopeRoots,
          resultCode: "REJECTED"
        }
      };
    }
    const expectedHash = ((patchPayload == null ? void 0 : patchPayload.expectedSelectionHash) || selection.selectionHash || "").trim();
    if (expectedHash && initialSnapshot.selectionHash !== expectedHash) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: "Selection hash mismatch. Re-open and reselect target range.",
        audit: {
          targetPath,
          scopeRoots,
          currentSelectionHash: initialSnapshot.selectionHash,
          expectedSelectionHash: expectedHash,
          resultCode: "REJECTED"
        }
      };
    }
    if (typeof (patchPayload == null ? void 0 : patchPayload.expectedSelectionText) === "string" && patchPayload.expectedSelectionText.length > 0 && patchPayload.expectedSelectionText !== initialSnapshot.selectedText) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: "Selection text mismatch. Re-open and reselect target range.",
        audit: {
          targetPath,
          scopeRoots,
          currentSelectionHash: initialSnapshot.selectionHash,
          expectedSelectionHash: expectedHash,
          resultCode: "REJECTED"
        }
      };
    }
    const contractValidation = this.validateSelectionDiffActionAgainstOpenSelection(
      patchPayload,
      {
        filePath: selection.filePath,
        selectedText: initialSnapshot.selectedText,
        selectionHash: initialSnapshot.selectionHash
      }
    );
    if (!contractValidation.ok) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: `${contractValidation.error || "Invalid selection diff contract."} Re-generate unified diff.`,
        audit: {
          targetPath,
          scopeRoots,
          currentSelectionHash: initialSnapshot.selectionHash,
          expectedSelectionHash: expectedHash,
          resultCode: "REJECTED"
        }
      };
    }
    const diff = contractValidation.diffBody;
    const parsedDiff = contractValidation.parsedDiff;
    const limits = contractValidation.limits;
    const limitCheck = contractValidation.limitCheck;
    const preflightDryRunRaw = this.applySelectionPatchWithPatchApplier(
      initialSnapshot.selectedText,
      diff,
      parsedDiff,
      { allowFuzzy }
    );
    const preflightDryRun = this.summarizePr0DryRunResult(preflightDryRunRaw, allowFuzzy);
    let preflightGuard = {
      ok: false,
      error: preflightDryRun.ok ? "" : "Dry-run failed. Frontmatter guard check skipped.",
      guardApplied: false,
      frontmatterChangedByPatch: false
    };
    if (preflightDryRunRaw.ok) {
      const preflightPatchedFullText = `${initialSnapshot.fullText.slice(0, selection.fromOffset)}${preflightDryRunRaw.text}${initialSnapshot.fullText.slice(selection.toOffset)}`;
      preflightGuard = this.summarizePr0GuardResult(
        this.runFrontmatterLintGuardAfterPatch({
          beforeText: initialSnapshot.fullText,
          patchedText: preflightPatchedFullText,
          mode: "selection"
        })
      );
    }
    const previewModel = this.buildPatchPreviewModel({
      filePath: selection.filePath,
      fromOffset: selection.fromOffset,
      toOffset: selection.toOffset,
      applyMode: preflightDryRunRaw.ok ? preflightDryRunRaw.mode || "strict" : "none",
      strictError: preflightDryRunRaw.strictError || "",
      parsedDiff,
      dryRunSummary: preflightDryRun,
      guardResult: preflightGuard,
      canApply: preflightDryRun.ok && preflightGuard.ok
    });
    const preview = await PatchPreviewModal.ask(this.app, previewModel);
    if (preview.decision !== "apply") {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: "Patch preview cancelled by user.",
        audit: {
          targetPath,
          scopeRoots,
          currentSelectionHash: initialSnapshot.selectionHash,
          expectedSelectionHash: expectedHash,
          diffHash: this.hashString(contractValidation.diffWithHeader),
          changedLines: limitCheck.changedLines,
          applyMode: preflightDryRun.mode || "none",
          previewDecision: "cancel",
          dryRunSummary: preflightDryRun,
          guardResult: preflightGuard,
          maxChangedLines: limits.maxChangedLines,
          maxHunks: limits.maxHunks,
          resultCode: "CANCELED"
        }
      };
    }
    if (!previewModel.canApply) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: previewModel.blockReason || "PR-0 guard blocked patch apply.",
        audit: {
          targetPath,
          scopeRoots,
          currentSelectionHash: initialSnapshot.selectionHash,
          expectedSelectionHash: expectedHash,
          diffHash: this.hashString(contractValidation.diffWithHeader),
          changedLines: limitCheck.changedLines,
          applyMode: preflightDryRun.mode || "none",
          previewDecision: "apply",
          dryRunSummary: preflightDryRun,
          guardResult: preflightGuard,
          maxChangedLines: limits.maxChangedLines,
          maxHunks: limits.maxHunks,
          resultCode: "REJECTED"
        }
      };
    }
    const latestSnapshot = readSelectionSnapshot();
    if (!latestSnapshot.ok) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: "Selection offsets changed while preview was open. Re-open and reselect target range.",
        audit: {
          targetPath,
          scopeRoots,
          currentSelectionHash: initialSnapshot.selectionHash,
          expectedSelectionHash: expectedHash,
          diffHash: this.hashString(contractValidation.diffWithHeader),
          changedLines: limitCheck.changedLines,
          previewDecision: "apply",
          dryRunSummary: preflightDryRun,
          guardResult: preflightGuard,
          maxChangedLines: limits.maxChangedLines,
          maxHunks: limits.maxHunks,
          resultCode: "REJECTED"
        }
      };
    }
    if (expectedHash && latestSnapshot.selectionHash !== expectedHash) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: "Selection hash mismatch after preview. Re-open and reselect target range.",
        audit: {
          targetPath,
          scopeRoots,
          currentSelectionHash: latestSnapshot.selectionHash,
          expectedSelectionHash: expectedHash,
          diffHash: this.hashString(contractValidation.diffWithHeader),
          changedLines: limitCheck.changedLines,
          previewDecision: "apply",
          dryRunSummary: preflightDryRun,
          guardResult: preflightGuard,
          maxChangedLines: limits.maxChangedLines,
          maxHunks: limits.maxHunks,
          resultCode: "REJECTED"
        }
      };
    }
    if (!expectedHash && latestSnapshot.selectionHash !== initialSnapshot.selectionHash) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: "Selection changed while preview was open. Regenerate unified diff.",
        audit: {
          targetPath,
          scopeRoots,
          currentSelectionHash: latestSnapshot.selectionHash,
          expectedSelectionHash: expectedHash,
          diffHash: this.hashString(contractValidation.diffWithHeader),
          changedLines: limitCheck.changedLines,
          previewDecision: "apply",
          dryRunSummary: preflightDryRun,
          guardResult: preflightGuard,
          maxChangedLines: limits.maxChangedLines,
          maxHunks: limits.maxHunks,
          resultCode: "REJECTED"
        }
      };
    }
    if (typeof (patchPayload == null ? void 0 : patchPayload.expectedSelectionText) === "string" && patchPayload.expectedSelectionText.length > 0 && patchPayload.expectedSelectionText !== latestSnapshot.selectedText) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: "Selection text mismatch after preview. Re-open and reselect target range.",
        audit: {
          targetPath,
          scopeRoots,
          currentSelectionHash: latestSnapshot.selectionHash,
          expectedSelectionHash: expectedHash,
          diffHash: this.hashString(contractValidation.diffWithHeader),
          changedLines: limitCheck.changedLines,
          previewDecision: "apply",
          dryRunSummary: preflightDryRun,
          guardResult: preflightGuard,
          maxChangedLines: limits.maxChangedLines,
          maxHunks: limits.maxHunks,
          resultCode: "REJECTED"
        }
      };
    }
    const latestRangeCheck = this.validateSelectionDiffRange(parsedDiff, latestSnapshot.selectedText);
    if (!latestRangeCheck.ok) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: `${latestRangeCheck.error} Re-select target range and regenerate unified diff.`,
        audit: {
          targetPath,
          scopeRoots,
          currentSelectionHash: latestSnapshot.selectionHash,
          expectedSelectionHash: expectedHash,
          diffHash: this.hashString(contractValidation.diffWithHeader),
          changedLines: limitCheck.changedLines,
          previewDecision: "apply",
          dryRunSummary: preflightDryRun,
          guardResult: preflightGuard,
          maxChangedLines: limits.maxChangedLines,
          maxHunks: limits.maxHunks,
          resultCode: "REJECTED"
        }
      };
    }
    const liveLimitCheck = this.validateSelectionDiffLimits(parsedDiff, limits);
    if (!liveLimitCheck.ok) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: `${liveLimitCheck.error} Re-generate unified diff.`,
        audit: {
          targetPath,
          scopeRoots,
          currentSelectionHash: latestSnapshot.selectionHash,
          expectedSelectionHash: expectedHash,
          diffHash: this.hashString(contractValidation.diffWithHeader),
          changedLines: liveLimitCheck.changedLines,
          previewDecision: "apply",
          dryRunSummary: preflightDryRun,
          guardResult: preflightGuard,
          maxChangedLines: limits.maxChangedLines,
          maxHunks: limits.maxHunks,
          resultCode: "REJECTED"
        }
      };
    }
    const applied = this.applySelectionPatchWithPatchApplier(
      latestSnapshot.selectedText,
      diff,
      parsedDiff,
      { allowFuzzy }
    );
    const liveDryRun = this.summarizePr0DryRunResult(applied, allowFuzzy);
    if (!applied.ok) {
      return {
        status: applied.outOfRange ? "blocked" : "error",
        title: "apply_selection_diff",
        detail: `${applied.error || "Failed to apply unified diff."} Regenerate unified diff.`,
        audit: {
          targetPath,
          scopeRoots,
          currentSelectionHash: latestSnapshot.selectionHash,
          expectedSelectionHash: expectedHash,
          diffHash: this.hashString(contractValidation.diffWithHeader),
          changedLines: liveLimitCheck.changedLines,
          applyMode: applied.mode || "none",
          strictError: applied.strictError || "",
          fuzzyError: applied.fuzzyError || "",
          previewDecision: "apply",
          dryRunSummary: liveDryRun,
          guardResult: preflightGuard,
          maxChangedLines: limits.maxChangedLines,
          maxHunks: limits.maxHunks,
          resultCode: applied.outOfRange ? "REJECTED" : "FAILED"
        }
      };
    }
    const patchedFullText = `${latestSnapshot.fullText.slice(0, selection.fromOffset)}${applied.text}${latestSnapshot.fullText.slice(selection.toOffset)}`;
    const guardRaw = this.runFrontmatterLintGuardAfterPatch({
      beforeText: latestSnapshot.fullText,
      patchedText: patchedFullText,
      mode: "selection"
    });
    const guardResult = this.summarizePr0GuardResult(guardRaw);
    if (!guardRaw.ok) {
      return {
        status: "blocked",
        title: "apply_selection_diff",
        detail: `${guardRaw.error} Re-generate unified diff.`,
        audit: {
          targetPath,
          scopeRoots,
          currentSelectionHash: latestSnapshot.selectionHash,
          expectedSelectionHash: expectedHash,
          diffHash: this.hashString(contractValidation.diffWithHeader),
          changedLines: liveLimitCheck.changedLines,
          applyMode: applied.mode || "none",
          strictError: applied.strictError || "",
          fuzzyError: applied.fuzzyError || "",
          previewDecision: "apply",
          dryRunSummary: liveDryRun,
          guardResult,
          maxChangedLines: limits.maxChangedLines,
          maxHunks: limits.maxHunks,
          resultCode: "REJECTED"
        }
      };
    }
    const finalFullText = guardRaw.text;
    const patchedFromOffset = selection.fromOffset;
    const patchedToOffset = selection.fromOffset + applied.text.length;
    let finalFromOffset = this.mapOffsetAfterFrontmatterGuard(
      patchedFromOffset,
      guardRaw.beforeBodyStartOffset,
      guardRaw.bodyOffsetDelta
    );
    let finalToOffset = this.mapOffsetAfterFrontmatterGuard(
      patchedToOffset,
      guardRaw.beforeBodyStartOffset,
      guardRaw.bodyOffsetDelta
    );
    finalFromOffset = Math.max(0, Math.min(finalFullText.length, finalFromOffset));
    finalToOffset = Math.max(finalFromOffset, Math.min(finalFullText.length, finalToOffset));
    editor.setValue(finalFullText);
    editor.setSelection(editor.offsetToPos(finalFromOffset), editor.offsetToPos(finalToOffset));
    const finalSelectedText = finalFullText.slice(finalFromOffset, finalToOffset);
    const nextSelection = {
      ...selection,
      fromOffset: finalFromOffset,
      toOffset: finalToOffset,
      selectedText: finalSelectedText,
      selectionHash: this.hashString(`${selection.filePath}
${finalSelectedText}`),
      capturedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    return {
      status: "ok",
      title: `apply_selection_diff ${selection.filePath}`,
      detail: `Applied unified diff to selection (${selection.fromOffset}-${selection.toOffset}), changed lines=${applied.changedLines}, hunks=${liveLimitCheck.hunks}, mode=${applied.mode || "strict"}.`,
      nextSelection,
      audit: {
        targetPath,
        scopeRoots,
        currentSelectionHash: nextSelection.selectionHash,
        expectedSelectionHash: expectedHash,
        diffHash: this.hashString(contractValidation.diffWithHeader),
        changedLines: liveLimitCheck.changedLines,
        applyMode: applied.mode || "strict",
        usedTrimmedMatch: Boolean(applied.usedTrimmedMatch),
        strictError: applied.strictError || "",
        previewDecision: "apply",
        dryRunSummary: liveDryRun,
        guardResult,
        frontmatterGuardApplied: Boolean(guardRaw.guardApplied),
        frontmatterUpdated: true,
        maxChangedLines: limits.maxChangedLines,
        maxHunks: limits.maxHunks,
        resultCode: "APPLIED"
      }
    };
  }
  async executeSelectionDiffAction(action, executionContext) {
    const selection = executionContext.openSelection;
    const routingLog = executionContext.routingLog && typeof executionContext.routingLog === "object" ? executionContext.routingLog : null;
    const auditState = {
      at: (/* @__PURE__ */ new Date()).toISOString(),
      planId: executionContext.planId || "",
      taskType: executionContext.taskType || "QA_CHAT",
      roles: routingLog && Array.isArray(routingLog.roles) ? [...routingLog.roles] : [],
      modelUsed: routingLog && Array.isArray(routingLog.modelUsed) ? [...routingLog.modelUsed] : [],
      fallbackUsed: Boolean(routingLog && routingLog.fallbackUsed),
      safeguardPassed: Boolean(routingLog && routingLog.safeguardPassed),
      actionType: "apply_selection_diff",
      filePath: selection ? selection.filePath : "",
      selectionFrom: selection ? selection.fromOffset : null,
      selectionTo: selection ? selection.toOffset : null,
      expectedSelectionHash: "",
      currentSelectionHash: "",
      diffHash: "",
      changedLines: 0,
      applyMode: "none"
    };
    const finalize = async (status, title, detail, extra = {}) => {
      const result = { status, title, detail };
      const resultCode = typeof extra.resultCode === "string" && extra.resultCode.length > 0 ? extra.resultCode : status === "ok" ? "APPLIED" : status === "error" ? "FAILED" : /cancel/i.test(detail) ? "CANCELED" : "REJECTED";
      await this.appendSelectionDiffAuditLog({
        ts: (/* @__PURE__ */ new Date()).toISOString(),
        ...auditState,
        ...extra,
        status,
        title,
        detail,
        scope: Array.isArray(extra.scopeRoots) ? extra.scopeRoots : [],
        paths: {
          target: typeof extra.targetPath === "string" && extra.targetPath.length > 0 ? extra.targetPath : auditState.filePath,
          selection: selection ? selection.filePath : ""
        },
        guard: extra.guardResult && typeof extra.guardResult === "object" ? extra.guardResult : null,
        dryRun: extra.dryRunSummary && typeof extra.dryRunSummary === "object" ? extra.dryRunSummary : null,
        result: resultCode
      });
      return result;
    };
    if (!selection) {
      return finalize("blocked", "apply_selection_diff", "No active open selection snapshot is available.");
    }
    const flowResult = await this.applyPatchFlow(
      {
        selection,
        scopeRoots: Array.isArray(executionContext.scopeRoots) ? executionContext.scopeRoots : this.buildSelectionScopeRoots(selection.filePath)
      },
      action
    );
    const flowAudit = flowResult.audit && typeof flowResult.audit === "object" ? flowResult.audit : {};
    if (typeof flowAudit.currentSelectionHash === "string") {
      auditState.currentSelectionHash = flowAudit.currentSelectionHash;
    }
    if (typeof flowAudit.expectedSelectionHash === "string") {
      auditState.expectedSelectionHash = flowAudit.expectedSelectionHash;
    }
    if (typeof flowAudit.diffHash === "string") {
      auditState.diffHash = flowAudit.diffHash;
    }
    if (Number.isFinite(flowAudit.changedLines)) {
      auditState.changedLines = flowAudit.changedLines;
    }
    if (typeof flowAudit.applyMode === "string") {
      auditState.applyMode = flowAudit.applyMode;
    }
    if (flowResult.nextSelection) {
      executionContext.openSelection = flowResult.nextSelection;
      auditState.selectionFrom = flowResult.nextSelection.fromOffset;
      auditState.selectionTo = flowResult.nextSelection.toOffset;
      auditState.filePath = flowResult.nextSelection.filePath || auditState.filePath;
    }
    return finalize(
      flowResult.status || "error",
      flowResult.title || "apply_selection_diff",
      flowResult.detail || "Unknown apply_patch_flow error.",
      flowAudit
    );
  }
  evaluateQaActionPlanSafeguard(plan, context = {}) {
    const reasons = [];
    let containsExternalAccess = false;
    let modifiesOutsideWorkspace = false;
    let isMassEdit = false;
    const taskType = context.taskType || plan.taskType || "QA_CHAT";
    const openSelection = context.openSelection || plan.openSelection || null;
    let mutatingActions = 0;
    let applySelectionDiffActions = 0;
    for (const action of plan.actions) {
      if (action.type === "run_shell") {
        const command = (action.command || "").toLowerCase();
        if (/(https?:\/\/|curl\s|wget\s|browser|open\s|osascript|xdg-open|start\s+)/i.test(command)) {
          containsExternalAccess = true;
          reasons.push("run_shell contains external/network/browser access signal.");
        }
        if (taskType === "EDIT_NOTE") {
          containsExternalAccess = true;
          reasons.push("EDIT_NOTE task blocks run_shell action.");
        }
      }
      if (action.type === "list_folder") {
        const folderPath = (action.path || "").trim();
        if (folderPath === "." || folderPath === "/" || folderPath === "\\") {
          isMassEdit = true;
          reasons.push("Vault-wide folder scan is blocked by safeguard.");
        }
      }
      if (action.type === "write_note" || action.type === "append_note" || action.type === "delete_note" || action.type === "apply_selection_diff") {
        mutatingActions += 1;
      }
      if (action.type === "apply_selection_diff") {
        applySelectionDiffActions += 1;
        const validation = this.validateSelectionDiffActionAgainstOpenSelection(action, openSelection);
        if (!validation.ok) {
          isMassEdit = true;
          reasons.push(`apply_selection_diff contract violation: ${validation.error}`);
        }
      }
      if (typeof action.path === "string" && this.isAbsoluteQaPath(action.path.trim()) && !this.settings.qaAgentShellFullAccess) {
        try {
          this.resolveQaAgentPathTarget(
            action.path,
            `${action.type}.path`,
            action.type === "list_folder" ? "folder" : "file"
          );
        } catch (error) {
          modifiesOutsideWorkspace = true;
          reasons.push(`Action path outside allowed workspace roots: ${action.path}`);
        }
      }
    }
    if (taskType === "EDIT_NOTE" && plan.actions.some(
      (action) => action.type === "write_note" || action.type === "append_note" || action.type === "delete_note"
    )) {
      isMassEdit = true;
      reasons.push("EDIT_NOTE task only allows selection diff edits.");
    }
    if (taskType === "EDIT_NOTE" && applySelectionDiffActions !== 1) {
      isMassEdit = true;
      reasons.push(`EDIT_NOTE task requires exactly one apply_selection_diff action (found ${applySelectionDiffActions}).`);
    }
    if (mutatingActions > 6) {
      isMassEdit = true;
      reasons.push(`Too many mutating actions (${mutatingActions}).`);
    }
    const passed = !containsExternalAccess && !modifiesOutsideWorkspace && !isMassEdit;
    return {
      passed,
      containsExternalAccess,
      modifiesOutsideWorkspace,
      isMassEdit,
      reasons
    };
  }
  formatQaSafeguardFailureText(safety) {
    const header = "### Safeguard blocked action plan";
    const detailLines = safety.reasons.length > 0 ? safety.reasons.map((reason) => `- ${reason}`) : ["- blocked by safeguard rules"];
    return [header, ...detailLines].join("\n");
  }
  resolveSafeQaAgentPath(rawPath, label) {
    const normalized = (0, import_obsidian4.normalizePath)((rawPath != null ? rawPath : "").trim());
    if (!this.isSafeVaultRelativePath(normalized)) {
      throw new Error(`${label} must be a safe vault-relative path.`);
    }
    return normalized;
  }
  getVaultBasePathForQaShell() {
    const adapter = this.app.vault.adapter;
    if (typeof adapter.getBasePath !== "function") {
      throw new Error("Shell tool requires desktop filesystem vault adapter.");
    }
    const base = adapter.getBasePath();
    if (!base || typeof base !== "string") {
      throw new Error("Could not resolve vault base path for shell tool.");
    }
    return base;
  }
  parseQaAgentAbsoluteAllowlist() {
    return this.settings.qaAgentPathAllowlist.split(/[\n,;]+/).map((item) => item.trim()).filter((item) => item.length > 0).filter((item) => item.startsWith("/") || /^[A-Za-z]:/.test(item)).map((item) => nodePath.resolve(item)).filter((item, index, arr) => arr.indexOf(item) === index);
  }
  isPathInsideAnyAllowedRoot(resolvedPath, allowedRoots) {
    return allowedRoots.some((root) => {
      const normalizedRoot = nodePath.resolve(root);
      const relative2 = nodePath.relative(normalizedRoot, resolvedPath);
      return relative2 === "" || !relative2.startsWith("..") && !nodePath.isAbsolute(relative2);
    });
  }
  isAbsoluteQaPath(pathValue) {
    return pathValue.startsWith("/") || /^[A-Za-z]:/.test(pathValue);
  }
  resolveQaAgentPathTarget(rawPath, label, kind) {
    const requested = (rawPath != null ? rawPath : "").trim();
    if (!requested) {
      throw new Error(`${label} is required.`);
    }
    if (!this.isAbsoluteQaPath(requested)) {
      if (kind === "folder") {
        return {
          mode: "vault",
          path: this.resolveSafeFolderPath(requested, ".", label)
        };
      }
      return {
        mode: "vault",
        path: this.resolveSafeQaAgentPath(requested, label)
      };
    }
    const resolved = nodePath.resolve(requested);
    if (this.settings.qaAgentShellFullAccess) {
      return {
        mode: "absolute",
        path: resolved
      };
    }
    const allowedRoots = [
      nodePath.resolve(this.getVaultBasePathForQaShell()),
      ...this.parseQaAgentAbsoluteAllowlist()
    ];
    if (!this.isPathInsideAnyAllowedRoot(resolved, allowedRoots)) {
      throw new Error(
        `${label} absolute path is blocked. Allowed roots: ${allowedRoots.join(", ") || "(none)"}`
      );
    }
    return {
      mode: "absolute",
      path: resolved
    };
  }
  sanitizeQaShellCwdPath(rawCwd) {
    const requested = (rawCwd != null ? rawCwd : "").trim();
    if (!requested) {
      return "";
    }
    if (requested.startsWith("/") || /^[A-Za-z]:/.test(requested)) {
      const resolved = nodePath.resolve(requested);
      if (this.settings.qaAgentShellFullAccess) {
        return resolved;
      }
      const allowedRoots = this.parseQaAgentAbsoluteAllowlist();
      if (!this.isPathInsideAnyAllowedRoot(resolved, allowedRoots)) {
        throw new Error(
          `Shell cwd must be inside allowlist roots: ${allowedRoots.join(", ") || "(none)"}`
        );
      }
      return resolved;
    }
    return this.resolveSafeFolderPath(requested, ".", "Shell cwd");
  }
  resolveQaShellCwd(rawCwd) {
    var _a;
    const basePath = this.getVaultBasePathForQaShell();
    const baseResolved = nodePath.resolve(basePath);
    const fullAccess = this.settings.qaAgentShellFullAccess;
    const allowedRoots = [baseResolved, ...this.parseQaAgentAbsoluteAllowlist()];
    const requested = ((_a = rawCwd != null ? rawCwd : this.settings.qaAgentShellCwdPath) != null ? _a : "").trim();
    if (!requested) {
      return baseResolved;
    }
    const sanitized = this.sanitizeQaShellCwdPath(requested);
    const resolved = sanitized.startsWith("/") || /^[A-Za-z]:/.test(sanitized) ? nodePath.resolve(sanitized) : nodePath.resolve(baseResolved, sanitized);
    if (fullAccess) {
      return resolved;
    }
    if (!this.isPathInsideAnyAllowedRoot(resolved, allowedRoots)) {
      throw new Error(
        `Shell cwd must stay inside vault or allowlist roots: ${allowedRoots.join(", ")}`
      );
    }
    return resolved;
  }
  async writeVaultTextFile(path, content) {
    await this.ensureParentFolder(path);
    const existing = this.app.vault.getAbstractFileByPath(path);
    if (existing instanceof import_obsidian4.TFile) {
      await this.app.vault.modify(existing, content);
      return;
    }
    const exists = await this.app.vault.adapter.exists(path);
    if (exists) {
      await this.app.vault.adapter.write(path, content);
      return;
    }
    await this.app.vault.create(path, content);
  }
  async executeQaAgentAction(action, executionContext = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    try {
      if ((executionContext.taskType || "QA_CHAT") === "EDIT_NOTE" && action.type !== "apply_selection_diff") {
        return {
          status: "blocked",
          title: this.summarizeQaAgentAction(action),
          detail: "EDIT_NOTE task only allows apply_selection_diff. Other mutating routes are blocked by PR-0 flow."
        };
      }
      if (action.type === "read_note") {
        const target = this.resolveQaAgentPathTarget(
          action.path || "",
          "read_note.path",
          "file"
        );
        let content = "";
        if (target.mode === "vault") {
          const exists = await this.app.vault.adapter.exists(target.path);
          if (!exists) {
            return {
              status: "error",
              title: `read_note ${target.path}`,
              detail: "File does not exist."
            };
          }
          content = await this.app.vault.adapter.read(target.path);
        } else {
          try {
            content = await nodeFs.promises.readFile(target.path, "utf8");
          } catch (e) {
            return {
              status: "error",
              title: `read_note ${target.path}`,
              detail: "File does not exist or is not readable."
            };
          }
        }
        return {
          status: "ok",
          title: `read_note ${target.path}`,
          detail: this.trimQaToolText(content, 2400)
        };
      }
      if (action.type === "write_note") {
        const target = this.resolveQaAgentPathTarget(
          action.path || "",
          "write_note.path",
          "file"
        );
        const content = (_a = action.content) != null ? _a : "";
        if (target.mode === "vault") {
          await this.writeVaultTextFile(target.path, content);
        } else {
          await nodeFs.promises.mkdir(nodePath.dirname(target.path), { recursive: true });
          await nodeFs.promises.writeFile(target.path, content, "utf8");
        }
        return {
          status: "ok",
          title: `write_note ${target.path}`,
          detail: `Wrote ${content.length} chars.`
        };
      }
      if (action.type === "append_note") {
        const target = this.resolveQaAgentPathTarget(
          action.path || "",
          "append_note.path",
          "file"
        );
        const appendText = (_b = action.content) != null ? _b : "";
        let previous = "";
        if (target.mode === "vault") {
          const exists = await this.app.vault.adapter.exists(target.path);
          previous = exists ? await this.app.vault.adapter.read(target.path) : "";
        } else {
          try {
            previous = await nodeFs.promises.readFile(target.path, "utf8");
          } catch (e) {
            previous = "";
          }
        }
        const separator = previous.length > 0 && !previous.endsWith("\n") && appendText.length > 0 && !appendText.startsWith("\n") ? "\n" : "";
        const merged = `${previous}${separator}${appendText}`;
        if (target.mode === "vault") {
          await this.writeVaultTextFile(target.path, merged);
        } else {
          await nodeFs.promises.mkdir(nodePath.dirname(target.path), { recursive: true });
          await nodeFs.promises.writeFile(target.path, merged, "utf8");
        }
        return {
          status: "ok",
          title: `append_note ${target.path}`,
          detail: `Appended ${appendText.length} chars (total ${merged.length}).`
        };
      }
      if (action.type === "delete_note") {
        const target = this.resolveQaAgentPathTarget(
          action.path || "",
          "delete_note.path",
          "file"
        );
        if (target.mode === "vault") {
          const entry = this.app.vault.getAbstractFileByPath(target.path);
          if (entry instanceof import_obsidian4.TFile) {
            await this.app.vault.delete(entry, true);
          } else {
            const exists = await this.app.vault.adapter.exists(target.path);
            if (!exists) {
              return {
                status: "error",
                title: `delete_note ${target.path}`,
                detail: "File does not exist."
              };
            }
            await this.app.vault.adapter.remove(target.path);
          }
        } else {
          try {
            const stat = await nodeFs.promises.stat(target.path);
            if (stat.isDirectory()) {
              return {
                status: "blocked",
                title: `delete_note ${target.path}`,
                detail: "Path is a directory. delete_note only allows file deletion."
              };
            }
            await nodeFs.promises.unlink(target.path);
          } catch (error) {
            return {
              status: "error",
              title: `delete_note ${target.path}`,
              detail: "File does not exist or cannot be deleted."
            };
          }
        }
        return {
          status: "ok",
          title: `delete_note ${target.path}`,
          detail: "File deleted."
        };
      }
      if (action.type === "list_folder") {
        const target = this.resolveQaAgentPathTarget(
          action.path || ".",
          "list_folder.path",
          "folder"
        );
        const lines = [
          `folder=${target.path}`
        ];
        let folders = [];
        let files = [];
        if (target.mode === "vault") {
          const listing = await this.app.vault.adapter.list(target.path);
          folders = listing.folders;
          files = listing.files;
          lines.push(`folders=${folders.length}, files=${files.length}`);
        } else {
          const entries = await nodeFs.promises.readdir(target.path, { withFileTypes: true });
          for (const entry of entries) {
            const resolved = nodePath.join(target.path, entry.name);
            if (entry.isDirectory()) {
              folders.push(resolved);
            } else {
              files.push(resolved);
            }
          }
          folders.sort((a, b) => a.localeCompare(b));
          files.sort((a, b) => a.localeCompare(b));
          lines.push(`folders=${folders.length}, files=${files.length}`);
        }
        const folderPreview = folders.slice(0, 30);
        const filePreview = files.slice(0, 40);
        if (folders.length > 0) {
          lines.push("subfolders:");
          for (const folder of folderPreview) {
            lines.push(`- ${folder}`);
          }
          if (folders.length > folderPreview.length) {
            lines.push(`- ...and ${folders.length - folderPreview.length} more`);
          }
        }
        if (files.length > 0) {
          lines.push("files:");
          for (const file of filePreview) {
            lines.push(`- ${file}`);
          }
          if (files.length > filePreview.length) {
            lines.push(`- ...and ${files.length - filePreview.length} more`);
          }
        }
        return {
          status: "ok",
          title: `list_folder ${target.path}`,
          detail: lines.join("\n")
        };
      }
      if (action.type === "apply_selection_diff") {
        return await this.executeSelectionDiffAction(action, executionContext);
      }
      if (action.type === "run_shell") {
        if (!this.settings.qaAgentAllowShellTool) {
          return {
            status: "blocked",
            title: "run_shell",
            detail: "Blocked by settings: 'Allow shell tool (danger)' is disabled."
          };
        }
        const command = ((_c = action.command) != null ? _c : "").trim();
        if (!command) {
          return {
            status: "error",
            title: "run_shell",
            detail: "command is empty."
          };
        }
        const timeoutSec = Math.max(
          3,
          Math.min(
            300,
            Math.floor((_d = action.timeoutSec) != null ? _d : this.settings.qaAgentShellTimeoutSec)
          )
        );
        const cwd = this.resolveQaShellCwd(action.cwd);
        const output = await execAsync(command, {
          cwd,
          timeout: timeoutSec * 1e3,
          maxBuffer: 1024 * 1024
        });
        const stdout = this.trimQaToolText(String((_e = output.stdout) != null ? _e : ""), 2e3);
        const stderr = this.trimQaToolText(String((_f = output.stderr) != null ? _f : ""), 1600);
        const lines = [
          `cwd=${cwd}`,
          `timeout=${timeoutSec}s`,
          stdout ? `stdout:
${stdout}` : "stdout: (empty)",
          stderr ? `stderr:
${stderr}` : "stderr: (empty)"
        ];
        return {
          status: "ok",
          title: "run_shell",
          detail: lines.join("\n")
        };
      }
      return {
        status: "error",
        title: `unsupported action: ${String(action.type)}`,
        detail: "Unsupported action type."
      };
    } catch (error) {
      if (action.type === "run_shell") {
        const shellError = error;
        const stdout = this.trimQaToolText(String((_g = shellError.stdout) != null ? _g : ""), 1800);
        const stderr = this.trimQaToolText(String((_h = shellError.stderr) != null ? _h : ""), 1800);
        const details = [
          (_i = shellError.message) != null ? _i : "Shell execution failed.",
          shellError.code !== void 0 ? `code=${String(shellError.code)}` : "",
          shellError.signal ? `signal=${shellError.signal}` : "",
          stdout ? `stdout:
${stdout}` : "",
          stderr ? `stderr:
${stderr}` : ""
        ].filter((line) => line.length > 0).join("\n");
        return {
          status: "error",
          title: "run_shell",
          detail: details
        };
      }
      const message = error instanceof Error ? error.message : "Unknown action error";
      return {
        status: "error",
        title: this.summarizeQaAgentAction(action),
        detail: message
      };
    }
  }
  async executeQaAgentActionPlan(plan, onEvent) {
    const lines = [
      "### Agent action execution report / \uC5D0\uC774\uC804\uD2B8 \uC561\uC158 \uC2E4\uD589 \uB9AC\uD3EC\uD2B8",
      `Plan ID: ${plan.id}`,
      `Actions: ${plan.actions.length}`,
      ""
    ];
    const executionContext = {
      openSelection: plan.openSelection || null,
      taskType: plan.taskType || "QA_CHAT",
      routingLog: plan.routingLog || null,
      planId: plan.id
    };
    for (let index = 0; index < plan.actions.length; index += 1) {
      const action = plan.actions[index];
      const actionLabel = this.summarizeQaAgentAction(action);
      this.emitQaEvent(
        onEvent,
        "info",
        `Executing action ${index + 1}/${plan.actions.length}: ${actionLabel}`
      );
      const result = await this.executeQaAgentAction(action, executionContext);
      if (result.status === "ok") {
        this.emitQaEvent(onEvent, "info", `Action completed: ${actionLabel}`);
      } else if (result.status === "blocked") {
        this.emitQaEvent(onEvent, "warning", `Action blocked: ${actionLabel}`, {
          detail: result.detail
        });
      } else {
        this.emitQaEvent(onEvent, "error", `Action failed: ${actionLabel}`, {
          detail: result.detail
        });
      }
      lines.push(
        `#### ${index + 1}. [${result.status.toUpperCase()}] ${result.title}`
      );
      if (result.detail) {
        lines.push(result.detail);
      }
      lines.push("");
    }
    return lines.join("\n").trim();
  }
  buildQaAgentControlResult(question, answer) {
    return {
      question: question.trim(),
      answer,
      thinking: "",
      model: "agent-tools",
      embeddingModel: this.settings.semanticOllamaModel.trim() || "(none)",
      sources: [],
      retrievalCacheHits: 0,
      retrievalCacheWrites: 0
    };
  }
  async applyQaAgentActionsFromAnswer(params) {
    const { answer, question, qaModel, onEvent, abortSignal, openSelection, taskType, routingLog } = params;
    if (abortSignal == null ? void 0 : abortSignal.aborted) {
      throw new DOMException("The operation was aborted.", "AbortError");
    }
    if (!this.settings.qaAgentToolModeEnabled) {
      if ((taskType || "QA_CHAT") === "EDIT_NOTE" && openSelection) {
        const raw = answer.trim();
        if (raw.includes(CODER_PROMPT_CONTRACT_SELECTION_HEADER) && raw.includes("@@")) {
          const syntheticPlan = {
            id: `plan-${Date.now()}`,
            actions: [
              {
                type: "apply_selection_diff",
                patch: {
                  format: "unified",
                  content: raw,
                  targetPath: openSelection.filePath,
                  expectedSelectionHash: openSelection.selectionHash,
                  expectedSelectionText: openSelection.selectedText
                }
              }
            ],
            taskType: "EDIT_NOTE",
            openSelection,
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            sourceModel: qaModel
          };
          this.pendingQaActionPlan = syntheticPlan;
          return [
            "EDIT_NOTE 패치 초안을 감지했습니다.",
            "Agent tool mode가 꺼져 있어 자동 실행은 하지 않습니다.",
            "명시 승인 시 실제 패치 적용 경로로 연결됩니다.",
            this.buildQaActionApprovalText(syntheticPlan)
          ].join("\n\n");
        }
      }
      return answer;
    }
    const parsed = this.parseQaAgentActionPlanFromAnswer({
      answer,
      question,
      model: qaModel
    });
    if (!parsed.plan) {
      if (taskType === "EDIT_NOTE") {
        const reason = parsed.warning || "Missing omni-forge-actions block for EDIT_NOTE.";
        return [
          parsed.answerWithoutPlan,
          "### Safeguard blocked action plan",
          `- ${reason}`,
          "- EDIT_NOTE는 apply_selection_diff(unified diff) 액션이 필요합니다."
        ].filter((line) => line.trim().length > 0).join("\n\n");
      }
      if (!parsed.warning) {
        return parsed.answerWithoutPlan;
      }
      const warningLine = `> Agent action parse warning: ${parsed.warning}`;
      return [parsed.answerWithoutPlan, warningLine].filter((line) => line.trim()).join("\n\n");
    }
    if (parsed.warning) {
      this.emitQaEvent(onEvent, "warning", parsed.warning);
    }
    if ((taskType || "QA_CHAT") === "EDIT_NOTE" && parsed.answerWithoutPlan.trim().length > 0) {
      this.emitQaEvent(onEvent, "warning", "EDIT_NOTE contract violation: non-diff text detected.");
      return [
        parsed.answerWithoutPlan,
        "### Safeguard blocked action plan",
        `- Coder Prompt Contract ${CODER_PROMPT_CONTRACT_VERSION}: unified diff only output is required.`,
        "- diff 외 텍스트가 포함되어 실행을 차단했습니다. 패치를 재생성하세요."
      ].filter((line) => line.trim().length > 0).join("\n\n");
    }
    parsed.plan.taskType = taskType || "QA_CHAT";
    parsed.plan.openSelection = openSelection || null;
    if (routingLog && typeof routingLog === "object") {
      parsed.plan.routingLog = {
        taskType: routingLog.taskType,
        roles: [...routingLog.roles],
        modelUsed: [...routingLog.modelUsed],
        fallbackUsed: routingLog.fallbackUsed,
        safeguardPassed: routingLog.safeguardPassed
      };
    }
    const safety = this.evaluateQaActionPlanSafeguard(parsed.plan, {
      taskType: parsed.plan.taskType,
      openSelection: parsed.plan.openSelection
    });
    if (!safety.passed) {
      if (routingLog && typeof routingLog === "object") {
        routingLog.safeguardPassed = false;
      }
      this.emitQaEvent(onEvent, "warning", "Safeguard blocked agent action plan.", {
        detail: safety.reasons.join(" | ")
      });
      return [
        parsed.answerWithoutPlan || "(Action-only response)",
        this.formatQaSafeguardFailureText(safety)
      ].filter((line) => line.trim().length > 0).join("\n\n");
    }
    if (routingLog && typeof routingLog === "object") {
      routingLog.safeguardPassed = true;
    }
    if (this.settings.qaAgentRequireApproval) {
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        throw new DOMException("The operation was aborted.", "AbortError");
      }
      this.pendingQaActionPlan = parsed.plan;
      this.emitQaEvent(
        onEvent,
        "info",
        `Queued ${parsed.plan.actions.length} action(s) for manual approval.`
      );
      return [
        parsed.answerWithoutPlan || "(Action-only response)",
        this.buildQaActionApprovalText(parsed.plan)
      ].filter((line) => line.trim().length > 0).join("\n\n");
    }
    if (abortSignal == null ? void 0 : abortSignal.aborted) {
      throw new DOMException("The operation was aborted.", "AbortError");
    }
    const report = await this.executeQaAgentActionPlan(parsed.plan, onEvent);
    return [parsed.answerWithoutPlan, report].filter((line) => line.trim().length > 0).join("\n\n");
  }
  normalizeQaExternalAttachments(attachments) {
    var _a, _b, _c, _d, _e;
    const textDocs = [];
    const images = [];
    const imageLabels = [];
    const pdfLabels = [];
    const imageItems = [];
    const pdfItems = [];
    for (const attachment of attachments.slice(0, LOCAL_QA_MAX_ATTACHMENTS)) {
      if (attachment.kind === "image") {
        const base64 = ((_a = attachment.imageBase64) != null ? _a : "").trim();
        if (base64) {
          images.push(base64);
          const label2 = (attachment.label || attachment.path || `image-${images.length}`).trim();
          const path2 = (_b = attachment.path) == null ? void 0 : _b.trim();
          imageLabels.push(label2);
          imageItems.push({ label: label2, path: path2 });
        }
      }
      if (attachment.kind === "pdf") {
        const label2 = (attachment.label || attachment.path || `pdf-${pdfLabels.length + 1}`).trim();
        const path2 = (_c = attachment.path) == null ? void 0 : _c.trim();
        pdfLabels.push(label2);
        pdfItems.push({ label: label2, path: path2 });
      }
      const content = this.trimQaToolText(((_d = attachment.content) != null ? _d : "").trim(), 12e3);
      if (!content) {
        continue;
      }
      const label = (attachment.label || attachment.path || `document-${textDocs.length + 1}`).trim();
      const path = (_e = attachment.path) == null ? void 0 : _e.trim();
      textDocs.push({
        label,
        path,
        content
      });
    }
    return {
      textDocs: textDocs.slice(0, LOCAL_QA_MAX_ATTACHMENTS),
      images: images.slice(0, LOCAL_QA_MAX_ATTACHMENTS),
      imageLabels: imageLabels.slice(0, LOCAL_QA_MAX_ATTACHMENTS),
      pdfLabels: pdfLabels.slice(0, LOCAL_QA_MAX_ATTACHMENTS),
      imageItems: imageItems.slice(0, LOCAL_QA_MAX_ATTACHMENTS),
      pdfItems: pdfItems.slice(0, LOCAL_QA_MAX_ATTACHMENTS)
    };
  }
  async askLocalQa(question, topK, history = [], onToken, onEvent, abortSignal, externalAttachments = [], options = {}) {
    var _a;
    const safeQuestion = question.trim();
    if (!safeQuestion) {
      throw new Error("Question is empty.");
    }
    const throwIfAborted = () => {
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        throw new DOMException("The operation was aborted.", "AbortError");
      }
    };
    throwIfAborted();
    if (this.settings.qaAgentToolModeEnabled) {
      const approvalCommand = this.parseQaAgentApprovalCommand(safeQuestion);
      if (approvalCommand) {
        if (!this.pendingQaActionPlan) {
          return this.buildQaAgentControlResult(
            safeQuestion,
            "\uB300\uAE30 \uC911\uC778 \uC561\uC158 \uACC4\uD68D\uC774 \uC5C6\uC2B5\uB2C8\uB2E4. / No pending action plan."
          );
        }
        if (approvalCommand === "deny") {
          const cancelled = this.pendingQaActionPlan;
          this.pendingQaActionPlan = null;
          return this.buildQaAgentControlResult(
            safeQuestion,
            `\uACC4\uD68D\uC744 \uCDE8\uC18C\uD588\uC2B5\uB2C8\uB2E4: ${cancelled.id} (${cancelled.actions.length} actions).`
          );
        }
        const plan = this.pendingQaActionPlan;
        this.pendingQaActionPlan = null;
        const safety = this.evaluateQaActionPlanSafeguard(plan, {
          taskType: plan.taskType || "QA_CHAT",
          openSelection: plan.openSelection || null
        });
        if (!safety.passed) {
          if (plan.routingLog && typeof plan.routingLog === "object") {
            plan.routingLog.safeguardPassed = false;
          }
          return this.buildQaAgentControlResult(
            safeQuestion,
            this.formatQaSafeguardFailureText(safety)
          );
        }
        if (plan.routingLog && typeof plan.routingLog === "object") {
          plan.routingLog.safeguardPassed = true;
        }
        const report = await this.executeQaAgentActionPlan(plan, onEvent);
        return this.buildQaAgentControlResult(safeQuestion, report);
      }
    }
    const qaContextEnabled = this.settings.qaContextInChat;
    const selectedFiles = qaContextEnabled ? this.getSelectedFiles() : [];
    const normalizedExternal = this.normalizeQaExternalAttachments(externalAttachments);
    const openFilePath = (0, import_obsidian4.normalizePath)(((_a = options.openFilePath) != null ? _a : "").trim());
    const openFileEntry = openFilePath ? this.app.vault.getAbstractFileByPath(openFilePath) : null;
    const openFile = openFileEntry instanceof import_obsidian4.TFile && openFileEntry.extension === "md" ? openFileEntry : null;
    const openSelection = this.normalizeQaOpenSelectionContext(options.openSelection, openFilePath);
    const hasImageAttachments = normalizedExternal.images.length > 0;
    const hasPdfAttachments = normalizedExternal.pdfLabels.length > 0;
    const hasVisionAttachments = hasImageAttachments;
    const isCloudFamily = this.getQaChatModelFamilyForQa() === "cloud";
    const hasExternalContext = normalizedExternal.textDocs.length > 0 || normalizedExternal.images.length > 0 || normalizedExternal.pdfLabels.length > 0;
    const routingContext = {
      hasSelection: Boolean(openSelection),
      hasOpenFile: Boolean(openFilePath),
      hasAttachments: hasExternalContext
    };
    const intent = this.detectLocalQaIntent(safeQuestion);
    const preferDetailed = this.shouldPreferDetailedAnswer(safeQuestion, intent);
    const safeTopK = Math.max(1, Math.min(15, topK));
    let qaBaseUrl = this.resolveQaBaseUrl();
    if (!qaBaseUrl) {
      throw new Error("Q&A base URL is empty.");
    }
    if (!isCloudFamily && !this.isLocalEndpoint(qaBaseUrl)) {
      const localBase = this.settings.ollamaBaseUrl.trim();
      if (localBase && this.isLocalEndpoint(localBase)) {
        qaBaseUrl = localBase;
        this.settings.qaOllamaBaseUrl = localBase;
        void this.saveSettings().catch(() => {
        });
        this.emitQaEvent(
          onEvent,
          "info",
          "Local mode: restored Q&A base URL to local Ollama endpoint."
        );
      }
    }
    if (isCloudFamily) {
      let changed = false;
      if (!this.settings.qaAllowNonLocalEndpoint) {
        this.settings.qaAllowNonLocalEndpoint = true;
        changed = true;
        this.emitQaEvent(
          onEvent,
          "info",
          "Cloud mode: auto-enabled non-local endpoint policy for this session."
        );
      }
      const beforeAllowlist = this.settings.qaAllowedOutboundHosts;
      this.appendQaAllowedOutboundHostFromUrl(qaBaseUrl);
      if (beforeAllowlist !== this.settings.qaAllowedOutboundHosts) {
        changed = true;
        this.emitQaEvent(
          onEvent,
          "info",
          "Cloud mode: endpoint host added to outbound allowlist."
        );
      }
      if (changed) {
        void this.saveSettings().catch(() => {
        });
      }
    }
    this.emitQaEvent(
      onEvent,
      "info",
      `Endpoint policy precheck: family=${isCloudFamily ? "cloud" : "local"}, base=${qaBaseUrl}, allowNonLocal=${this.settings.qaAllowNonLocalEndpoint ? "ON" : "OFF"}`
    );
    const endpointPolicyError = this.validateQaEndpointPolicy(qaBaseUrl);
    if (endpointPolicyError) {
      throw new Error(endpointPolicyError);
    }
    if (!qaContextEnabled) {
      this.emitQaEvent(
        onEvent,
        "retrieval",
        "QA context is disabled; running general chat without selected-note retrieval."
      );
    }
    let primaryRole = this.resolveQaPrimaryRole();
    if (hasVisionAttachments && !isCloudFamily && primaryRole !== "ask_vision") {
      primaryRole = "ask_vision";
      this.emitQaEvent(
        onEvent,
        "info",
        "Vision-compatible image attachments detected; switching role to Ask (vision) for this turn."
      );
    }
    let qaModel = this.resolveQaModelForRole(primaryRole);
    const detectedModels = this.getDetectedOllamaModelNames();
    if (!isCloudFamily && !qaModel) {
      const roleRecommendation = this.getQaModelRecommendationForRole(primaryRole);
      if (roleRecommendation) {
        this.emitQaEvent(
          onEvent,
          "warning",
          `Selected ${primaryRole} model is empty; auto-selecting recommended local model: ${roleRecommendation}`
        );
        qaModel = roleRecommendation;
      }
    }
    if (!isCloudFamily && qaModel && detectedModels.length > 0 && !this.hasDetectedOllamaModel(qaModel)) {
      const roleFallback = this.getQaModelRecommendationForRole(primaryRole);
      if (roleFallback) {
        this.emitQaEvent(
          onEvent,
          "warning",
          `Selected ${primaryRole} model is not detected (${qaModel}); fallback to ${roleFallback}`
        );
        qaModel = roleFallback;
      } else {
        this.emitQaEvent(
          onEvent,
          "warning",
          `Selected ${primaryRole} model is not detected (${qaModel}); continuing with configured value.`
        );
      }
    }
    if (!isCloudFamily && hasVisionAttachments && !this.isVisionCapableModel(qaModel)) {
      const visionFallback = this.resolveVisionModelForImageAttachments();
      if (visionFallback) {
        this.emitQaEvent(
          onEvent,
          "warning",
          `Current model is text-only for image input. Switching to vision model: ${visionFallback}`
        );
        qaModel = visionFallback;
      } else {
        this.emitQaEvent(
          onEvent,
          "error",
          "No vision-capable local model detected. Image understanding is unavailable in current setup."
        );
        throw new Error(
          "\uBE44\uC804 \uBAA8\uB378\uC774 \uAC10\uC9C0\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uC774\uBBF8\uC9C0/PDF \uCCA8\uBD80\uB97C \uCC98\uB9AC\uD558\uB824\uBA74 Guide\uC758 \uBE44\uC804 \uBAA8\uB378 \uC124\uCE58 \uC548\uB0B4\uB97C \uBA3C\uC800 \uC644\uB8CC\uD558\uC138\uC694."
        );
      }
    }
    if (!qaModel) {
      throw new Error("Q&A model is empty.");
    }
    if (!isCloudFamily && !isOllamaModelAllowedForQaRole(primaryRole, qaModel)) {
      const roleFallback = this.getQaModelRecommendationForRole(primaryRole);
      if (roleFallback && roleFallback !== qaModel && isOllamaModelAllowedForQaRole(primaryRole, roleFallback)) {
        this.emitQaEvent(
          onEvent,
          "warning",
          `Q&A model is not suitable (${qaModel}); switching to recommended compatible model: ${roleFallback}`
        );
        qaModel = roleFallback;
      } else {
        throw new Error(`Q&A model is not suitable: ${qaModel}`);
      }
    }
    const routingLog = this.buildTaskRoutingForQa(safeQuestion, routingContext, qaModel);
    this.lastQaRoutingLog = {
      taskType: routingLog.taskType,
      roles: [...routingLog.roles],
      modelUsed: [...routingLog.modelUsed],
      fallbackUsed: routingLog.fallbackUsed,
      safeguardPassed: routingLog.safeguardPassed
    };
    this.emitQaEvent(
      onEvent,
      "info",
      `RoleRouter: task=${routingLog.taskType} | roles=${routingLog.roles.join(" -> ")}`
    );
    if (routingLog.modelUsed.length > 0) {
      this.emitQaEvent(
        onEvent,
        "info",
        `RoleRouter models: ${routingLog.modelUsed.join(", ")}${routingLog.fallbackUsed ? " (fallback used)" : ""}`
      );
    }
    this.emitQaEvent(onEvent, "generation", `Primary QA model selected: ${qaModel}`);
    try {
      throwIfAborted();
      let embeddingModel = this.settings.semanticOllamaModel.trim();
      let retrievalCacheHits = 0;
      let retrievalCacheWrites = 0;
      const maxContextChars = this.resolveQaContextCharLimit(intent);
      let sourceBlocks = [];
      if (selectedFiles.length > 0 && embeddingModel) {
        this.setStatus("semantic retrieval for local qa...");
        this.emitQaEvent(onEvent, "retrieval", "Embedding retrieval started");
        try {
          throwIfAborted();
          const retrievalCandidateK = this.resolveQaRetrievalCandidateK(intent, safeTopK);
          const retrieval = await searchSemanticNotesByQuery(
            this.app,
            selectedFiles,
            this.settings,
            safeQuestion,
            retrievalCandidateK,
            abortSignal
          );
          retrievalCacheHits = retrieval.cacheHits;
          retrievalCacheWrites = retrieval.cacheWrites;
          this.emitQaEvent(
            onEvent,
            "retrieval",
            `Retrieved ${retrieval.hits.length} candidates (cache hits=${retrieval.cacheHits}, writes=${retrieval.cacheWrites})`
          );
          if (retrieval.errors.length > 0) {
            this.notice(`Semantic retrieval had ${retrieval.errors.length} issue(s).`, 6e3);
            this.emitQaEvent(
              onEvent,
              "warning",
              `Retrieval warnings: ${retrieval.errors.length}`
            );
          }
          if (retrieval.hits.length === 0 && !hasExternalContext) {
            throw new Error("No relevant notes were found for this question.");
          }
          const rankedHits = this.rerankQaHits(
            retrieval.hits,
            safeQuestion,
            this.resolveQaRerankTopK(intent, safeTopK)
          );
          const queryTerms = this.tokenizeQuery(safeQuestion);
          const sourceCandidates = [];
          let usedChars = 0;
          for (const hit of rankedHits) {
            throwIfAborted();
            if (usedChars >= maxContextChars) {
              break;
            }
            const entry = this.app.vault.getAbstractFileByPath(hit.path);
            if (!(entry instanceof import_obsidian4.TFile)) {
              continue;
            }
            const raw = await this.app.vault.cachedRead(entry);
            throwIfAborted();
            const remaining = Math.max(500, maxContextChars - usedChars);
            const snippet = this.extractRelevantSnippet(raw, safeQuestion, remaining);
            if (!snippet) {
              continue;
            }
            const snippetMatch = this.countTermMatches(snippet.toLowerCase(), queryTerms);
            const relevance = hit.similarity + Math.min(0.22, snippetMatch * 0.03);
            sourceCandidates.push({
              path: hit.path,
              similarity: hit.similarity,
              content: snippet,
              relevance
            });
            usedChars += snippet.length;
          }
          sourceCandidates.sort(
            (a, b) => b.relevance - a.relevance || a.path.localeCompare(b.path)
          );
          const sourceLimit = intent === "comparison" || intent === "plan" ? Math.max(safeTopK + 2, safeTopK) : intent === "sources_only" ? Math.max(safeTopK, 5) : safeTopK;
          sourceBlocks = sourceCandidates.slice(0, sourceLimit).map((item) => ({
            path: item.path,
            similarity: item.similarity,
            content: item.content
          }));
          this.emitQaEvent(
            onEvent,
            "retrieval",
            `Context built from ${sourceBlocks.length} notes (${usedChars} chars)`
          );
        } catch (error) {
          if (this.isAbortError(error)) {
            throw error;
          }
          if (!hasExternalContext) {
            throw error;
          }
          const message = error instanceof Error ? error.message : "Unknown semantic retrieval error";
          this.emitQaEvent(
            onEvent,
            "warning",
            `Semantic retrieval failed. Falling back to attachments: ${message}`
          );
          this.notice(`Semantic retrieval fallback: ${message}`, 7e3);
          sourceBlocks = [];
        }
      } else if (selectedFiles.length > 0 && !embeddingModel) {
        if (!hasExternalContext) {
          throw new Error("Embedding model is empty. Refresh embedding detection first.");
        }
        this.emitQaEvent(
          onEvent,
          "warning",
          "Embedding model is empty. Selected-note retrieval skipped; using attachments only."
        );
        embeddingModel = "(attachments-priority)";
      } else if (!hasExternalContext && openFile instanceof import_obsidian4.TFile) {
        const openRaw = await this.app.vault.cachedRead(openFile);
        throwIfAborted();
        const snippet = this.extractRelevantSnippet(openRaw, safeQuestion, maxContextChars);
        if (snippet.trim().length > 0) {
          sourceBlocks = [{
            path: openFile.path,
            similarity: 1,
            content: snippet
          }];
          embeddingModel = "(open-file-fallback)";
          this.emitQaEvent(
            onEvent,
            "retrieval",
            `No selected scope/attachments. Using currently open file: ${openFile.path}`
          );
        } else {
          embeddingModel = "(open-file-empty)";
          this.emitQaEvent(
            onEvent,
            "warning",
            `Open file detected but no readable text: ${openFile.path}`
          );
        }
      } else if (hasExternalContext) {
        this.emitQaEvent(onEvent, "retrieval", "Skipping semantic retrieval (attachments only)");
        embeddingModel = "(attachments-only)";
      } else {
        this.emitQaEvent(onEvent, "retrieval", "No selected notes/attachments: general chat mode");
        embeddingModel = "(general-chat)";
      }
      if (normalizedExternal.textDocs.length > 0) {
        const attachmentBlocks = normalizedExternal.textDocs.map((doc, index) => ({
          path: doc.path || `[ATTACHMENT-DOC] ${doc.label || `document-${index + 1}`}`,
          similarity: 1,
          content: this.trimQaToolText(
            [
              "Attachment document (PRIMARY EVIDENCE)",
              `Label: ${doc.label || `document-${index + 1}`}`,
              doc.path ? `Original path: ${doc.path}` : "Original path: (external attachment)",
              "---",
              doc.content
            ].join("\n"),
            Math.max(900, Math.floor(maxContextChars * 0.6))
          )
        }));
        sourceBlocks = [...attachmentBlocks, ...sourceBlocks];
        this.emitQaEvent(
          onEvent,
          "retrieval",
          `Included ${attachmentBlocks.length} attached text document(s).`
        );
      }
      if (sourceBlocks.length > 0) {
        const trimmedBlocks = [];
        let used = 0;
        for (const block of sourceBlocks) {
          throwIfAborted();
          const remaining = maxContextChars - used;
          if (remaining < 160) {
            break;
          }
          const nextContent = this.trimQaToolText(block.content, remaining);
          if (!nextContent.trim()) {
            continue;
          }
          trimmedBlocks.push({
            path: block.path,
            similarity: block.similarity,
            content: nextContent
          });
          used += nextContent.length;
        }
        sourceBlocks = trimmedBlocks;
      }
      if (sourceBlocks.length === 0 && (normalizedExternal.images.length > 0 || normalizedExternal.pdfLabels.length > 0)) {
        const imageBlocks = normalizedExternal.imageItems.map((item, index) => {
          var _a2;
          return {
            path: ((_a2 = item.path) == null ? void 0 : _a2.trim()) || `[ATTACHMENT-IMAGE] ${item.label || `image-${index + 1}`}`,
            similarity: 1,
            content: "Image attachment (model should inspect attached image input)."
          };
        });
        const pdfBlocks = normalizedExternal.pdfItems.map((item, index) => {
          var _a2;
          return {
            path: ((_a2 = item.path) == null ? void 0 : _a2.trim()) || `[ATTACHMENT-PDF] ${item.label || `pdf-${index + 1}`}`,
            similarity: 1,
            content: "PDF attachment (if direct parsing is limited, request converted image/text excerpts for precise grounding)."
          };
        });
        sourceBlocks = [...pdfBlocks, ...imageBlocks];
      }
      const sourceContext = this.buildLocalQaSourceContext(sourceBlocks);
      const hasSourceContext = sourceBlocks.length > 0 || normalizedExternal.images.length > 0 || normalizedExternal.pdfLabels.length > 0;
      const attachmentLabels = [
        ...normalizedExternal.textDocs.map((doc) => `[DOC] ${doc.label}`),
        ...normalizedExternal.imageLabels.map((label) => `[IMG] ${label}`),
        ...normalizedExternal.pdfLabels.map((label) => `[PDF] ${label}`)
      ];
      const selectionInventoryContext = selectedFiles.length > 0 && this.shouldIncludeSelectionInventory(
        safeQuestion,
        selectedFiles.length,
        intent
      ) ? this.buildSelectionInventoryContext(selectedFiles) : void 0;
      const systemPrompt = this.buildLocalQaSystemPrompt(
        intent,
        preferDetailed,
        hasSourceContext,
        primaryRole,
        safeQuestion
      );
      const userPrompt = this.buildLocalQaUserPrompt(
        safeQuestion,
        sourceContext,
        selectionInventoryContext,
        attachmentLabels,
        openFilePath,
        openSelection
      );
      this.emitQaEvent(onEvent, "generation", "Generation started");
      this.setStatus("asking local qa model...");
      throwIfAborted();
      const completion = await this.requestLocalQaCompletion({
        qaBaseUrl,
        qaModel,
        systemPrompt,
        userPrompt,
        history,
        images: normalizedExternal.images,
        onToken,
        onEvent,
        abortSignal
      });
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        throw new DOMException("The operation was aborted.", "AbortError");
      }
      const split = splitThinkingBlocks(completion.answer);
      const initialAnswer = split.answer.trim() || completion.answer.trim();
      if (!initialAnswer) {
        throw new Error("Local Q&A returned an empty answer.");
      }
      const hasAgentActionBlock = this.settings.qaAgentToolModeEnabled && /```omni-forge-actions[\s\S]*?```/i.test(initialAnswer);
      let finalAnswer = initialAnswer;
      const conversationMode = this.getQaConversationModeForQa();
      const wantsGameBuild = this.isGameBuildTask(safeQuestion);
      const canRunPipelineWithoutSources = conversationMode === "orchestration" || conversationMode === "plan" || conversationMode === "agent";
      if (!hasSourceContext && !canRunPipelineWithoutSources) {
        this.emitQaEvent(
          onEvent,
          "info",
          "No source context for this turn; skipping source-based rewrite passes."
        );
      } else if (hasAgentActionBlock) {
        this.emitQaEvent(
          onEvent,
          "info",
          "Agent action block detected; skipping post-generation rewrite passes."
        );
      } else if (hasVisionAttachments) {
        this.emitQaEvent(
          onEvent,
          "info",
          "Vision-compatible attachments detected; limiting rewrite passes to safeguard-only."
        );
        const limitedStages = this.resolveQaPipelineStages(safeQuestion, intent).filter((stage) => stage === "safeguard");
        for (const stage of limitedStages) {
          throwIfAborted();
          finalAnswer = await this.applySafeguardPass({
            question: safeQuestion,
            answer: finalAnswer,
            sourceBlocks,
            qaBaseUrl,
            onEvent,
            abortSignal
          });
        }
      } else {
        if (!hasSourceContext && canRunPipelineWithoutSources) {
          this.emitQaEvent(
            onEvent,
            "info",
            "No source context, but orchestration/plan mode keeps rewrite pipeline enabled."
          );
        }
        throwIfAborted();
        finalAnswer = await this.repairQaStructureIfNeeded({
          intent,
          answer: initialAnswer,
          question: safeQuestion,
          preferDetailed,
          sourceBlocks,
          qaBaseUrl,
          qaModel,
          onEvent,
          abortSignal
        });
        const useLightweightPipeline = this.shouldUseLightweightQaPipeline(
          safeQuestion,
          intent
        );
        if (useLightweightPipeline) {
          this.emitQaEvent(
            onEvent,
            "info",
            "Simple question detected; skipping heavy pipeline passes for faster response."
          );
        }
        let pipelineStages = useLightweightPipeline ? [] : this.resolveQaPipelineStages(safeQuestion, intent);
        if (conversationMode === "agent") {
          pipelineStages = this.mapTaskRolesToStagesForQa(routingLog.roles);
          this.emitQaEvent(
            onEvent,
            "info",
            `Agent mode RoleRouter pipeline: ${pipelineStages.length > 0 ? pipelineStages.join(" -> ") : "(none)"}`
          );
        } else if (conversationMode === "orchestration" && pipelineStages.length > 0 && !pipelineStages.includes("orchestrator")) {
          pipelineStages = ["orchestrator", ...pipelineStages];
        }
        if (conversationMode === "orchestration" && wantsGameBuild) {
          const ensureStageBeforeSafeguard = (stage) => {
            if (pipelineStages.includes(stage)) {
              return;
            }
            const safeguardIndex = pipelineStages.indexOf("safeguard");
            if (safeguardIndex >= 0) {
              pipelineStages.splice(safeguardIndex, 0, stage);
            } else {
              pipelineStages.push(stage);
            }
          };
          ensureStageBeforeSafeguard("orchestrator");
          ensureStageBeforeSafeguard("architect");
          ensureStageBeforeSafeguard("coder");
          if (!pipelineStages.includes("safeguard")) {
            pipelineStages.push("safeguard");
          }
        }
        if (pipelineStages.length > 0) {
          this.emitQaEvent(
            onEvent,
            "generation",
            `Pipeline: ${pipelineStages.join(" -> ")}`
          );
          if (conversationMode === "orchestration") {
            this.emitQaEvent(
              onEvent,
              "generation",
              `Orchestration model trace: ${this.describeOrchestrationModelTrace(pipelineStages, qaModel)}`
            );
          }
        }
        for (const stage of pipelineStages) {
          throwIfAborted();
          if (stage === "orchestrator") {
            finalAnswer = await this.applyOrchestratorPass({
              question: safeQuestion,
              answer: finalAnswer,
              sourceBlocks,
              qaBaseUrl,
              onEvent,
              abortSignal
            });
            continue;
          }
          if (stage === "safeguard") {
            finalAnswer = await this.applySafeguardPass({
              question: safeQuestion,
              answer: finalAnswer,
              sourceBlocks,
              qaBaseUrl,
              onEvent,
              abortSignal
            });
            continue;
          }
          finalAnswer = await this.applyRolePresetRefinementPass({
            role: stage,
            question: safeQuestion,
            answer: finalAnswer,
            sourceBlocks,
            qaBaseUrl,
            onEvent,
            abortSignal
          });
        }
      }
      if (conversationMode === "orchestration" && wantsGameBuild && !this.hasRunnableGameScaffold(finalAnswer)) {
        this.emitQaEvent(
          onEvent,
          "warning",
          "Game request detected but runnable scaffold is missing; running focused game scaffold pass."
        );
        finalAnswer = await this.applyGameBuildScaffoldPass({
          question: safeQuestion,
          answer: finalAnswer,
          sourceBlocks,
          qaBaseUrl,
          onEvent,
          abortSignal
        });
      }
      if (conversationMode === "agent" && this.settings.qaAgentToolModeEnabled) {
        if (routingLog.taskType === "EDIT_NOTE" && openSelection) {
          finalAnswer = await this.ensureSelectionDiffActionPlan({
            question: safeQuestion,
            draftAnswer: finalAnswer,
            sourceBlocks,
            qaBaseUrl,
            qaModel,
            openFilePath,
            openSelection,
            routingLog,
            onEvent,
            abortSignal
          });
          if (!this.hasValidSelectionDiffActionInAnswer(finalAnswer, safeQuestion, qaModel, openSelection)) {
            this.emitQaEvent(
              onEvent,
              "warning",
              "EDIT_NOTE diff planner failed after retries. Apply step will remain blocked."
            );
            finalAnswer = [
              finalAnswer,
              "### EDIT_NOTE 실행 차단",
              "- 유효한 unified diff 액션 생성에 실패하여 자동 적용을 중단합니다."
            ].filter((line) => line.trim().length > 0).join("\n\n");
          }
        } else if (this.isLikelyAgentMutationTask(safeQuestion) && !this.hasMutatingQaActionInAnswer(finalAnswer, safeQuestion, qaModel)) {
          finalAnswer = await this.ensureAgentMutatingActionPlan({
            question: safeQuestion,
            draftAnswer: finalAnswer,
            sourceBlocks,
            qaBaseUrl,
            qaModel,
            openFilePath,
            onEvent,
            abortSignal
          });
        }
      }
      const shouldSkipLanguageGuard = this.settings.qaAgentToolModeEnabled && /```omni-forge-actions[\s\S]*?```/i.test(finalAnswer);
      if (!shouldSkipLanguageGuard) {
        throwIfAborted();
        finalAnswer = await this.enforcePreferredLanguageIfNeeded({
          answer: finalAnswer,
          question: safeQuestion,
          qaBaseUrl,
          qaModel,
          onEvent,
          abortSignal
        });
      }
      const mergedThinking = [completion.thinking.trim(), split.thinking.trim()].filter((item) => item.length > 0).join("\n\n").trim();
      this.emitQaEvent(onEvent, "generation", `Generation completed (${completion.endpoint})`);
      const sourceList = sourceBlocks.map((item) => ({
        path: item.path,
        similarity: item.similarity
      }));
      throwIfAborted();
      const answerWithActions = await this.applyQaAgentActionsFromAnswer({
        answer: finalAnswer,
        question: safeQuestion,
        qaModel,
        onEvent,
        abortSignal,
        openSelection,
        taskType: routingLog.taskType,
        routingLog
      });
      this.lastQaRoutingLog = {
        taskType: routingLog.taskType,
        roles: [...routingLog.roles],
        modelUsed: [...routingLog.modelUsed],
        fallbackUsed: routingLog.fallbackUsed,
        safeguardPassed: routingLog.safeguardPassed
      };
      return {
        question: safeQuestion,
        answer: answerWithActions,
        thinking: mergedThinking,
        model: qaModel,
        embeddingModel,
        sources: sourceList,
        retrievalCacheHits,
        retrievalCacheWrites
      };
    } finally {
      this.setStatus("idle");
    }
  }
  getPropertyCleanupConfig() {
    const removeKeys = new Set(this.parseSimpleList(this.settings.propertyCleanupKeys));
    const removePrefixes = this.parseSimpleList(this.settings.propertyCleanupPrefixes);
    const keepKeys = new Set(this.parseSimpleList(this.settings.propertyCleanupKeepKeys));
    if (removeKeys.size === 0 && removePrefixes.length === 0) {
      return void 0;
    }
    return {
      removeKeys,
      removePrefixes,
      keepKeys
    };
  }
  extractPathTerms(path) {
    return path.toLowerCase().replace(/\.md$/i, "").split(/[^a-z0-9가-힣]+/).map((token) => token.trim()).filter((token) => token.length >= 2);
  }
  /**
   * @typedef {Object} AutoLinkEvidence
   * @property {"topic"|"project"|"time"|"entity"|"concept"|"keyword"|"other"} type
   * @property {number} weight
   * @property {string} detail
   */
  /**
   * @typedef {Object} AutoLinkEvidenceScoring
   * @property {true} scoring
   * @property {number} weight
   * @property {string} type
   * @property {string} detail
   */
  /**
   * @typedef {Object} AutoLinkEvidenceNonScoring
   * @property {false|undefined} [scoring]
   * @property {number} [weight]
   * @property {string} type
   * @property {string} detail
   */
  /**
   * @typedef {Object} AutoLinkScoreBreakdown
   * @property {AutoLinkEvidence[]} evidences
   * @property {number} rawScore
   */
  scoreCandidatePath(sourcePath, candidatePath, scoreTarget) {
    const sourceParts = sourcePath.toLowerCase().split("/");
    const targetParts = candidatePath.toLowerCase().split("/");
    let sharedPrefix = 0;
    for (let i = 0; i < Math.min(sourceParts.length, targetParts.length); i += 1) {
      if (sourceParts[i] !== targetParts[i]) {
        break;
      }
      sharedPrefix += 1;
    }
    const sourceTerms = new Set(this.extractPathTerms(sourcePath));
    const targetTerms = this.extractPathTerms(candidatePath);
    let overlap = 0;
    for (const token of targetTerms) {
      if (sourceTerms.has(token)) {
        overlap += 1;
      }
    }
    function isScoringEvidence(e) {
      return e && e.scoring === true && typeof e.weight === "number";
    }
    const breakdown = { evidences: [], rawScore: 0 };
    if (sharedPrefix > 0) {
      breakdown.evidences.push({
        type: "project",
        weight: sharedPrefix * 2,
        scoring: true,
        detail: `shared path prefix depth=${sharedPrefix}`
      });
    }
    if (overlap > 0) {
      breakdown.evidences.push({
        type: "keyword",
        weight: overlap,
        scoring: true,
        detail: `path term overlap=${overlap}`
      });
    }
    if (breakdown.evidences.length === 0) {
      breakdown.evidences.push({
        type: "other",
        weight: 0,
        detail: "no shared path prefix or term overlap"
      });
    }
    // Only scoring evidences contribute to rawScore to preserve legacy formula equivalence.
    const rawScore = breakdown.evidences
      .filter(isScoringEvidence)
      .reduce((sum, e) => sum + e.weight, 0);
    breakdown.rawScore = rawScore;
    if (scoreTarget && typeof scoreTarget === "object") {
      // AL-1a: score breakdown scaffold for future UI; not used for ranking.
      scoreTarget._scoreBreakdown = breakdown;
    }
    return rawScore;
  }
  normalizeAnalyzeLinkedScopeModeSetting(value) {
    if (value === "selected_only" || value === "selected_plus_related" || value === "vault_sampled") {
      return value;
    }
    return DEFAULT_SETTINGS.analyzeLinkedScopeMode;
  }
  normalizeRelatedScopeMaxCandidatesSetting(value) {
    const fallback = DEFAULT_SETTINGS.relatedScopeMaxCandidates;
    if (!Number.isFinite(value)) {
      return fallback;
    }
    return Math.max(16, Math.min(LINKED_SCOPE_MAX_CANDIDATES_HARD, Math.floor(value)));
  }
  normalizeRelatedScopeTimeBudgetMsSetting(value) {
    const fallback = DEFAULT_SETTINGS.relatedScopeTimeBudgetMs;
    if (!Number.isFinite(value)) {
      return fallback;
    }
    return Math.max(50, Math.min(LINKED_SCOPE_TIME_BUDGET_MS_HARD, Math.floor(value)));
  }
  prepareLinkedScopeContext(selectedFiles, filesToAnalyze) {
    const requestedMode = this.normalizeAnalyzeLinkedScopeModeSetting(this.settings.analyzeLinkedScopeMode);
    const maxCandidates = this.normalizeRelatedScopeMaxCandidatesSetting(this.settings.relatedScopeMaxCandidates);
    const timeBudgetMs = this.normalizeRelatedScopeTimeBudgetMsSetting(this.settings.relatedScopeTimeBudgetMs);
    const selectedPathSet = new Set(
      selectedFiles.map((file) => file.path).filter((path) => typeof path === "string" && path.length > 0)
    );
    const context = {
      requestedMode,
      mode: requestedMode,
      maxCandidates,
      timeBudgetMs,
      selectedPathSet,
      relatedPool: [],
      vaultSamplePool: [],
      timedOut: false,
      fallbackReason: ""
    };
    if (requestedMode === "selected_only" || selectedPathSet.size === 0) {
      return context;
    }
    const startedAt = Date.now();
    const withinBudget = () => Date.now() - startedAt <= timeBudgetMs;
    const isEligiblePath = (path) => {
      if (typeof path !== "string") {
        return false;
      }
      const normalized = (0, import_obsidian4.normalizePath)(path.trim());
      if (!normalized || selectedPathSet.has(normalized) || this.isPathExcluded(normalized)) {
        return false;
      }
      const entry = this.app.vault.getAbstractFileByPath(normalized);
      return entry instanceof import_obsidian4.TFile && entry.extension === "md";
    };
    const rankAgainstAnchors = (path, anchors) => {
      let best = 0;
      for (const anchor of anchors) {
        const forward = this.scoreCandidatePath(anchor, path);
        const backward = this.scoreCandidatePath(path, anchor);
        const combined = Math.max(forward, backward);
        if (combined > best) {
          best = combined;
        }
        if (best >= 8) {
          break;
        }
      }
      return best;
    };
    const anchorPaths = (Array.isArray(filesToAnalyze) ? filesToAnalyze : selectedFiles).map((file) => file.path).filter((path) => typeof path === "string" && path.length > 0).slice(0, 16);
    const scoredPool = /* @__PURE__ */ new Map();
    const upsertScoredPool = (path, score) => {
      if (!isEligiblePath(path)) {
        return;
      }
      const normalized = (0, import_obsidian4.normalizePath)(path.trim());
      const safeScore = Number.isFinite(score) ? score : 0;
      const prev = scoredPool.get(normalized);
      if (!Number.isFinite(prev) || safeScore > prev) {
        scoredPool.set(normalized, safeScore);
      }
    };
    if (requestedMode === "selected_plus_related") {
      const resolvedLinks = this.app.metadataCache && this.app.metadataCache.resolvedLinks && typeof this.app.metadataCache.resolvedLinks === "object" ? this.app.metadataCache.resolvedLinks : {};
      for (const sourcePath of selectedPathSet) {
        if (!withinBudget()) {
          context.timedOut = true;
          break;
        }
        const outbound = resolvedLinks[sourcePath];
        if (!outbound || typeof outbound !== "object") {
          continue;
        }
        for (const [destPath, weightRaw] of Object.entries(outbound)) {
          if (!withinBudget()) {
            context.timedOut = true;
            break;
          }
          const weight = Number.isFinite(weightRaw) ? Number(weightRaw) : 0;
          upsertScoredPool(destPath, 10 + Math.max(0, Math.min(weight, 5)));
        }
      }
    }
    if (!context.timedOut && scoredPool.size < maxCandidates) {
      const allFiles = this.getAllMarkdownFiles();
      for (const file of allFiles) {
        if (!withinBudget()) {
          context.timedOut = true;
          break;
        }
        const path = file.path;
        if (!isEligiblePath(path)) {
          continue;
        }
        const score = rankAgainstAnchors(path, anchorPaths);
        if (requestedMode === "vault_sampled" || score > 0) {
          upsertScoredPool(path, score);
        }
      }
    }
    const rankedPool = [...scoredPool.entries()].sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0])).slice(0, maxCandidates).map(([path]) => path);
    if (requestedMode === "selected_plus_related") {
      context.relatedPool = rankedPool;
      if (context.relatedPool.length === 0) {
        context.mode = "selected_only";
        context.fallbackReason = context.timedOut ? "selected_plus_related timed out; fallback to selected_only." : "selected_plus_related produced no valid candidates; fallback to selected_only.";
      }
      return context;
    }
    context.vaultSamplePool = rankedPool;
    if (context.vaultSamplePool.length === 0) {
      context.mode = "selected_only";
      context.fallbackReason = context.timedOut ? "vault_sampled timed out; fallback to selected_only." : "vault_sampled produced no valid candidates; fallback to selected_only.";
    }
    return context;
  }
  buildScopedCandidateLinkPaths(filePath, rankedFallback, linkedScopeContext) {
    if (!linkedScopeContext || linkedScopeContext.mode === "selected_only") {
      return rankedFallback;
    }
    const pool = linkedScopeContext.mode === "vault_sampled" ? linkedScopeContext.vaultSamplePool : linkedScopeContext.relatedPool;
    if (!Array.isArray(pool) || pool.length === 0) {
      return rankedFallback;
    }
    const scopedRanked = pool.filter((path) => path !== filePath).sort((a, b) => {
      const scoreDiff = this.scoreCandidatePath(filePath, b) - this.scoreCandidatePath(filePath, a);
      if (scoreDiff !== 0) {
        return scoreDiff;
      }
      return a.localeCompare(b);
    });
    if (linkedScopeContext.mode === "vault_sampled") {
      return mergeUniqueStrings(scopedRanked, rankedFallback);
    }
    return mergeUniqueStrings(rankedFallback, scopedRanked);
  }
  getCandidateLinkPathsForFile(filePath, selectedFiles, semanticNeighbors, linkedScopeContext) {
    var _a;
    const fallback = selectedFiles.filter((candidate) => candidate.path !== filePath).map((candidate) => candidate.path);
    const candidateLimit = Math.max(
      this.settings.maxLinked * 6,
      this.settings.semanticTopK,
      this.normalizeRelatedScopeMaxCandidatesSetting(this.settings.relatedScopeMaxCandidates),
      ANALYSIS_HARD_MAX_CANDIDATES
    );
    const rankedFallback = [...fallback].sort((a, b) => {
      const scoreDiff = this.scoreCandidatePath(filePath, b) - this.scoreCandidatePath(filePath, a);
      if (scoreDiff !== 0) {
        return scoreDiff;
      }
      return a.localeCompare(b);
    });
    const scopedCandidates = this.buildScopedCandidateLinkPaths(
      filePath,
      rankedFallback,
      linkedScopeContext
    );
    if (!semanticNeighbors || !this.settings.semanticLinkingEnabled) {
      return scopedCandidates.slice(0, candidateLimit);
    }
    const semantic = ((_a = semanticNeighbors.get(filePath)) != null ? _a : []).map((item) => item.path);
    if (semantic.length === 0) {
      return scopedCandidates.slice(0, candidateLimit);
    }
    return mergeUniqueStrings(semantic, scopedCandidates).slice(0, candidateLimit);
  }
  normalizeFolderPrefix(path) {
    const normalized = (0, import_obsidian4.normalizePath)(path.trim());
    return normalized.endsWith("/") ? normalized : `${normalized}/`;
  }
  isPathInsideFolder(filePath, folderPath) {
    const fileNormalized = (0, import_obsidian4.normalizePath)(filePath);
    const folderNormalized = (0, import_obsidian4.normalizePath)(folderPath);
    if (!fileNormalized || !folderNormalized) {
      return false;
    }
    if (fileNormalized === folderNormalized) {
      return true;
    }
    return fileNormalized.startsWith(this.normalizeFolderPrefix(folderNormalized));
  }
  parseWatchedFolders() {
    const normalizedRoots = this.settings.watchNewNotesFolders.split(/[\n,;]+/).map((item) => (0, import_obsidian4.normalizePath)(item.trim())).filter((item) => item.length > 0).filter((item) => this.isSafeVaultRelativePath(item)).sort((a, b) => a.localeCompare(b));
    shadowComputePR3ScopeEnforcementFromSettings(normalizedRoots, this.settings);
    return normalizedRoots;
  }
  resolveMatchedWatchedFolder(filePath) {
    const watchedFolders = this.parseWatchedFolders();
    for (const folder of watchedFolders) {
      if (this.isPathInsideFolder(filePath, folder)) {
        return folder;
      }
    }
    return null;
  }
  isManagedOutputPath(path) {
    try {
      const chatRoot = this.resolveSafeFolderPath(
        this.settings.chatTranscriptRootPath,
        "Omni Forge Chats",
        "Chat transcript"
      );
      if (this.isPathInsideFolder(path, chatRoot)) {
        return true;
      }
    } catch (e) {
    }
    try {
      const reportRoot = this.resolveSafeFolderPath(
        this.settings.cleanupReportRootPath,
        "Omni Forge Reports",
        "Cleanup dry-run report"
      );
      if (this.isPathInsideFolder(path, reportRoot)) {
        return true;
      }
    } catch (e) {
    }
    try {
      const backupRoot = this.resolveSafeFolderPath(
        this.settings.backupRootPath,
        "Omni Forge Backups",
        "Backup root"
      );
      if (this.isPathInsideFolder(path, backupRoot)) {
        return true;
      }
    } catch (e) {
    }
    return false;
  }
  async addFileToSelection(filePath) {
    const normalized = (0, import_obsidian4.normalizePath)(filePath);
    if (!normalized || this.isPathExcluded(normalized)) {
      return "already";
    }
    const alreadySelected = this.getSelectedFiles().some((file) => file.path === normalized);
    if (alreadySelected || this.settings.targetFilePaths.includes(normalized)) {
      return "already";
    }
    this.settings.targetFilePaths = [...this.settings.targetFilePaths, normalized].sort(
      (a, b) => a.localeCompare(b)
    );
    await this.saveSettings();
    return "added";
  }
  async handleWatchedNewFile(file) {
    if (!this.settings.watchNewNotesEnabled) {
      return;
    }
    if (this.isPathExcluded(file.path) || this.isManagedOutputPath(file.path)) {
      return;
    }
    const matchedFolder = this.resolveMatchedWatchedFolder(file.path);
    if (!matchedFolder) {
      return;
    }
    if (this.pendingNewNoteWatchPrompts.has(file.path)) {
      return;
    }
    this.pendingNewNoteWatchPrompts.add(file.path);
    try {
      const decision = await NewNoteWatchModal.ask(this.app, file.path, matchedFolder);
      if (decision.action === "ignore") {
        return;
      }
      const addResult = await this.addFileToSelection(file.path);
      if (decision.action === "add_only") {
        if (addResult === "added") {
          this.notice(`Added to selection: ${file.path}`, 5e3);
        } else {
          this.notice(`Already included in selection: ${file.path}`, 4e3);
        }
        return;
      }
      if (addResult === "added") {
        this.notice(`Added and analyzing: ${file.path}`, 5e3);
      } else {
        this.notice(`Analyzing with current selection: ${file.path}`, 5e3);
      }
      await this.runAnalysis();
    } finally {
      this.pendingNewNoteWatchPrompts.delete(file.path);
    }
  }
  isParserInboxTargetFile(file) {
    if (!(file instanceof import_obsidian4.TFile)) {
      return false;
    }
    const ext = file.extension.toLowerCase();
    if (!["pdf", "docx", "xlsx", "hwp", "hwpx", "png", "jpg", "jpeg", "webp"].includes(ext)) {
      return false;
    }
    const inboxRoot = (0, import_obsidian4.normalizePath)((this.settings.qaParserInboxFolder || "inbox").trim() || "inbox");
    if (!inboxRoot) {
      return false;
    }
    return this.isPathInsideFolder(file.path, inboxRoot);
  }
  escapeXml(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/'/g, "&apos;");
  }
  async extractXlsxTextWithPython(xlsxAbsolutePath) {
    const command = [
      "python3 - <<'PY'",
      "import zipfile,sys,re,xml.etree.ElementTree as ET",
      `p=r'''${this.shellQuoteArg(xlsxAbsolutePath).replace(/^'|'$/g, "")}'''`,
      "ns='{http://schemas.openxmlformats.org/spreadsheetml/2006/main}'",
      "out=[]",
      "with zipfile.ZipFile(p,'r') as z:",
      "  shared=[]",
      "  if 'xl/sharedStrings.xml' in z.namelist():",
      "    root=ET.fromstring(z.read('xl/sharedStrings.xml'))",
      "    for si in root.findall(f'{ns}si'):",
      "      txt=''.join(t.text or '' for t in si.iter(f'{ns}t'))",
      "      shared.append(txt)",
      "  sheets=sorted([n for n in z.namelist() if re.match(r'xl/worksheets/sheet\\d+\\.xml$', n)])",
      "  for sheet in sheets:",
      "    root=ET.fromstring(z.read(sheet))",
      "    out.append(f'## {sheet.split('/')[-1]}')",
      "    for row in root.findall(f'.//{ns}row'):",
      "      cells=[]",
      "      for c in row.findall(f'{ns}c'):",
      "        t=c.get('t','')",
      "        v=(c.find(f'{ns}v').text if c.find(f'{ns}v') is not None else '')",
      "        if t=='s' and v.isdigit() and int(v)<len(shared):",
      "          cells.append(shared[int(v)])",
      "        else:",
      "          cells.append(v)",
      "      if any((x or '').strip() for x in cells):",
      "        out.append('\t'.join(cells))",
      "print('\\n'.join(out)[:18000])",
      "PY"
    ].join("\n");
    const result = await execAsync(command, { timeout: 6e4, maxBuffer: 1024 * 1024 * 8 });
    return String(result.stdout || "").trim();
  }
  async extractDocxTextWithPython(docxAbsolutePath) {
    const command = [
      "python3 - <<'PY'",
      "import zipfile,re,xml.etree.ElementTree as ET",
      `p=r'''${this.shellQuoteArg(docxAbsolutePath).replace(/^'|'$/g, "")}'''`,
      "ns='{http://schemas.openxmlformats.org/wordprocessingml/2006/main}'",
      "targets=['word/document.xml']",
      "with zipfile.ZipFile(p,'r') as z:",
      "  targets += sorted([n for n in z.namelist() if re.match(r'word/(header|footer)\\d+\\.xml$', n)])",
      "  out=[]",
      "  for part in targets:",
      "    if part not in z.namelist():",
      "      continue",
      "    root=ET.fromstring(z.read(part))",
      "    lines=[]",
      "    for para in root.iter(f'{ns}p'):",
      "      txt=''.join((t.text or '') for t in para.iter(f'{ns}t')).strip()",
      "      if txt:",
      "        lines.append(txt)",
      "    if lines:",
      "      out.append(f'## {part.split('/')[-1]}')",
      "      out.extend(lines)",
      "print('\\n'.join(out)[:18000])",
      "PY"
    ].join("\n");
    const result = await execAsync(command, { timeout: 6e4, maxBuffer: 1024 * 1024 * 8 });
    return String(result.stdout || "").trim();
  }
  buildParserDiagnosticFileId(filePath, ext) {
    const safePath = typeof filePath === "string" ? filePath : "";
    const safeExt = typeof ext === "string" && ext.trim() ? ext.trim().toLowerCase() : "unknown";
    return `${safeExt}:${this.hashString(safePath).slice(0, 10)}`;
  }
  emitParserDiagnostic(event, level = "info") {
    if (!event || typeof console === "undefined") {
      return;
    }
    const payload = {
      at: (/* @__PURE__ */ new Date()).toISOString(),
      event: "parser_inbox",
      ...event
    };
    const line = `[Omni-Forge][parser][diag] ${JSON.stringify(payload)}`;
    if (level === "error" && typeof console.warn === "function") {
      console.warn(line);
      return;
    }
    if (typeof console.info === "function") {
      console.info(line);
    }
  }
  classifyParserAbortReason(message, ext) {
    const normalized = typeof message === "string" ? message.toLowerCase() : "";
    if (normalized.includes("hwp 처리 취소") || normalized.includes("hwp processing cancelled") || normalized.includes("user_cancel")) {
      return "user_cancel";
    }
    if (normalized.includes("unsupported parser input")) {
      return "unsupported_input";
    }
    if (normalized.includes("readbinary api unavailable") || normalized.includes("input binary unavailable")) {
      return "vault_readbinary_unavailable";
    }
    if (normalized.includes("soffice missing") || normalized.includes("command not found")) {
      return "soffice_unavailable";
    }
    if (normalized.includes("soffice failed")) {
      return "soffice_failed";
    }
    if (normalized.includes("pdf parser chain unavailable") || normalized.includes("pdf parser chain failed")) {
      return "pdf_parser_failed";
    }
    if (normalized.includes("pdftotext failed")) {
      return "pdftotext_failed";
    }
    if (normalized.includes("pdfminer failed")) {
      return "pdfminer_failed";
    }
    if (normalized.includes("ocr failed") || normalized.includes("tesseract")) {
      return "ocr_failed";
    }
    if (normalized.includes("empty_extraction")) {
      return "empty_extraction";
    }
    if (normalized.includes("hwp_conversion_not_supported") || normalized.includes("hwp conversion not supported")) {
      return "hwp_conversion_not_supported";
    }
    if (ext === "hwp" || ext === "hwpx") {
      return "hwp_conversion_not_supported";
    }
    return "conversion_failed";
  }
  getParserRetryGuidance(reasonCode, ext) {
    switch (reasonCode) {
      case "user_cancel":
        return "Ingest was canceled by user. Re-upload the same file when ready.";
      case "hwp_conversion_not_supported":
        return "HWP/HWPX auto conversion is unavailable. Convert to PDF or DOCX manually, then upload again.";
      case "soffice_unavailable":
        return "LibreOffice (soffice) is missing. Install LibreOffice and ensure soffice is on PATH.";
      case "soffice_failed":
        return "LibreOffice conversion failed. Open the source file in LibreOffice and export PDF manually.";
      case "pdf_parser_failed":
        return "PDF parse chain failed after conversion. Retry in Detailed parser mode or run OCR fallback tools.";
      case "unsupported_input":
        return "Supported parser formats: PDF, DOCX, XLSX, PNG/JPG/JPEG/WEBP, HWP/HWPX.";
      case "vault_readbinary_unavailable":
        return "Vault adapter readBinary is unavailable in this runtime. Update Obsidian/plugin runtime and retry.";
      case "ocr_failed":
        return "Switch parser mode to Detailed and verify pdftoppm + tesseract installation for OCR fallback.";
      case "pdftotext_failed":
      case "pdfminer_failed":
        return "PDF text extract failed. Refresh parser tool readiness and retry with OCR fallback.";
      case "empty_extraction":
        return "Extraction returned empty text. Retry with a higher-quality source (300dpi+ recommended).";
      default:
        if (ext === "hwp" || ext === "hwpx") {
          return "HWP/HWPX conversion failed. Manual PDF conversion is recommended as fallback.";
        }
        return "Retry once. If it still fails, check parser diagnostics logs (stage/reason).";
    }
  }
  buildParserInboxOutputDocument(payload) {
    const normalizedContent = this.normalizeParserExtractedText(payload.content || "", {
      forOcr: false,
      normalizeSpacing: true
    });
    const format = this.settings.qaParserIngestOutputFormat === "xml" ? "xml" : "md";
    const parserMode = payload.parserMode === "detailed" ? "detailed" : "fast";
    const reasonCode = typeof payload.reasonCode === "string" && payload.reasonCode.trim() ? payload.reasonCode.trim() : "ok";
    const lowConfidence = Boolean(payload.lowConfidence);
    const parserQuality = lowConfidence ? "low_confidence" : "ok";
    const parserNotes = Array.isArray(payload.parserNotes) ? payload.parserNotes.filter((line) => typeof line === "string" && line.trim().length > 0).slice(0, 6) : [];
    if (format === "xml") {
      const text = this.escapeXml(normalizedContent);
      const notesXml = parserNotes.length > 0 ? `\n  <notes>\n${parserNotes.map((line) => `    <note>${this.escapeXml(line)}</note>`).join("\n")}\n  </notes>` : "";
      return `<?xml version="1.0" encoding="UTF-8"?>\n<parser_ingest source_path="${this.escapeXml(payload.sourcePath)}" source_kind="${this.escapeXml(payload.kind)}" parser="${this.escapeXml(payload.parser)}" parser_mode="${this.escapeXml(parserMode)}" parser_quality="${this.escapeXml(parserQuality)}" parser_reason="${this.escapeXml(reasonCode)}" created_at="${new Date().toISOString()}">\n  <content>${text}</content>${notesXml}\n</parser_ingest>\n`;
    }
    const lines = [
      "---",
      "parser_ingest: true",
      `source_kind: ${payload.kind}`,
      `source_path: \"${payload.sourcePath.replace(/\"/g, '\\\"')}\"`,
      `parser: ${payload.parser}`,
      `parser_mode: ${parserMode}`,
      `parser_quality: ${parserQuality}`,
      `parser_reason: ${reasonCode}`,
      `created_at: ${new Date().toISOString()}`,
      "---",
      "",
      `# Inbox Parsed: ${payload.sourcePath}`,
      ""
    ];
    if (parserNotes.length > 0) {
      lines.push(
        "## Parser diagnostics",
        ...parserNotes.map((line) => `- ${line}`),
        ""
      );
    }
    lines.push(normalizedContent);
    return lines.join("\n");
  }
  async handleParserInboxFileCreate(file, options) {
    const force = Boolean(options == null ? void 0 : options.force);
    const forceOcr = Boolean(options == null ? void 0 : options.forceOcr);
    if (!force && !this.settings.qaParserInboxWatchEnabled) {
      return;
    }
    if (!this.isParserInboxTargetFile(file)) {
      return;
    }
    this.setParserInboxLastEvent({
      fileName: file.name,
      result: "queued",
      message: "Parser inbox queued"
    });
    const currentQueue = Math.max(0, (this.parserInboxMetrics.queueLength || 0) + 1);
    this.updateParserInboxMetrics({
      stage: this.parserInboxMetrics.stage === "scanning" ? "scanning" : "queueing",
      queueLength: currentQueue,
      total: Math.max(this.parserInboxMetrics.total || 0, (this.parserInboxMetrics.processed || 0) + currentQueue),
      startedAt: this.parserInboxMetrics.startedAt || Date.now(),
      lastFile: file.name,
      lastResult: "queued"
    });
    if (this.parserInboxInFlightPaths.has(file.path)) {
      return;
    }
    this.parserInboxInFlightPaths.add(file.path);
    const run = async () => {
      let parseStage = "queued";
      let parseReasonCode = "ok";
      let ext = file.extension.toLowerCase();
      let parser = "";
      let parserDiagnostics = null;
      let parserNotes = [];
      const parserMode = this.getQaParserModeForQa();
      const fileId = this.buildParserDiagnosticFileId(file.path, ext);
      try {
        this.updateParserInboxMetrics({
          stage: "converting",
          lastFile: file.name,
          lastResult: "processing"
        });
        parseStage = "detect-input";
        ext = file.extension.toLowerCase();
        const baseNoExt = file.path.replace(/\.[^.]+$/, "");
        const outputExt = this.settings.qaParserIngestOutputFormat === "xml" ? "xml" : "md";
        const outPath = `${baseNoExt}.parser.${outputExt}`;
        let content = "";
        if (ext === "pdf") {
          parseStage = "pdf-read-binary";
          const adapter = this.app.vault.adapter;
          if (typeof adapter.readBinary !== "function") {
            throw new Error("readBinary API unavailable for PDF parser.");
          }
          const binary = await adapter.readBinary(file.path);
          const absolutePath = this.resolveVaultAbsolutePath(file.path);
          parseStage = "pdf-parse-chain";
          const parsed = await this.extractPdfTextWithParserChain(binary, absolutePath, { forceOcr });
          content = parsed.content;
          parser = `pdf:${parsed.parser}`;
          parserDiagnostics = parsed.diagnostics || null;
          parserNotes = Array.isArray(parsed.notes) ? parsed.notes : [];
          parseReasonCode = (parserDiagnostics == null ? void 0 : parserDiagnostics.reasonCode) || "ok";
        } else if (ext === "docx") {
          parseStage = "docx-parse";
          const absolutePath = this.resolveVaultAbsolutePath(file.path);
          content = await this.extractDocxTextWithPython(absolutePath);
          parser = "docx:python-zip-xml";
        } else if (ext === "xlsx") {
          parseStage = "xlsx-parse";
          const absolutePath = this.resolveVaultAbsolutePath(file.path);
          content = await this.extractXlsxTextWithPython(absolutePath);
          parser = "xlsx:python-zip-xml";
        } else if (ext === "png" || ext === "jpg" || ext === "jpeg" || ext === "webp") {
          parseStage = "image-read-binary";
          const adapter = this.app.vault.adapter;
          if (typeof adapter.readBinary !== "function") {
            throw new Error("readBinary API unavailable for image parser.");
          }
          const binary = await adapter.readBinary(file.path);
          const absolutePath = this.resolveVaultAbsolutePath(file.path);
          parseStage = "image-parse-chain";
          const parsed = await this.extractImageTextWithParserChain(binary, absolutePath, ext);
          content = parsed.content;
          parser = `image:${parsed.parser}`;
          parserDiagnostics = parsed.diagnostics || null;
          parserNotes = Array.isArray(parsed.notes) ? parsed.notes : [];
          parseReasonCode = (parserDiagnostics == null ? void 0 : parserDiagnostics.reasonCode) || "ok";
        } else if (ext === "hwp" || ext === "hwpx") {
          parseStage = "hwp-guided-choice";
          const choice = await this.promptHwpIngestChoice(file.name, 0);
          const choiceLabel = choice === "pdf_only" ? "PDF만" : choice === "pdf_to_md" ? "PDF→MD" : "취소";
          if (choice === "cancel") {
            const cancelMessage = `HWP/HWPX 선택 결과: ${choiceLabel} | skip | auto=not_attempted`;
            this.setParserInboxLastEvent({
              fileName: file.name,
              result: "skip",
              message: cancelMessage
            });
            if (typeof console !== "undefined" && typeof console.info === "function") {
              console.info(`[Omni-Forge][parser][hwp-choice] ${file.path} -> ${choiceLabel} (skip | auto=not_attempted)`);
            }
            throw new Error("HWP 처리 취소");
          }
          let hwpResult = "guided";
          let statusMeta = "auto=not_attempted";
          let autoResult = null;
          if (choice === "pdf_to_md" && ext === "hwp") {
            parseStage = "hwp-soffice-poc";
            const adapter = this.app.vault.adapter;
            let binary = null;
            if (typeof adapter.readBinary === "function") {
              binary = await adapter.readBinary(file.path);
            }
            autoResult = await runHwpToPdfParserPocWithSoffice({
              ext,
              fileName: file.name,
              binary,
              parsePdf: typeof this.extractPdfTextWithParserChain === "function" ? async (pdfBinary, pdfAbsolutePath) => await this.extractPdfTextWithParserChain(pdfBinary, pdfAbsolutePath, { forceOcr }) : null
            });
            statusMeta = `auto=${describeHwpAutoConvertStatus(autoResult.status, autoResult.message)}`;
            if (autoResult.ok && autoResult.parsed) {
              const parsed = autoResult.parsed;
              parser = `hwp:soffice->pdf:${parsed.parser}`;
              content = parsed.content;
              parserDiagnostics = parsed.diagnostics || null;
              parserNotes = [
                `hwp auto-convert: ${describeHwpAutoConvertStatus(autoResult.status)}`,
                ...(Array.isArray(parsed.notes) ? parsed.notes : [])
              ];
              parseReasonCode = (parserDiagnostics == null ? void 0 : parserDiagnostics.reasonCode) || "hwp_soffice_autoconvert";
              hwpResult = "converted";
            }
          }
          if (!parser) {
            parser = choice === "pdf_only" ? "hwp:guided-pdf-only" : "hwp:guided-pdf-to-md";
            const autoLine = choice === "pdf_to_md" && ext === "hwp" ? `자동 변환 상태: ${statusMeta.replace(/^auto=/, "")}` : "자동 변환 상태: not_attempted";
            content = choice === "pdf_only" ? [
            `HWP guide: ${file.name}`,
            "선택: PDF까지만 변환(권장)",
            "상태: HWP 자동변환은 실행하지 않았습니다.",
            "다음 단계: 외부 도구에서 HWP→PDF 변환 후 PDF를 다시 업로드하세요."
          ].join("\n") : [
            `HWP guide: ${file.name}`,
            "선택: PDF 변환 후 MD까지 진행(사용자 수동 변환 필요)",
            autoLine,
            "다음 단계: 외부 도구에서 HWP→PDF 변환 후 PDF 업로드 시 parser ingest(.md/.xml)로 이어서 처리하세요."
          ].join("\n");
            parseReasonCode = autoResult && autoResult.status && autoResult.status !== "ok" ? `hwp_${autoResult.status}` : "hwp_conversion_not_supported";
          }
          const hwpMessage = `HWP/HWPX 선택 결과: ${choiceLabel} | ${hwpResult} | ${statusMeta}${hwpResult === "guided" ? " | fallback guide" : ""}`;
          this.setParserInboxLastEvent({
            fileName: file.name,
            result: hwpResult,
            message: hwpMessage
          });
          if (typeof console !== "undefined" && typeof console.info === "function") {
            console.info(`[Omni-Forge][parser][hwp-choice] ${file.path} -> ${choiceLabel} (${hwpResult} | ${statusMeta})`);
          }
        } else {
          parseStage = "unsupported-input";
          throw new Error(`Unsupported parser input extension: .${ext}`);
        }
        this.updateParserInboxMetrics({
          stage: "writing",
          lastFile: file.name,
          lastResult: "writing"
        });
        parseStage = "write-output";
        const document = this.buildParserInboxOutputDocument({
          kind: ext,
          sourcePath: file.path,
          parser,
          parserMode,
          reasonCode: parseReasonCode,
          lowConfidence: Boolean(parserDiagnostics == null ? void 0 : parserDiagnostics.lowConfidence),
          parserNotes,
          content: this.clampAttachmentText(content || "", 2e4)
        });
        await this.writeVaultTextFile(outPath, document);
        this.setParserInboxLastEvent({
          fileName: file.name,
          result: "success",
          message: `converted -> ${outPath} (${parser}) | mode=${parserMode}`
        });
        this.updateParserInboxMetrics({
          stage: (this.parserInboxMetrics.queueLength || 1) - 1 > 0 ? "queueing" : "done",
          processed: (this.parserInboxMetrics.processed || 0) + 1,
          success: (this.parserInboxMetrics.success || 0) + 1,
          queueLength: Math.max(0, (this.parserInboxMetrics.queueLength || 1) - 1),
          lastFile: file.name,
          lastResult: "success"
        });
        this.emitParserDiagnostic({
          fileId,
          ext,
          stage: parseStage,
          result: "success",
          reasonCode: parseReasonCode,
          parser,
          parserMode,
          forceOcr,
          noteCount: parserNotes.length,
          lowConfidence: Boolean(parserDiagnostics == null ? void 0 : parserDiagnostics.lowConfidence),
          strongOcrAttempted: Boolean(parserDiagnostics == null ? void 0 : parserDiagnostics.strongOcrAttempted),
          toolStatus: {
            pdftotext: this.parserToolStatus.pdftotext === true,
            pdftoppm: this.parserToolStatus.pdftoppm === true,
            tesseract: this.parserToolStatus.tesseract === true,
            soffice: this.parserToolStatus.soffice === true
          }
        });
        this.notice(`Parser inbox converted: ${file.path} -> ${outPath}`, 6e3);
      } catch (error) {
        const message = error instanceof Error ? error.message : "Parser inbox conversion failed";
        const reasonCode = this.classifyParserAbortReason(message, ext);
        const guidance = this.getParserRetryGuidance(reasonCode, ext);
        const isSkip = reasonCode === "user_cancel" || reasonCode === "unsupported_input" || reasonCode === "hwp_conversion_not_supported";
        const summary = `[${parseStage}/${reasonCode}] ${message}${guidance ? ` | ${guidance}` : ""}`;
        this.setParserInboxLastEvent({
          fileName: file.name,
          result: isSkip ? "skip" : "error",
          message: summary
        });
        this.updateParserInboxMetrics({
          stage: isSkip ? "skip" : (this.parserInboxMetrics.queueLength || 1) - 1 > 0 ? "queueing" : "done",
          processed: (this.parserInboxMetrics.processed || 0) + 1,
          skip: (this.parserInboxMetrics.skip || 0) + (isSkip ? 1 : 0),
          error: (this.parserInboxMetrics.error || 0) + (isSkip ? 0 : 1),
          queueLength: Math.max(0, (this.parserInboxMetrics.queueLength || 1) - 1),
          lastFile: file.name,
          lastResult: isSkip ? "skip" : "error"
        });
        this.emitParserDiagnostic({
          fileId,
          ext,
          stage: parseStage,
          result: isSkip ? "skip" : "error",
          reasonCode,
          parserMode,
          forceOcr,
          toolStatus: {
            pdftotext: this.parserToolStatus.pdftotext === true,
            pdftoppm: this.parserToolStatus.pdftoppm === true,
            tesseract: this.parserToolStatus.tesseract === true,
            soffice: this.parserToolStatus.soffice === true
          }
        }, isSkip ? "info" : "error");
        this.notice(`Parser inbox ${isSkip ? "skipped" : "failed"} (${file.path}): ${summary}`, 8e3);
      } finally {
        this.parserInboxInFlightPaths.delete(file.path);
        if ((this.parserInboxMetrics.queueLength || 0) === 0 && (this.parserInboxMetrics.total || 0) > 0 && (this.parserInboxMetrics.processed || 0) >= (this.parserInboxMetrics.total || 0)) {
          this.updateParserInboxMetrics({ stage: "done", etaMs: 0 });
        }
      }
    };
    this.parserInboxQueue = this.parserInboxQueue.then(run, run);
    await this.parserInboxQueue;
  }
  buildAutoTagCandidatePaths(file) {
    const selected = this.getSelectedFiles().filter((candidate) => candidate.path !== file.path).map((candidate) => candidate.path);
    if (selected.length > 0) {
      return selected.slice(0, ANALYSIS_HARD_MAX_CANDIDATES);
    }
    return this.getAllMarkdownFiles().filter((candidate) => candidate.path !== file.path).sort((a, b) => {
      const scoreDiff = this.scoreCandidatePath(file.path, b.path) - this.scoreCandidatePath(file.path, a.path);
      if (scoreDiff !== 0) {
        return scoreDiff;
      }
      return a.path.localeCompare(b.path);
    }).slice(0, ANALYSIS_HARD_MAX_CANDIDATES).map((candidate) => candidate.path);
  }
  async runAutoTagForFile(file, source) {
    var _a, _b, _c, _d;
    if (this.isPathExcluded(file.path)) {
      return;
    }
    const vaultRelativePath = typeof file.path === "string" ? file.path.replace(/\\/g, "/").replace(/\/+/g, "/") : "";
    const pr3Scope = createPR3Step2ScopeFromSettings(this.settings);
    const pr3Gate = checkPR3ScopeGate({
      scope: pr3Scope,
      vaultRelativePath
    });
    const enforceEnabled = pr3Scope.mode === "enforce" && this.settings.pr3ScopeEnforceAck === true;
    if (enforceEnabled && pr3Scope.status === "ok" && pr3Gate.decision === "deny") {
      this.notice(
        `PR3 scope (enforce): blocked because target is outside allowed roots. Reason=${pr3Gate.reason}`,
        6e3
      );
      return;
    }
    if (pr3Scope.mode === "enforce" && (pr3Scope.status === "ambiguous" || pr3Scope.status === "empty" || pr3Scope.status === "invalid")) {
      this.notice(
        `PR3 scope (enforce): non-decisive scope (${pr3Scope.status}); enforcement not applied. Reason=${pr3Gate.reason}`,
        6e3
      );
    } else if (pr3Scope.mode === "enforce" && !enforceEnabled && pr3Gate.decision !== "allow") {
      this.notice(
        `PR3 scope (enforce): ack required; enforcement not applied. This would be blocked after ack. Reason=${pr3Gate.reason}`,
        6e3
      );
    } else if (!enforceEnabled && pr3Scope.mode === "warn-only" && pr3Gate.decision !== "allow") {
      this.notice(
        `PR3 scope (warn-only): this operation is outside allowed roots and would be blocked in enforce mode. Reason=${pr3Gate.reason}`,
        6e3
      );
    }
    if (this.autoTagInFlightPaths.has(file.path)) {
      return;
    }
    const cooldownSec = Math.max(10, this.settings.autoTagActiveNoteCooldownSec);
    const cooldownMs = cooldownSec * 1e3;
    const now = Date.now();
    const lastRun = (_a = this.autoTagLastRunByPath.get(file.path)) != null ? _a : 0;
    if (source === "auto" && now - lastRun < cooldownMs) {
      return;
    }
    if (this.settings.provider === "ollama") {
      const selectedModel = this.settings.ollamaModel.trim();
      if (!selectedModel || !isOllamaModelAnalyzable(selectedModel)) {
        if (source === "manual") {
          this.notice("Auto-tag skipped: select an analyzable Ollama model first.", 5e3);
        }
        return;
      }
    }
    this.autoTagInFlightPaths.add(file.path);
    this.autoTagLastRunByPath.set(file.path, now);
    try {
      const analysisCache = await this.loadAnalysisCache();
      const providerCacheSignature = this.getProviderCacheSignature();
      const settingsSignature = this.buildAnalysisSettingsSignature(providerCacheSignature);
      const candidateLinkPaths = this.buildAutoTagCandidatePaths(file);
      const selectionSignature = this.hashString(
        JSON.stringify([file.path, ...candidateLinkPaths])
      );
      const signatureInput = {
        sourcePath: file.path,
        candidateLinkPaths,
        maxTags: this.settings.maxTags,
        maxLinked: this.settings.maxLinked,
        analyzeTags: true,
        analyzeTopic: false,
        analyzeLinked: false,
        forceAllToAllLinkedEnabled: false,
        analyzeIndex: false,
        includeReasons: this.settings.includeReasons
      };
      const cacheKey = this.buildAnalysisCacheKey(providerCacheSignature, file.path);
      const requestSignature = this.buildAnalysisRequestSignature(
        providerCacheSignature,
        signatureInput
      );
      const cachedOutcome = this.getCachedAnalysisOutcome(
        analysisCache,
        cacheKey,
        requestSignature,
        file,
        settingsSignature,
        selectionSignature
      );
      let outcome;
      if (cachedOutcome) {
        outcome = cachedOutcome;
      } else {
        outcome = await analyzeWithFallback(this.settings, {
          ...signatureInput,
          sourceText: await this.app.vault.cachedRead(file)
        }, this.settings.oauthEnabled === true ? async () => await this.getOAuthAuthHeadersForQa() : void 0);
        this.storeAnalysisOutcome(
          analysisCache,
          cacheKey,
          requestSignature,
          settingsSignature,
          selectionSignature,
          file,
          outcome
        );
      }
      const existingFrontmatter = (_c = (_b = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _b.frontmatter) != null ? _c : {};
      const existingTags = normalizeTags(this.readRawFrontmatterTags(existingFrontmatter));
      const proposedTags = normalizeTags(
        ((_d = outcome.proposal.tags) != null ? _d : []).slice(0, this.settings.maxTags)
      );
      const mergedTags = normalizeTags(mergeUniqueStrings(existingTags, proposedTags));
      const unchanged = mergedTags.length === existingTags.length && mergedTags.every((item, idx) => item === existingTags[idx]);
      if (unchanged || mergedTags.length === 0) {
        if (source === "manual") {
          this.notice("Auto-tag: no tag changes for active note.", 4e3);
        }
      } else {
        await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
          const current = frontmatter;
          current.tags = mergedTags;
        });
        if (source === "manual") {
          this.notice(`Auto-tag applied: ${file.path} (${mergedTags.length} tags)`, 5e3);
        }
      }
      if (this.analysisCacheDirty) {
        await this.flushAnalysisCache();
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown auto-tag error";
      if (source === "manual") {
        this.notice(`Auto-tag failed: ${message}`, 6e3);
      }
    } finally {
      this.autoTagInFlightPaths.delete(file.path);
    }
  }
  async handleAutoTagOnFileOpen(file) {
    if (!this.settings.autoTagActiveNoteEnabled) {
      return;
    }
    await this.runAutoTagForFile(file, "auto");
  }
  parseExcludedPatterns() {
    return this.settings.excludedFolderPatterns.split(/[\n,;]+/).map((item) => item.trim().toLowerCase()).filter((item) => item.length > 0);
  }
  isPathExcluded(path) {
    const lower = path.toLowerCase();
    const patterns = this.parseExcludedPatterns();
    return patterns.some((pattern) => lower.includes(pattern));
  }
  getAllMarkdownFiles() {
    return this.app.vault.getMarkdownFiles().filter((file) => !this.isPathExcluded(file.path)).sort((a, b) => a.path.localeCompare(b.path));
  }
  getAllFolders() {
    const folders = this.app.vault.getAllLoadedFiles().filter(
      (entry) => entry instanceof import_obsidian4.TFolder && entry.path.trim().length > 0 && !this.isPathExcluded(entry.path)
    );
    return folders.sort((a, b) => a.path.localeCompare(b.path));
  }
  collectFilesFromFolder(folder, includeSubfolders, out) {
    if (this.isPathExcluded(folder.path)) {
      return;
    }
    for (const child of folder.children) {
      if (child instanceof import_obsidian4.TFile && child.extension === "md") {
        if (!this.isPathExcluded(child.path)) {
          out.add(child.path);
        }
        continue;
      }
      if (child instanceof import_obsidian4.TFolder && includeSubfolders) {
        this.collectFilesFromFolder(child, includeSubfolders, out);
      }
    }
  }
  getSelectedFiles() {
    const selectedPaths = /* @__PURE__ */ new Set();
    for (const path of this.settings.targetFilePaths) {
      if (this.isPathExcluded(path)) {
        continue;
      }
      const entry = this.app.vault.getAbstractFileByPath(path);
      if (entry instanceof import_obsidian4.TFile && entry.extension === "md") {
        selectedPaths.add(entry.path);
      }
    }
    for (const folderPath of this.settings.targetFolderPaths) {
      if (this.isPathExcluded(folderPath)) {
        continue;
      }
      const entry = this.app.vault.getAbstractFileByPath(folderPath);
      if (entry instanceof import_obsidian4.TFolder) {
        this.collectFilesFromFolder(
          entry,
          this.settings.includeSubfoldersInFolderSelection,
          selectedPaths
        );
      }
    }
    const out = [];
    for (const path of selectedPaths) {
      const entry = this.app.vault.getAbstractFileByPath(path);
      if (entry instanceof import_obsidian4.TFile && entry.extension === "md") {
        out.push(entry);
      }
    }
    return out.sort((a, b) => a.path.localeCompare(b.path));
  }
  async openSelectionModal(context = null) {
    const allFiles = this.getAllMarkdownFiles();
    const allFolders = this.getAllFolders();
    new SelectionModal(
      this.app,
      allFiles,
      allFolders,
      this.settings.targetFilePaths,
      this.settings.targetFolderPaths,
      this.settings.includeSubfoldersInFolderSelection,
      this.settings.selectionPathWidthPercent,
      async (payload) => {
        this.settings.targetFilePaths = payload.selectedFilePaths;
        this.settings.targetFolderPaths = payload.selectedFolderPaths;
        this.settings.includeSubfoldersInFolderSelection = payload.includeSubfolders;
        this.settings.selectionPathWidthPercent = payload.pathWidthPercent;
        if (typeof console !== "undefined" && typeof console.debug === "function") {
          console.debug("[Omni-Forge][PR3][SelectionModalSave]", {
            selectedFilePathsCount: Array.isArray(payload.selectedFilePaths) ? payload.selectedFilePaths.length : 0,
            selectedFolderPathsCount: Array.isArray(payload.selectedFolderPaths) ? payload.selectedFolderPaths.length : 0,
            includeSubfolders: payload.includeSubfolders,
            pathWidthPercent: payload.pathWidthPercent
          });
        }
        // Persist Selection Modal source-of-truth state before dependent flows consume it.
        await this.saveSettings();
        const expandedCount = this.getSelectedFiles().length;
        this.notice(
          `Selection saved. Files: ${payload.selectedFilePaths.length}, folders: ${payload.selectedFolderPaths.length}, expanded markdown files: ${expandedCount}`,
          5e3
        );
      },
      context
    ).open();
  }
  async askBackupDecision() {
    return BackupConfirmModal.ask(this.app, this.settings.backupBeforeApply);
  }
  async backupSelectedNotesNow() {
    const selectedFiles = this.getSelectedFiles();
    if (selectedFiles.length === 0) {
      this.notice("No selected notes to back up. Select targets first.");
      return;
    }
    const backupFolder = await this.createBackupForFiles(selectedFiles);
    this.notice(
      backupFolder ? `Backup created: ${backupFolder}` : "Backup skipped (no files).",
      5e3
    );
  }
  async runPropertyCleanup(dryRun) {
    const selectedFiles = this.getSelectedFiles();
    if (selectedFiles.length === 0) {
      this.notice("No target notes selected. Open selector first.");
      await this.openSelectionModal();
      return;
    }
    const cleanupConfig = this.getPropertyCleanupConfig();
    if (!cleanupConfig && !this.settings.cleanUnknownFrontmatter) {
      this.notice(
        "No cleanup rules configured. Set cleanup keys/prefixes or enable legacy key cleanup first.",
        6e3
      );
      return;
    }
    let backupFolder = null;
    if (!dryRun) {
      const decision = await this.askBackupDecision();
      if (!decision.proceed) {
        this.notice("Cleanup cancelled.");
        return;
      }
      if (decision.rememberAsDefault) {
        this.settings.backupBeforeApply = decision.backupBeforeRun;
        await this.saveSettings();
      }
      if (decision.backupBeforeRun) {
        this.setStatus("creating backup...");
        backupFolder = await this.createBackupForFiles(selectedFiles);
        if (backupFolder) {
          this.notice(`Backup completed before cleanup: ${backupFolder}`, 5e3);
        }
      }
    }
    const progressModal = new RunProgressModal(
      this.app,
      dryRun ? "Dry-run cleanup for selected frontmatter" : "Cleaning selected frontmatter"
    );
    progressModal.open();
    const errors = [];
    const events = [];
    const startedAt = Date.now();
    let cancelled = false;
    let changedFiles = 0;
    let removedKeysTotal = 0;
    const dryRunReportRows = [];
    for (let index = 0; index < selectedFiles.length; index += 1) {
      if (progressModal.isCancelled()) {
        cancelled = true;
        break;
      }
      const file = selectedFiles[index];
      progressModal.update({
        stage: dryRun ? "Dry-run" : "Cleaning",
        current: index + 1,
        total: selectedFiles.length,
        startedAt,
        currentFile: file.path,
        errors,
        events
      });
      this.setStatus(
        `${dryRun ? "dry-run cleanup" : "cleaning"} ${index + 1}/${selectedFiles.length}`
      );
      try {
        if (dryRun) {
          const snapshot = await this.readFrontmatterSnapshot(file);
          if (!snapshot || Object.keys(snapshot).length === 0) {
            events.push({ filePath: file.path, status: "ok", message: "no-frontmatter" });
            continue;
          }
          const previewCleaned = cleanupFrontmatterRecord(snapshot, {
            cleanUnknown: this.settings.cleanUnknownFrontmatter,
            cleanupConfig
          });
          const previewRemoved = previewCleaned.removedKeys;
          if (previewRemoved.length === 0) {
            events.push({ filePath: file.path, status: "ok", message: "no-change" });
            continue;
          }
          changedFiles += 1;
          removedKeysTotal += previewRemoved.length;
          events.push({
            filePath: file.path,
            status: "ok",
            message: `would remove ${previewRemoved.length}`
          });
          dryRunReportRows.push(`## ${file.path}`);
          dryRunReportRows.push(
            `- Remove keys (${previewRemoved.length}): ${previewRemoved.sort((a, b) => a.localeCompare(b)).join(", ")}`
          );
          dryRunReportRows.push(
            `- Before keys: ${Object.keys(snapshot).sort((a, b) => a.localeCompare(b)).join(", ")}`
          );
          dryRunReportRows.push(
            `- After keys: ${Object.keys(previewCleaned.next).sort((a, b) => a.localeCompare(b)).join(", ")}`
          );
          dryRunReportRows.push("");
          continue;
        }
        let removedForFile = 0;
        await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
          const current = frontmatter;
          const cleaned = cleanupFrontmatterRecord(current, {
            cleanUnknown: this.settings.cleanUnknownFrontmatter,
            cleanupConfig
          });
          removedForFile = cleaned.removedKeys.length;
          if (removedForFile === 0) {
            return;
          }
          for (const key of Object.keys(current)) {
            delete current[key];
          }
          for (const [key, value] of Object.entries(cleaned.next)) {
            current[key] = value;
          }
        });
        if (removedForFile === 0) {
          events.push({ filePath: file.path, status: "ok", message: "no-change" });
          continue;
        }
        changedFiles += 1;
        removedKeysTotal += removedForFile;
        events.push({
          filePath: file.path,
          status: "ok",
          message: `removed ${removedForFile}`
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : "Unknown cleanup error";
        errors.push({ filePath: file.path, message });
        events.push({ filePath: file.path, status: "error", message });
      }
    }
    progressModal.setFinished(
      cancelled ? `${dryRun ? "Dry-run cleanup" : "Cleanup"} stopped by user.` : `${dryRun ? "Dry-run cleanup" : "Cleanup"} complete: ${changedFiles} changed of ${selectedFiles.length}`
    );
    progressModal.close();
    this.setStatus(
      cancelled ? `${dryRun ? "dry-run cleanup" : "cleanup"} stopped (${changedFiles}/${selectedFiles.length})` : `${dryRun ? "dry-run cleanup" : "cleanup"} done (${changedFiles}/${selectedFiles.length})`
    );
    let reportPath = null;
    if (dryRun) {
      const removeKeys = cleanupConfig ? [...cleanupConfig.removeKeys].sort((a, b) => a.localeCompare(b)).join(", ") : "(none)";
      const removePrefixes = cleanupConfig ? cleanupConfig.removePrefixes.join(", ") || "(none)" : "(none)";
      const keepKeys = cleanupConfig ? [...cleanupConfig.keepKeys].sort((a, b) => a.localeCompare(b)).join(", ") : "(none)";
      const lines = [];
      lines.push("# Omni Forge Cleanup Dry-Run Report");
      lines.push("");
      lines.push(`Generated: ${(/* @__PURE__ */ new Date()).toISOString()}`);
      lines.push(`Selected files: ${selectedFiles.length}`);
      lines.push(`Would change files: ${changedFiles}`);
      lines.push(`Would remove keys total: ${removedKeysTotal}`);
      lines.push(`Legacy cleanup enabled: ${this.settings.cleanUnknownFrontmatter}`);
      lines.push(`Cleanup keys: ${removeKeys || "(none)"}`);
      lines.push(`Cleanup prefixes: ${removePrefixes}`);
      lines.push(`Keep keys: ${keepKeys || "(none)"}`);
      lines.push("");
      if (dryRunReportRows.length === 0) {
        lines.push("No files would change.");
      } else {
        lines.push(...dryRunReportRows);
      }
      try {
        const reportFolder = this.resolveSafeFolderPath(
          this.settings.cleanupReportRootPath,
          "Omni Forge Reports",
          "Cleanup dry-run report"
        );
        reportPath = (0, import_obsidian4.normalizePath)(
          `${reportFolder}/cleanup-dry-run-${formatBackupStamp(/* @__PURE__ */ new Date())}.md`
        );
        await this.ensureParentFolder(reportPath);
        await this.app.vault.adapter.write(
          reportPath,
          `${lines.join("\n").trim()}
`
        );
      } catch (error) {
        const message = error instanceof Error ? error.message : "Unknown dry-run report error";
        this.notice(`Dry-run report write failed: ${message}`, 6e3);
      }
    }
    const summary = `${dryRun ? "Dry-run cleanup" : "Cleanup"} finished. Changed files=${changedFiles}, removed keys=${removedKeysTotal}, errors=${errors.length}${cancelled ? " (stopped early)" : ""}.`;
    if (dryRun && reportPath) {
      this.notice(`${summary} Report: ${reportPath}`, 8e3);
      return;
    }
    if (backupFolder) {
      this.notice(`${summary} Backup: ${backupFolder}`, 7e3);
    } else {
      this.notice(summary, 6e3);
    }
  }
  async runAnalysis() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const selectedFiles = this.getSelectedFiles();
    if (selectedFiles.length === 0) {
      this.notice("No target notes selected. Open selector first.");
      await this.openSelectionModal();
      return;
    }
    if (this.settings.provider === "ollama") {
      const selectedModel = this.settings.ollamaModel.trim();
      if (!selectedModel) {
        this.notice("Ollama model is empty. Refresh model detection and select one.");
        return;
      }
      if (!isOllamaModelAnalyzable(selectedModel)) {
        this.notice(
          `Selected Ollama model is marked as (\uBD88\uAC00): ${selectedModel}. Choose a chat/instruct model first.`,
          6e3
        );
        return;
      }
    }
    if (this.settings.semanticLinkingEnabled && this.settings.analyzeLinked) {
      const embeddingModel = this.settings.semanticOllamaModel.trim();
      if (!embeddingModel) {
        this.notice(
          "Embedding model is empty. Refresh embedding detection and select one.",
          6e3
        );
        return;
      }
      if (!isOllamaModelEmbeddingCapable(embeddingModel)) {
        this.notice(
          `Selected embedding model is marked as (\uBD88\uAC00): ${embeddingModel}. Choose an embedding model first.`,
          6e3
        );
        return;
      }
    }
    const analysisCache = await this.loadAnalysisCache();
    const providerCacheSignature = this.getProviderCacheSignature();
    const settingsSignature = this.buildAnalysisSettingsSignature(providerCacheSignature);
    const selectionSignature = this.buildSelectionSignature(selectedFiles);
    let skippedUnchanged = 0;
    let filesToAnalyze = selectedFiles;
    if (this.settings.analysisOnlyChangedNotes) {
      const pending = [];
      for (const file of selectedFiles) {
        const cacheKey = this.buildAnalysisCacheKey(providerCacheSignature, file.path);
        if (this.canSkipByChangedOnlyMode(
          analysisCache,
          cacheKey,
          file,
          settingsSignature,
          selectionSignature
        )) {
          skippedUnchanged += 1;
          continue;
        }
        pending.push(file);
      }
      filesToAnalyze = pending;
      if (filesToAnalyze.length === 0) {
        this.setStatus("analysis done (unchanged cache hit)");
        this.notice(
          `No changed notes to analyze. Selected=${selectedFiles.length}, SkippedUnchanged=${skippedUnchanged}.`,
          5e3
        );
        return;
      }
      this.notice(
        `Changed-only mode: ${skippedUnchanged} skipped, ${filesToAnalyze.length} queued.`,
        4e3
      );
    }
    const capacityModelLabel = getProviderModelLabel(this.settings);
    const recommendedMax = this.estimateRecommendedSelectionMax(capacityModelLabel);
    if (filesToAnalyze.length >= Math.floor(recommendedMax * 0.85)) {
      this.notice(
        `Selected ${filesToAnalyze.length}. Recommended max for current model is about ${recommendedMax}.`,
        5e3
      );
    }
    if (filesToAnalyze.length > recommendedMax) {
      const capacityDecision = await CapacityGuardModal.ask(
        this.app,
        filesToAnalyze.length,
        recommendedMax,
        capacityModelLabel,
        this.settings.semanticLinkingEnabled && this.settings.analyzeLinked
      );
      if (!capacityDecision.proceed) {
        this.notice("Analysis cancelled due to large selection size.");
        return;
      }
    }
    const forceAllToAllLinked = this.settings.analyzeLinked && this.settings.forceAllToAllLinkedEnabled;
    if (forceAllToAllLinked) {
      this.notice(
        "All-to-all linked mode is ON. Each note will include all selected notes (except itself).",
        6e3
      );
    }
    const decision = await this.askBackupDecision();
    if (!decision.proceed) {
      this.notice("Analysis cancelled.");
      return;
    }
    if (decision.rememberAsDefault) {
      this.settings.backupBeforeApply = decision.backupBeforeRun;
      await this.saveSettings();
    }
    let backupFolder = null;
    if (decision.backupBeforeRun) {
      this.setStatus("creating backup...");
      backupFolder = await this.createBackupForFiles(filesToAnalyze);
      if (backupFolder) {
        this.notice(`Backup completed before analysis: ${backupFolder}`, 5e3);
      }
    }
    let semanticNeighbors = /* @__PURE__ */ new Map();
    const shouldBuildSemanticNeighbors = this.settings.semanticLinkingEnabled && this.settings.analyzeLinked && !forceAllToAllLinked;
    if (shouldBuildSemanticNeighbors) {
      this.setStatus("building semantic candidates...");
      try {
        const semanticScopeFiles = this.settings.analysisOnlyChangedNotes ? filesToAnalyze : selectedFiles;
        const semanticResult = await buildSemanticNeighborMap(
          this.app,
          semanticScopeFiles,
          this.settings
        );
        semanticNeighbors = semanticResult.neighborMap;
        const neighborCount = [...semanticResult.neighborMap.values()].reduce(
          (sum, items) => sum + items.length,
          0
        );
        this.notice(
          `Semantic candidates ready: vectors=${semanticResult.generatedVectors}, cacheHits=${semanticResult.cacheHits}, cacheWrites=${semanticResult.cacheWrites}, edges=${neighborCount}, model=${semanticResult.model}.`,
          5e3
        );
        if (semanticResult.errors.length > 0) {
          this.notice(
            `Semantic embedding had ${semanticResult.errors.length} issue(s). Falling back per file where needed.`,
            6e3
          );
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "Unknown semantic embedding error";
        this.notice(`Semantic candidate ranking skipped: ${message}`, 6e3);
      }
    } else if (forceAllToAllLinked && this.settings.semanticLinkingEnabled) {
      this.notice(
        "Semantic candidate build skipped because all-to-all linked mode is ON.",
        5e3
      );
    }
    const progressModal = new RunProgressModal(this.app, "Analyzing selected notes");
    progressModal.open();
    const selectedPathSet = new Set(selectedFiles.map((file) => file.path));
    const linkedScopeContext = this.settings.analyzeLinked && !forceAllToAllLinked ? this.prepareLinkedScopeContext(selectedFiles, filesToAnalyze) : {
      requestedMode: "selected_only",
      mode: "selected_only",
      relatedPool: [],
      vaultSamplePool: [],
      timedOut: false,
      fallbackReason: ""
    };
    if (this.settings.analyzeLinked && !forceAllToAllLinked && linkedScopeContext.requestedMode !== "selected_only") {
      if (linkedScopeContext.mode !== linkedScopeContext.requestedMode && linkedScopeContext.fallbackReason) {
        this.notice(
          `Linked scope fallback: ${linkedScopeContext.fallbackReason}`,
          5e3
        );
      } else {
        const poolSize = linkedScopeContext.mode === "vault_sampled" ? linkedScopeContext.vaultSamplePool.length : linkedScopeContext.relatedPool.length;
        this.notice(
          `Linked scope mode=${linkedScopeContext.mode}, candidates=${poolSize}${linkedScopeContext.timedOut ? " (time budget reached)" : ""}.`,
          5e3
        );
      }
    }
    const suggestions = [];
    const errors = [];
    const events = [];
    const runStartedAt = Date.now();
    let usedFallbackCount = 0;
    let analysisCacheHits = 0;
    let analysisCacheWrites = 0;
    let cancelled = false;
    for (let index = 0; index < filesToAnalyze.length; index += 1) {
      if (progressModal.isCancelled()) {
        cancelled = true;
        break;
      }
      const file = filesToAnalyze[index];
      progressModal.update({
        stage: "Analyzing",
        current: index + 1,
        total: filesToAnalyze.length,
        startedAt: runStartedAt,
        currentFile: file.path,
        errors,
        events
      });
      this.setStatus(`analyzing ${index + 1}/${filesToAnalyze.length}`);
      try {
        const candidateLinkPaths = this.getCandidateLinkPathsForFile(
          file.path,
          selectedFiles,
          semanticNeighbors,
          linkedScopeContext
        );
        const analyzeLinkedByModel = this.settings.analyzeLinked && !forceAllToAllLinked;
        const candidateLinkPathsForRequest = analyzeLinkedByModel ? candidateLinkPaths : [];
        const shouldCollectAutoLinkScoreDetails = this.settings.showAutoLinkScoreDetails && this.settings.suggestionMode;
        const shouldBuildLinkedDiffPreview = this.settings.suggestionMode && this.settings.analyzeLinked;
        const autoLinkScoreDetails = shouldCollectAutoLinkScoreDetails ? candidateLinkPathsForRequest.map((path) => {
          const scoreTarget = {};
          this.scoreCandidatePath(file.path, path, scoreTarget);
          return scoreTarget._scoreBreakdown ? { path, _scoreBreakdown: scoreTarget._scoreBreakdown } : null;
        }).filter((item) => item) : [];
        let sourceText = null;
        if (shouldBuildLinkedDiffPreview) {
          sourceText = await this.app.vault.cachedRead(file);
        }
        const signatureInput = {
          sourcePath: file.path,
          candidateLinkPaths: candidateLinkPathsForRequest,
          maxTags: this.settings.maxTags,
          maxLinked: this.settings.maxLinked,
          analyzeTags: this.settings.analyzeTags,
          analyzeTopic: this.settings.analyzeTopic,
          analyzeLinked: analyzeLinkedByModel,
          forceAllToAllLinkedEnabled: forceAllToAllLinked,
          analyzeIndex: this.settings.analyzeIndex,
          includeReasons: this.settings.includeReasons
        };
        const cacheKey = this.buildAnalysisCacheKey(providerCacheSignature, file.path);
        const requestSignature = this.buildAnalysisRequestSignature(
          providerCacheSignature,
          signatureInput
        );
        const cachedOutcome = this.getCachedAnalysisOutcome(
          analysisCache,
          cacheKey,
          requestSignature,
          file,
          settingsSignature,
          selectionSignature
        );
        let outcome;
        if (cachedOutcome) {
          outcome = cachedOutcome;
          analysisCacheHits += 1;
        } else {
          const requestSourceText = sourceText !== null ? sourceText : await this.app.vault.cachedRead(file);
          sourceText = requestSourceText;
          const request = {
            ...signatureInput,
            sourceText: requestSourceText
          };
          outcome = await analyzeWithFallback(
            this.settings,
            request,
            this.settings.oauthEnabled === true ? async () => await this.getOAuthAuthHeadersForQa() : void 0
          );
          this.storeAnalysisOutcome(
            analysisCache,
            cacheKey,
            requestSignature,
            settingsSignature,
            selectionSignature,
            file,
            outcome
          );
          analysisCacheWrites += 1;
        }
        if (outcome.meta.usedFallback) {
          usedFallbackCount += 1;
        }
        const currentFrontmatter = (_b = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) != null ? _b : {};
        const rawExistingTags = this.readRawFrontmatterTags(currentFrontmatter);
        const existingBase = normalizeManagedFrontmatter(
          extractManagedFrontmatter(currentFrontmatter)
        );
        const existingValidated = {
          tags: existingBase.tags,
          topic: existingBase.topic,
          linked: normalizeLinked(this.app, file.path, existingBase.linked),
          index: existingBase.index
        };
        const existingForComparison = {
          tags: rawExistingTags,
          topic: existingValidated.topic,
          linked: existingValidated.linked,
          index: existingValidated.index
        };
        const proposed = {
          tags: existingValidated.tags,
          topic: existingValidated.topic,
          linked: existingValidated.linked,
          index: existingValidated.index
        };
        let linkedUnifiedDiffPreview = null;
        if (this.settings.analyzeTags) {
          const proposedTags = normalizeTags(
            ((_c = outcome.proposal.tags) != null ? _c : []).slice(0, this.settings.maxTags)
          );
          proposed.tags = mergeUniqueStrings(existingValidated.tags, proposedTags);
        }
        if (this.settings.analyzeTopic) {
          const maybeTopic = (_d = outcome.proposal.topic) == null ? void 0 : _d.trim();
          if (maybeTopic) {
            proposed.topic = maybeTopic;
          }
        }
        if (this.settings.analyzeLinked) {
          const linkedSource = forceAllToAllLinked ? selectedFiles.filter((candidate) => candidate.path !== file.path).map((candidate) => candidate.path) : ((_e = outcome.proposal.linked) != null ? _e : []).slice(0, this.settings.maxLinked);
          const linkedAllowedPathSet = forceAllToAllLinked ? selectedPathSet : new Set(
            mergeUniqueStrings([...selectedPathSet], candidateLinkPathsForRequest)
          );
          const proposedLinked = normalizeLinked(
            this.app,
            file.path,
            linkedSource,
            linkedAllowedPathSet
          );
          proposed.linked = mergeUniqueStrings(existingValidated.linked, proposedLinked);
          if (shouldBuildLinkedDiffPreview && typeof sourceText === "string") {
            const normalizedFilePath = typeof file.path === "string" ? file.path.replace(/\\/g, "/").replace(/\/+/g, "/") : "";
            const pr3Scope = createPR3Step2ScopeFromSettings(this.settings);
            const pr3Gate = checkPR3ScopeGate({
              scope: pr3Scope,
              vaultRelativePath: normalizedFilePath
            });
            const scopeDiagnostics = diagnosePathAgainstRootsV1(file.path, pr3Scope.roots);
            if (scopeDiagnostics.length > 0 && typeof console !== "undefined" && typeof console.warn === "function") {
              console.warn("[Omni-Forge] path semantics diagnostics", file.path, scopeDiagnostics.join(", "));
            }
            const diffSuggestions = proposedLinked.map((path) => ({
              path,
              score: 1
            }));
            const linkedDiffResult = BrainLinkQualityEngineV1.proposeLinkedFrontmatterUnifiedDiffV1({
              target: {
                path: file.path,
                folderPath: file.path.includes("/") ? file.path.slice(0, file.path.lastIndexOf("/")) : "",
                content: sourceText
              },
              existingLinked: existingValidated.linked,
              suggestions: diffSuggestions,
              policy: {
                maxLinked: existingValidated.linked.length + proposedLinked.length,
                topN: diffSuggestions.length,
                minScore: 0
              },
              scopeContext: {
                pr3Status: pr3Scope.status,
                scopeDecision: pr3Gate.decision
              }
            });
            const linkedDiffScope = linkedDiffResult && linkedDiffResult.meta && linkedDiffResult.meta.scope && typeof linkedDiffResult.meta.scope === "object" ? linkedDiffResult.meta.scope : null;
            linkedUnifiedDiffPreview = {
              diffText: linkedDiffResult && linkedDiffResult.proposal && typeof linkedDiffResult.proposal.diff === "string" ? linkedDiffResult.proposal.diff : "",
              changed: Boolean(linkedDiffResult && linkedDiffResult.proposal && linkedDiffResult.proposal.changed === true),
              scope: linkedDiffScope || void 0
            };
          }
        }
        if (this.settings.analyzeIndex) {
          const maybeIndex = (_f = outcome.proposal.index) == null ? void 0 : _f.trim();
          if (maybeIndex) {
            proposed.index = maybeIndex;
          }
        }
        const normalizedProposed = normalizeManagedFrontmatter(proposed);
        if (!managedFrontmatterChanged(existingForComparison, normalizedProposed)) {
          continue;
        }
        const semanticCandidates = ((_g = semanticNeighbors.get(file.path)) != null ? _g : []).map((item) => ({
          path: item.path,
          similarity: item.similarity
        }));
        suggestions.push({
          file,
          existing: existingForComparison,
          proposed: normalizedProposed,
          reasons: (_h = outcome.proposal.reasons) != null ? _h : {},
          analysis: outcome.meta,
          semanticCandidates,
          ...(autoLinkScoreDetails.length > 0 ? { autoLinkScoreDetails } : {}),
          ...(linkedUnifiedDiffPreview ? { linkedUnifiedDiffPreview } : {})
        });
        events.push({
          filePath: file.path,
          status: "ok",
          message: normalizedProposed.tags.length > 0 ? "suggested" : "no-change"
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : "Unknown analysis error";
        errors.push({ filePath: file.path, message });
        events.push({ filePath: file.path, status: "error", message });
      }
    }
    if (analysisCacheWrites > 0 || this.analysisCacheDirty) {
      try {
        await this.flushAnalysisCache();
      } catch (error) {
        const message = error instanceof Error ? error.message : "Unknown analysis cache write error";
        this.notice(`Analysis cache write failed: ${message}`, 6e3);
      }
    }
    progressModal.setFinished(
      cancelled ? "Analysis stopped by user." : `Analysis complete: ${suggestions.length} changed of ${filesToAnalyze.length}`
    );
    progressModal.close();
    const summary = {
      provider: this.settings.provider,
      model: getProviderModelLabel(this.settings),
      totalFiles: filesToAnalyze.length,
      changedFiles: suggestions.length,
      usedFallbackCount,
      elapsedMs: Date.now() - runStartedAt,
      cancelled,
      errorCount: errors.length
    };
    this.setStatus(`analysis done (${summary.changedFiles}/${summary.totalFiles} changed)`);
    if (suggestions.length === 0) {
      this.notice(
        `No metadata changes. Provider=${summary.provider}, Model=${summary.model}, Errors=${summary.errorCount}, Elapsed=${formatDurationMs(summary.elapsedMs)}, CacheHits=${analysisCacheHits}, CacheWrites=${analysisCacheWrites}, SkippedUnchanged=${skippedUnchanged}.`,
        5e3
      );
      return;
    }
    if (cancelled) {
      this.notice(
        `Analysis stopped. Showing partial suggestions (${suggestions.length} file(s)). CacheHits=${analysisCacheHits}, CacheWrites=${analysisCacheWrites}, SkippedUnchanged=${skippedUnchanged}.`,
        5e3
      );
    }
    this.notice(
      `Analysis complete: ${summary.changedFiles}/${summary.totalFiles} changed. CacheHits=${analysisCacheHits}, CacheWrites=${analysisCacheWrites}, SkippedUnchanged=${skippedUnchanged}, Elapsed=${formatDurationMs(summary.elapsedMs)}.`,
      5e3
    );
    if (this.settings.suggestionMode) {
      new SuggestionPreviewModal(
        this.app,
        summary,
        suggestions,
        this.settings.includeReasons,
        this.settings.showAutoLinkScoreDetails,
        async () => {
          const applyResult2 = await this.applySuggestions(
            suggestions,
            selectedFiles,
            backupFolder,
            decision.backupBeforeRun,
            decision.backupBeforeRun
          );
          if (!applyResult2.cancelled && this.settings.generateMoc) {
            await this.generateMocFromSelection(suggestions);
          }
        }
      ).open();
      return;
    }
    const applyResult = await this.applySuggestions(
      suggestions,
      selectedFiles,
      backupFolder,
      decision.backupBeforeRun,
      decision.backupBeforeRun
    );
    if (!applyResult.cancelled && this.settings.generateMoc) {
      await this.generateMocFromSelection(suggestions);
    }
  }
  async applySuggestions(suggestions, selectedFilesForBackup, existingBackupFolder, alreadyBackedUp, backupEnabledForRun) {
    let backupFolder = existingBackupFolder;
    if (!alreadyBackedUp && backupEnabledForRun) {
      backupFolder = await this.createBackupForFiles(selectedFilesForBackup);
    }
    const progressModal = new RunProgressModal(this.app, "Applying suggestions");
    progressModal.open();
    const errors = [];
    const events = [];
    const startedAt = Date.now();
    const cleanupConfig = this.settings.propertyCleanupEnabled ? this.getPropertyCleanupConfig() : void 0;
    let cancelled = false;
    for (let index = 0; index < suggestions.length; index += 1) {
      if (progressModal.isCancelled()) {
        cancelled = true;
        break;
      }
      const suggestion = suggestions[index];
      progressModal.update({
        stage: "Applying",
        current: index + 1,
        total: suggestions.length,
        startedAt,
        currentFile: suggestion.file.path,
        errors,
        events
      });
      this.setStatus(`applying ${index + 1}/${suggestions.length}`);
      try {
        await this.app.fileManager.processFrontMatter(
          suggestion.file,
          (frontmatter) => {
            const current = frontmatter;
            const next = buildNextFrontmatter(current, suggestion.proposed, {
              cleanUnknown: this.settings.cleanUnknownFrontmatter,
              sortArrays: this.settings.sortArrays,
              cleanupConfig
            });
            for (const key of Object.keys(current)) {
              delete current[key];
            }
            for (const [key, value] of Object.entries(next)) {
              current[key] = value;
            }
          }
        );
        if (this.settings.analyzeLinked) {
          const beforeContent = await this.app.vault.cachedRead(suggestion.file);
          const nextContent = this.upsertManagedGraphLinkBlock(beforeContent, suggestion.proposed.linked);
          if (nextContent !== beforeContent) {
            await this.app.vault.modify(suggestion.file, nextContent);
          }
        }
        events.push({ filePath: suggestion.file.path, status: "ok", message: "applied" });
      } catch (error) {
        const message = error instanceof Error ? error.message : "Unknown apply error";
        errors.push({ filePath: suggestion.file.path, message });
        events.push({ filePath: suggestion.file.path, status: "error", message });
      }
    }
    progressModal.setFinished(
      cancelled ? "Apply stopped by user." : `Apply complete: ${suggestions.length - errors.length} succeeded`
    );
    progressModal.close();
    this.setStatus(
      cancelled ? `apply stopped (${suggestions.length - errors.length}/${suggestions.length})` : `apply done (${suggestions.length - errors.length}/${suggestions.length})`
    );
    if (backupFolder) {
      this.notice(
        `Apply finished. Backup: ${backupFolder}. Errors: ${errors.length}${cancelled ? " (stopped early)" : ""}`,
        6e3
      );
    } else {
      this.notice(
        `Apply finished. Errors: ${errors.length}${cancelled ? " (stopped early)" : ""}`,
        5e3
      );
    }
    return { cancelled, errors };
  }
  buildManagedGraphLinkBlock(linkTokens) {
    const startMarker = "<!-- OMNI_FORGE_LINKED_START -->";
    const endMarker = "<!-- OMNI_FORGE_LINKED_END -->";
    const lines = [
      startMarker,
      "## Omni Forge Linked",
      ...linkTokens.map((token) => `- ${token}`),
      endMarker
    ];
    return `${lines.join("\n")}\n`;
  }
  upsertManagedGraphLinkBlock(content, linkTokens) {
    const source = typeof content === "string" ? content : "";
    const startMarker = "<!-- OMNI_FORGE_LINKED_START -->";
    const endMarker = "<!-- OMNI_FORGE_LINKED_END -->";
    const nextBlock = this.buildManagedGraphLinkBlock(linkTokens);
    const startIdx = source.indexOf(startMarker);
    const endIdx = source.indexOf(endMarker);
    if (startIdx >= 0 && endIdx > startIdx) {
      const afterEnd = endIdx + endMarker.length;
      const suffix = source.slice(afterEnd).replace(/^\r?\n/, "");
      const prefix = source.slice(0, startIdx).replace(/\s*$/, "\n\n");
      return `${prefix}${nextBlock}${suffix}`;
    }
    const trimmed = source.replace(/\s*$/, "");
    if (!trimmed) {
      return nextBlock;
    }
    return `${trimmed}\n\n${nextBlock}`;
  }
  async applyLinkedEdgesForGraphView() {
    const selectedFiles = this.getSelectedFiles();
    if (selectedFiles.length < 2) {
      this.notice("Select at least 2 target notes first.");
      await this.openSelectionModal();
      return;
    }
    const approved = typeof window !== "undefined" && typeof window.confirm === "function" ? window.confirm("Apply linked edges to selected notes now? (Graph View reflected after write)") : true;
    if (!approved) {
      this.notice("Apply cancelled. (NO-OP)");
      return;
    }
    let updated = 0;
    const errors = [];
    for (const file of selectedFiles) {
      try {
        const targets = selectedFiles.filter((candidate) => candidate.path !== file.path);
        const linkTokens = targets.map((candidate) => {
          const linkText = this.app.metadataCache.fileToLinktext(candidate, file.path, true);
          return `[[${linkText}]]`;
        });
        const currentContent = await this.app.vault.cachedRead(file);
        const nextContent = this.upsertManagedGraphLinkBlock(currentContent, linkTokens);
        if (nextContent !== currentContent) {
          await this.app.vault.modify(file, nextContent);
          updated += 1;
        }
        await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
          frontmatter.linked = [...linkTokens];
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : "Unknown graph-link apply error";
        errors.push(`${file.path}: ${message}`);
      }
    }
    if (errors.length > 0) {
      this.notice(`Graph link apply completed with errors (${updated}/${selectedFiles.length}).`, 6e3);
      if (typeof console !== "undefined" && typeof console.error === "function") {
        console.error("[Omni-Forge] applyLinkedEdgesForGraphView errors", errors);
      }
      return;
    }
    const graphFocused = await this.openOrFocusGraphViewForLinkedUx();
    this.notice(
      graphFocused ? `Graph link apply complete: ${updated}/${selectedFiles.length} note(s) updated. Graph View focused.` : `Graph link apply complete: ${updated}/${selectedFiles.length} note(s) updated. (Graph View focus unavailable)`,
      5e3
    );
  }
  async openOrFocusGraphViewForLinkedUx() {
    const existing = this.app.workspace.getLeavesOfType("graph");
    if (existing.length > 0) {
      await this.app.workspace.setActiveLeaf(existing[0], true, true);
      return true;
    }
    const commands = ["graph:open", "workspace:open-graph-view"];
    for (const id of commands) {
      const command = this.app.commands.findCommand(id);
      if (!command) {
        continue;
      }
      try {
        const ok = await this.app.commands.executeCommandById(id);
        if (ok !== false) {
          const leaves = this.app.workspace.getLeavesOfType("graph");
          if (leaves.length > 0) {
            await this.app.workspace.setActiveLeaf(leaves[0], true, true);
          }
          return true;
        }
      } catch (error) {
        if (typeof console !== "undefined" && typeof console.warn === "function") {
          console.warn("[Omni-Forge] failed to open graph view", id, error);
        }
      }
    }
    return false;
  }
  async createBackupForFiles(files) {
    const uniquePaths = [...new Set(files.map((file) => file.path))].sort(
      (a, b) => a.localeCompare(b)
    );
    if (uniquePaths.length === 0) {
      return null;
    }
    const backupRoot = this.resolveSafeFolderPath(
      this.settings.backupRootPath,
      DEFAULT_SETTINGS.backupRootPath,
      "Backup root"
    );
    const backupFolder = (0, import_obsidian4.normalizePath)(
      `${backupRoot}/${formatBackupStamp(/* @__PURE__ */ new Date())}`
    );
    await this.ensureFolderPath(backupFolder);
    for (const path of uniquePaths) {
      const entry = this.app.vault.getAbstractFileByPath(path);
      if (!(entry instanceof import_obsidian4.TFile)) {
        continue;
      }
      const content = await this.app.vault.cachedRead(entry);
      const outputPath = (0, import_obsidian4.normalizePath)(`${backupFolder}/${path}`);
      await this.ensureParentFolder(outputPath);
      await this.app.vault.adapter.write(outputPath, content);
    }
    const manifest = {
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      backupFolder,
      fileCount: uniquePaths.length,
      files: uniquePaths
    };
    const manifestPath = (0, import_obsidian4.normalizePath)(`${backupFolder}/manifest.json`);
    await this.app.vault.adapter.write(manifestPath, JSON.stringify(manifest, null, 2));
    await this.pruneOldBackups();
    return backupFolder;
  }
  async pruneOldBackups() {
    const keepCount = this.settings.backupRetentionCount;
    if (!Number.isFinite(keepCount) || keepCount < 1) {
      return;
    }
    const backupRoot = this.resolveSafeFolderPath(
      this.settings.backupRootPath,
      DEFAULT_SETTINGS.backupRootPath,
      "Backup root"
    );
    const exists = await this.app.vault.adapter.exists(backupRoot);
    if (!exists) {
      return;
    }
    const list = await this.app.vault.adapter.list(backupRoot);
    if (list.folders.length <= keepCount) {
      return;
    }
    const sorted = [...list.folders].sort((a, b) => b.localeCompare(a));
    const toDelete = sorted.slice(keepCount);
    for (const folder of toDelete) {
      await this.app.vault.adapter.rmdir(folder, true);
    }
  }
  async getLatestBackupFolder() {
    var _a;
    const backupRoot = this.resolveSafeFolderPath(
      this.settings.backupRootPath,
      DEFAULT_SETTINGS.backupRootPath,
      "Backup root"
    );
    const exists = await this.app.vault.adapter.exists(backupRoot);
    if (!exists) {
      return null;
    }
    const list = await this.app.vault.adapter.list(backupRoot);
    if (list.folders.length === 0) {
      return null;
    }
    const sorted = [...list.folders].sort((a, b) => a.localeCompare(b));
    return (_a = sorted[sorted.length - 1]) != null ? _a : null;
  }
  async restoreFromLatestBackup() {
    const latestBackupFolder = await this.getLatestBackupFolder();
    if (!latestBackupFolder) {
      this.notice("No backup folder found.");
      return;
    }
    const manifestPath = (0, import_obsidian4.normalizePath)(`${latestBackupFolder}/manifest.json`);
    const manifestExists = await this.app.vault.adapter.exists(manifestPath);
    if (!manifestExists) {
      this.notice(`Backup manifest is missing: ${manifestPath}`);
      return;
    }
    const manifestRaw = await this.app.vault.adapter.read(manifestPath);
    const manifest = JSON.parse(manifestRaw);
    if (!Array.isArray(manifest.files) || manifest.files.length === 0) {
      this.notice("Backup manifest does not contain files.");
      return;
    }
    let restoredCount = 0;
    for (const originalPath of manifest.files) {
      const backupFilePath = (0, import_obsidian4.normalizePath)(`${latestBackupFolder}/${originalPath}`);
      const exists = await this.app.vault.adapter.exists(backupFilePath);
      if (!exists) {
        continue;
      }
      const content = await this.app.vault.adapter.read(backupFilePath);
      await this.ensureParentFolder(originalPath);
      const current = this.app.vault.getAbstractFileByPath(originalPath);
      if (current instanceof import_obsidian4.TFile) {
        await this.app.vault.modify(current, content);
      } else {
        await this.app.vault.create(originalPath, content);
      }
      restoredCount += 1;
    }
    this.notice(
      `Restore completed from ${latestBackupFolder}. Restored ${restoredCount} file(s).`,
      6e3
    );
  }
  async generateMocFromSelection(suggestions) {
    var _a, _b, _c;
    const selectedFiles = this.getSelectedFiles();
    if (selectedFiles.length === 0) {
      this.notice("No selected notes available for MOC.");
      return;
    }
    const suggestionMap = /* @__PURE__ */ new Map();
    for (const item of suggestions != null ? suggestions : []) {
      suggestionMap.set(item.file.path, item);
    }
    const records = selectedFiles.map((file) => {
      var _a2, _b2;
      const suggested = suggestionMap.get(file.path);
      if (suggested) {
        return { file, metadata: suggested.proposed };
      }
      const frontmatter = (_b2 = (_a2 = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a2.frontmatter) != null ? _b2 : {};
      return {
        file,
        metadata: normalizeManagedFrontmatter(
          extractManagedFrontmatter(frontmatter)
        )
      };
    });
    const groups = /* @__PURE__ */ new Map();
    for (const record of records) {
      const group = ((_a = record.metadata.index) == null ? void 0 : _a.trim()) || "uncategorized";
      if (!groups.has(group)) {
        groups.set(group, []);
      }
      (_b = groups.get(group)) == null ? void 0 : _b.push(record);
    }
    const lines = [];
    lines.push("# Selected Knowledge MOC");
    lines.push("");
    lines.push(`Updated: ${(/* @__PURE__ */ new Date()).toISOString()}`);
    lines.push(`Source notes: ${selectedFiles.length}`);
    lines.push("");
    const sortedGroups = [...groups.keys()].sort((a, b) => a.localeCompare(b));
    for (const group of sortedGroups) {
      lines.push(`## ${group}`);
      const items = (_c = groups.get(group)) != null ? _c : [];
      items.sort((a, b) => a.file.path.localeCompare(b.file.path));
      for (const item of items) {
        const linkText = this.app.metadataCache.fileToLinktext(item.file, "", true);
        const topicSuffix = item.metadata.topic ? ` - ${item.metadata.topic}` : "";
        lines.push(`- [[${linkText}]]${topicSuffix}`);
      }
      lines.push("");
    }
    const outputPath = await this.allocateTimestampedMocPath(this.settings.mocPath);
    await this.ensureParentFolder(outputPath);
    const existing = this.app.vault.getAbstractFileByPath(outputPath);
    const content = `${lines.join("\n").trim()}
`;
    if (existing instanceof import_obsidian4.TFile) {
      await this.app.vault.modify(existing, content);
    } else {
      await this.app.vault.create(outputPath, content);
    }
    this.notice(`MOC saved: ${outputPath}`);
  }
  async ensureFolderPath(folderPath) {
    const normalized = (0, import_obsidian4.normalizePath)(folderPath);
    if (normalized.length === 0) {
      return;
    }
    const parts = normalized.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const existing = this.app.vault.getAbstractFileByPath(currentPath);
      if (existing instanceof import_obsidian4.TFolder) {
        continue;
      }
      if (existing instanceof import_obsidian4.TFile) {
        continue;
      }
      await this.app.vault.createFolder(currentPath);
    }
  }
  async ensureParentFolder(path) {
    const normalized = (0, import_obsidian4.normalizePath)(path);
    const chunks = normalized.split("/");
    chunks.pop();
    if (chunks.length === 0) {
      return;
    }
    await this.ensureFolderPath(chunks.join("/"));
  }
};
